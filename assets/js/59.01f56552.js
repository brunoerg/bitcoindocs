(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{434:function(e,t,n){"use strict";n.r(t);var o=n(43),s=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_152"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_152"}},[e._v("#")]),e._v(" 152")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  BIP: 152\n  Layer: Peer Services\n  Title: Compact Block Relay\n  Author: Matt Corallo <bip152@bluematt.me>\n  Comments-Summary: Unanimously Recommended for implementation\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0152\n  Status: Final\n  Type: Standards Track\n  Created: 2016-04-27\n  License: PD\n")])])]),n("h2",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("Compact blocks on the wire as a way to save bandwidth for nodes on the\nP2P network.")]),e._v(" "),n("p",[e._v('The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL\nNOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and\n"OPTIONAL" in this document are to be interpreted as described in RFC\n2119.')]),e._v(" "),n("h2",{attrs:{id:"motivation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),n("p",[e._v("Historically, the Bitcoin P2P protocol has not been very bandwidth\nefficient for block relay. Every transaction in a block is included when\nrelayed, even though a large number of the transactions in a given block\nare already available to nodes before the block is relayed. This causes\nmoderate inbound bandwidth spikes for nodes when receiving blocks, but\ncan cause very significant outbound bandwidth spikes for some nodes\nwhich receive a block before their peers. When such spikes occur, buffer\nbloat can make consumer-grade internet connections temporarily unusable,\nand can delay the relay of blocks to remote peers who may choose to wait\ninstead of redundantly requesting the same block from other, less\ncongested, peers.")]),e._v(" "),n("p",[e._v("Thus, decreasing the bandwidth used during block relay is very useful\nfor many individuals running nodes.")]),e._v(" "),n("p",[e._v("While the goal of this work is explicitly not to reduce block transfer\nlatency, it does, as a side effect reduce block transfer latencies in\nsome rather significant ways. Additionally, this work forms a foundation\nfor future work explicitly targeting low-latency block transfer.")]),e._v(" "),n("h2",{attrs:{id:"specification-for-version-1-specification-for-version-1"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification-for-version-1-specification-for-version-1"}},[e._v("#")]),e._v(" Specification for version 1 {#specification_for_version_1}")]),e._v(" "),n("h3",{attrs:{id:"intended-protocol-flow-intended-protocol-flow"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#intended-protocol-flow-intended-protocol-flow"}},[e._v("#")]),e._v(" Intended Protocol Flow {#intended_protocol_flow}")]),e._v(" "),n("p",[n("code",[e._v("<img src=bip-0152/protocol-flow.png>")]),e._v(" "),n("code",[e._v("</img>")])]),e._v(" "),n("p",[e._v("The protocol is intended to be used in two ways, depending on the peers\nand bandwidth available, as discussed\n"),n("a",{attrs:{href:"#Implementation_Notes",title:"wikilink"}},[e._v("later")]),e._v('. The "high-bandwidth" mode,\nwhich nodes may only enable for a few of their peers, is enabled by\nsetting the first boolean to 1 in a '),n("code",[e._v("sendcmpct")]),e._v(" message. In this mode,\npeers send new block announcements with the short transaction IDs\nalready (via a "),n("code",[e._v("cmpctblock")]),e._v(" message), possibly even before fully\nvalidating the block (as indicated by the grey box in the image above).\nIn some cases no further round-trip is needed, and the receiver can\nreconstruct the block and process it as usual immediately. When some\ntransactions were not available from local sources (ie mempool), a\n"),n("code",[e._v("getblocktxn")]),e._v("/"),n("code",[e._v("blocktxn")]),e._v(" roundtrip is necessary, bringing the best-case\nlatency to the same 1.5*RTT minimum time that nodes take today, though\nwith significantly less bandwidth usage.")]),e._v(" "),n("p",[e._v('The "low-bandwidth" mode is enabled by setting the first boolean to 0\nin a '),n("code",[e._v("sendcmpct")]),e._v(" message. In this mode, peers send new block\nannouncements with the usual inv/headers announcements (as per BIP130,\nand after fully validating the block). The receiving peer may then\nrequest the block using a MSG_CMPCT_BLOCK "),n("code",[e._v("getdata")]),e._v(" request, which will\nreceive a response of the header and short transaction IDs. In some\ncases no further round-trip is needed, and the receiver can reconstruct\nthe block and process it as usual, taking the same 1.5*RTT minimum time\nthat nodes take today, though with significantly less bandwidth usage.\nWhen some transactions were not available from local sources (ie\nmempool), a "),n("code",[e._v("getblocktxn")]),e._v("/"),n("code",[e._v("blocktxn")]),e._v(" roundtrip is necessary, bringing\nthe latency to at least 2.5*RTT in this case, again with significantly\nless bandwidth usage than today. Because TCP often exhibits worse\ntransfer latency for larger data sizes (as a multiple of RTT), total\nlatency is expected to be reduced even when the full 2.5*RTT transfer\nmechanism is used.")]),e._v(" "),n("h3",{attrs:{id:"new-data-structures-new-data-structures"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-data-structures-new-data-structures"}},[e._v("#")]),e._v(" New data structures {#new_data_structures}")]),e._v(" "),n("p",[e._v("Several new data structures are added to the P2P network to relay\ncompact blocks: PrefilledTransaction, HeaderAndShortIDs,\nBlockTransactionsRequest, and BlockTransactions.")]),e._v(" "),n("p",[e._v("For the purposes of this section, CompactSize refers to the\nvariable-length integer encoding used across the existing P2P protocol\nto encode array lengths, among other things, in 1, 3, 5 or 9 bytes. Only\nCompactSize encodings which are minimally-encoded (ie the shortest\nlength possible) are used by this spec. Any other CompactSize encodings\nare left with undefined behavior.")]),e._v(" "),n("p",[e._v('Several uses of CompactSize below are "differentially encoded". For\nthese, instead of using raw indexes, the number encoded is the\ndifference between the current index and the previous index, minus one.\nFor example, a first index of 0 implies a real index of 0, a second\nindex of 0 thereafter refers to a real index of 1, etc.')]),e._v(" "),n("h4",{attrs:{id:"prefilledtransaction"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#prefilledtransaction"}},[e._v("#")]),e._v(" PrefilledTransaction")]),e._v(" "),n("p",[e._v("A PrefilledTransaction structure is used in HeaderAndShortIDs to provide\na list of a few transactions explicitly.")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v('Field Name   Type          Size         Encoding                                                                             Purpose\nindex        CompactSize   1, 3 bytes   Compact Size, differentially encoded since the last PrefilledTransaction in a list   The index into the block at which this transaction is\ntx           Transaction   variable     As encoded in "tx" messages sent in response to getdata MSG_TX                     The transaction which is in the block at index index.')]),e._v(" "),n("hr"),e._v(" "),n("h4",{attrs:{id:"headerandshortids"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#headerandshortids"}},[e._v("#")]),e._v(" HeaderAndShortIDs")]),e._v(" "),n("p",[e._v("A HeaderAndShortIDs structure is used to relay a block header, the short\ntransactions IDs used for matching already-available transactions, and a\nselect few transactions which we expect a peer may be missing.")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v('Field Name            Type                            Size                                 Encoding                                                                            Purpose\nheader                Block header                    80 bytes                             First 80 bytes of the block as defined by the encoding used by "block" messages   The header of the block being provided\nnonce                 uint64_t                        8 bytes                              Little Endian                                                                       A nonce for use in short transaction ID calculations\nshortids_length       CompactSize                     1 or 3 bytes                         As used to encode array lengths elsewhere'),n("br"),e._v("\nshortids              List of 6-byte integers         6*shortids_length bytes             Little Endian                                                                       The short transaction IDs calculated from the transactions which were not provided explicitly in prefilledtxn\nprefilledtxn_length   CompactSize                     1 or 3 bytes                         As used to encode array lengths elsewhere"),n("br"),e._v("\nprefilledtxn          List of PrefilledTransactions   variable size*prefilledtxn_length   As defined by PrefilledTransaction definition, above                                Used to provide the coinbase transaction and a select few which we expect a peer may be missing")]),e._v(" "),n("hr"),e._v(" "),n("h4",{attrs:{id:"blocktransactionsrequest"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#blocktransactionsrequest"}},[e._v("#")]),e._v(" BlockTransactionsRequest")]),e._v(" "),n("p",[e._v("A BlockTransactionsRequest structure is used to list transaction indexes\nin a block being requested.")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("Field Name       Type                   Size                           Encoding                                                                 Purpose\nblockhash        Binary blob            32 bytes                       The output from a double-SHA256 of the block header, as used elsewhere   The blockhash of the block which the transactions being requested are in\nindexes_length   CompactSize            1 or 3 bytes                   As used to encode array lengths elsewhere"),n("br"),e._v("\nindexes          List of CompactSizes   1 or 3 bytes*indexes_length   Differentially encoded                                                   The indexes of the transactions being requested in the block")]),e._v(" "),n("hr"),e._v(" "),n("h4",{attrs:{id:"blocktransactions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#blocktransactions"}},[e._v("#")]),e._v(" BlockTransactions")]),e._v(" "),n("p",[e._v("A BlockTransactions structure is used to provide some of the\ntransactions in a block, as requested.")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("Field Name            Type                   Size           Encoding                                                                 Purpose\nblockhash             Binary blob            32 bytes       The output from a double-SHA256 of the block header, as used elsewhere   The blockhash of the block which the transactions being provided are in\ntransactions_length   CompactSize            1 or 3 bytes   As used to encode array lengths elsewhere"),n("br"),e._v('\ntransactions          List of Transactions   variable       As encoded in "tx" messages in response to getdata MSG_TX              The transactions provided')]),e._v(" "),n("hr"),e._v(" "),n("h4",{attrs:{id:"short-transaction-ids-short-transaction-ids"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#short-transaction-ids-short-transaction-ids"}},[e._v("#")]),e._v(" Short transaction IDs {#short_transaction_ids}")]),e._v(" "),n("p",[e._v("Short transaction IDs are used to represent a transaction without\nsending a full 256-bit hash. They are calculated by:")]),e._v(" "),n("ol",[n("li",[e._v("single-SHA256 hashing the block header with the nonce appended (in\nlittle-endian)")]),e._v(" "),n("li",[e._v("Running SipHash-2-4 with the input being the transaction ID and the\nkeys (k0/k1) set to the first two little-endian 64-bit integers from\nthe above hash, respectively.")]),e._v(" "),n("li",[e._v("Dropping the 2 most significant bytes from the SipHash output to\nmake it 6 bytes.")])]),e._v(" "),n("h3",{attrs:{id:"new-messages-new-messages"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-messages-new-messages"}},[e._v("#")]),e._v(" New messages {#new_messages}")]),e._v(" "),n("p",[e._v("A new inv type (MSG_CMPCT_BLOCK == 4) and several new protocol messages\nare added: sendcmpct, cmpctblock, getblocktxn, and blocktxn.")]),e._v(" "),n("h4",{attrs:{id:"sendcmpct"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sendcmpct"}},[e._v("#")]),e._v(" sendcmpct")]),e._v(" "),n("ol",[n("li",[e._v('The sendcmpct message is defined as a message containing a 1-byte\ninteger followed by a 8-byte integer where pchCommand ==\n"sendcmpct".')]),e._v(" "),n("li",[e._v("The first integer SHALL be interpreted as a boolean (and MUST have a\nvalue of either 1 or 0)")]),e._v(" "),n("li",[e._v("The second integer SHALL be interpreted as a little-endian version\nnumber. Nodes sending a sendcmpct message MUST currently set this\nvalue to 1.")]),e._v(" "),n("li",[e._v('Upon receipt of a "sendcmpct" message with the first and second\nintegers set to 1, the node SHOULD announce new blocks by sending a\ncmpctblock message.')]),e._v(" "),n("li",[e._v('Upon receipt of a "sendcmpct" message with the first integer set\nto 0, the node SHOULD NOT announce new blocks by sending a\ncmpctblock message, but SHOULD announce new blocks by sending invs\nor headers, as defined by BIP130.')]),e._v(" "),n("li",[e._v('Upon receipt of a "sendcmpct" message with the second integer set\nto something other than 1, nodes MUST treat the peer as if they had\nnot received the message (as it indicates the peer will provide an\nunexpected encoding in cmpctblock, and/or other, messages). This\nallows future versions to send duplicate sendcmpct messages with\ndifferent versions as a part of a version handshake for future\nversions. See Protocol Versioning section, below, for more info on\nthe specifics of the version-negotiation mechanics.')]),e._v(" "),n("li",[e._v("Nodes SHOULD check for a protocol version of >= 70014 before\nsending sendcmpct messages.")]),e._v(" "),n("li",[e._v("Nodes MUST NOT send a request for a MSG_CMPCT_BLOCK object to a peer\nbefore having received a sendcmpct message from that peer.")]),e._v(" "),n("li",[e._v("Nodes MUST NOT request a MSG_CMPCT_BLOCK object before having sent\nall sendcmpct messages to that peer which they intend to send, as\nthe peer cannot know what version protocol to use in the response.")])]),e._v(" "),n("h4",{attrs:{id:"msg-cmpct-block"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#msg-cmpct-block"}},[e._v("#")]),e._v(" MSG_CMPCT_BLOCK")]),e._v(" "),n("ol",[n("li",[e._v("getdata messages may now contain requests for MSG_CMPCT_BLOCK\nobjects.")]),e._v(" "),n("li",[e._v("Upon receipt of a getdata containing a request for a MSG_CMPCT_BLOCK\nobject with the hash of a block which was recently announced and is\nclose to the tip of the best chain of the receiver and after having\nsent the requesting peer a sendcmpct message, nodes MUST respond\nwith a cmpctblock message containing appropriate data representing\nthe block being requested.")]),e._v(" "),n("li",[e._v("Upon receipt of a getdata containing a request for a MSG_CMPCT_BLOCK\nobject for which a cmpctblock message is not sent in response, a\nblock message containing the requested block in non-compact form\nMUST be sent.")]),e._v(" "),n("li",[e._v("MSG_CMPCT_BLOCK inv objects MUST NOT appear anywhere except for in\ngetdata messages.")])]),e._v(" "),n("h4",{attrs:{id:"cmpctblock"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cmpctblock"}},[e._v("#")]),e._v(" cmpctblock")]),e._v(" "),n("ol",[n("li",[e._v('The cmpctblock message is defined as a message containing a\nserialized HeaderAndShortIDs message and pchCommand ==\n"cmpctblock".')]),e._v(" "),n("li",[e._v("Upon receipt of a cmpctblock message after sending a sendcmpct\nmessage, nodes SHOULD calculate the short transaction ID for each\nunconfirmed transaction they have available (ie in their mempool)\nand compare each to each short transaction ID in the cmpctblock\nmessage.")]),e._v(" "),n("li",[e._v("After finding already-available transactions, nodes which do not\nhave all transactions available to reconstruct the full block SHOULD\nrequest the missing transactions using a getblocktxn message.")]),e._v(" "),n("li",[e._v("A node MUST NOT send a cmpctblock message unless they are able to\nrespond to a getblocktxn message which requests every transaction in\nthe block.")]),e._v(" "),n("li",[e._v("A node MUST NOT send a cmpctblock message without having validated\nthat the header properly commits to each transaction in the block,\nand properly builds on top of the existing, fully-validated chain\nwith a valid proof-of-work either as a part of the current most-work\nvalid chain, or building directly on top of it. A node MAY send a\ncmpctblock before validating that each transaction in the block\nvalidly spends existing UTXO set entries.")])]),e._v(" "),n("h4",{attrs:{id:"getblocktxn"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#getblocktxn"}},[e._v("#")]),e._v(" getblocktxn")]),e._v(" "),n("ol",[n("li",[e._v('The getblocktxn message is defined as a message containing a\nserialized BlockTransactionsRequest message and pchCommand ==\n"getblocktxn".')]),e._v(" "),n("li",[e._v("Upon receipt of a properly-formatted getblocktxn message, nodes\nwhich recently provided the sender of such a message a cmpctblock\nfor the block hash identified in this message MUST respond with\neither an appropriate blocktxn message, or a full block message. A\nblocktxn response MUST contain exactly and only each transaction\nwhich is present in the appropriate block at the index specified in\nthe getblocktxn indexes list, in the order requested.")])]),e._v(" "),n("h4",{attrs:{id:"blocktxn"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#blocktxn"}},[e._v("#")]),e._v(" blocktxn")]),e._v(" "),n("ol",[n("li",[e._v('The blocktxn message is defined as a message containing a serialized\nBlockTransactions message and pchCommand == "blocktxn".')]),e._v(" "),n("li",[e._v("Upon receipt of a properly-formatted requested blocktxn message,\nnodes SHOULD attempt to reconstruct the full block by:\n"),n("ol",[n("li",[e._v("Taking the prefilledtxn transactions from the original\ncmpctblock and placing them in the marked positions.")]),e._v(" "),n("li",[e._v("For each short transaction ID from the original cmpctblock, in\norder, find the corresponding transaction either from the\nblocktxn message or from other sources and place it in the first\navailable position in the block.")])])]),e._v(" "),n("li",[e._v("Once the block has been reconstructed, it shall be processed as\nnormal, keeping in mind that short transaction IDs are expected to\noccasionally collide, and that nodes MUST NOT be penalized for such\ncollisions, wherever they appear.")])]),e._v(" "),n("h2",{attrs:{id:"protocol-versioning-protocol-versioning"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#protocol-versioning-protocol-versioning"}},[e._v("#")]),e._v(" Protocol Versioning {#protocol_versioning}")]),e._v(" "),n("ol",[n("li",[e._v("The protocol version negotiation allows two nodes to agree on the\nversions of compact blocks which they will exchange. As it is only\nin a single field, it does not allow a node to support a specific\nversion in only one direction (sending or receiving).")]),e._v(" "),n("li",[e._v("Upon connection establishment, a node SHOULD send a burst of\nsendcmpct messages containing every version of compact block\nencodings for which they are willing to support sending cmpctblock\nand blocktxn messages, and receiving getblocktxn messages. These\nmessages SHOULD be ordered in the order of the priority which the\nnode wishes to receive cmpctblock/blocktxn messages, with the\nhighest-priority version sendcmpct message sent first.")]),e._v(" "),n("li",[e._v("The encoding version used to send a cmpctblock or blocktxn message\nor to receive a getblocktxn message MUST be the second integer\n(version number) in the first sendcmpct message received for which a\nsendcmpct message with the same version number was sent.")]),e._v(" "),n("li",[e._v("Nodes MUST NOT send a sendcmpct message which contains a version\nnumber other than the version number which has been negotiated for\nreceiving cmpctblock/blocktxn messages after sending a request for a\nMSG_CMPCT_BLOCK object, sending a cmpctblock, getblocktxn, blocktxn,\nor pong message.")]),e._v(" "),n("li",[e._v("As a node must send all sendcmpct messages which contain a novel\nversion announcement before any other compact block-related\nmessages, it is possible to determine which version of compact\nblocks will be used for each object received. It is, however, not\npossible to know which version will be used to encode the response\nto a request for a compact block object before any\nMSG_CMPCT_BLOCK-containing getdata, cmpctblock, getblocktxn,\nblocktxn, or ping/pong messages have been exchanged.")]),e._v(" "),n("li",[e._v("Thus, if a node wishes to determine exactly which version of compact\nblocks will be used before requesting a compact block object, it\nmust send all of its sendcmpct version announcements, followed by a\nping, and wait for the pong response to ensure it has received all\nsendcmpctblock version announcement messages from the remote peer.\nNodes can, obviously, however, determine that the version used will\nbe at least a certain version (in their priority order) after having\nreceived a sendcmpct message from the remote peer containing that\nversion as the second integer.")])]),e._v(" "),n("h3",{attrs:{id:"sample-version-implementation-sample-version-implementation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sample-version-implementation-sample-version-implementation"}},[e._v("#")]),e._v(" Sample Version Implementation {#sample_version_implementation}")]),e._v(" "),n("ol",[n("li",[e._v("By way of example, an implementation of the above protocol might\nlook like the following.")]),e._v(" "),n("li",[e._v("Upon exchanging version/verack messages, a node immediately sends\nits list of sendcmpct announcements to the other side, with the\nversion which it wants to receive sent first.")]),e._v(" "),n("li",[e._v('Upon receiving the first sendcmpct announcement with a protocol\nversion which is understood from the remote peer, a node will "lock\nin" the compact block encoding version which will be used to encode\ncompact blocks to that peer.')]),e._v(" "),n("li",[e._v("The node then sets the current receive-protocol-version in use on\nthe connection to that version, and uses it to decode new compact\nblock messages.")]),e._v(" "),n("li",[e._v("Upon receiving subsequent sendcmpct announcements with a protocol\nversion which is understood from the remote peer (ie a version which\nhas been announced using a sendcmpct in the other direction), a node\nwill check if that protocol version is higher-receive-priority than\nthe current receive-protocol-version in use on the connection, and\nswitch to that version for decoding new compact block messages\nreceived.")]),e._v(" "),n("li",[e._v("A node might wish to keep a flag for each peer which indicates\ncompact block version negotiation is complete, which can be set upon\nreceiving any compact block-related, or pong message.")]),e._v(" "),n("li",[e._v("The above implementation requires only a compile-time list of\nsupported versions in some static priority order, two version fields\nper peer, and an optional negotiation-complete boolean per-peer.")])]),e._v(" "),n("h2",{attrs:{id:"specification-for-version-2-specification-for-version-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification-for-version-2-specification-for-version-2"}},[e._v("#")]),e._v(" Specification for version 2 {#specification_for_version_2}")]),e._v(" "),n("p",[e._v("Compact blocks version 2 is almost identical to version 1, but supports\nsegregated witness transactions (BIP 141 and BIP 144). The changes are:")]),e._v(" "),n("ol",[n("li",[e._v("The second integer (version number) inside sendcmpct is 2 instead of\n1 (see Protocol Versioning section, above).")]),e._v(" "),n("li",[e._v("Transactions inside cmpctblock messages (both those used as direct\nannouncement and those in response to getdata) and in blocktxn\nshould include witness data, using the same format as responses to\ngetdata MSG_WITNESS_TX, specified in BIP144.")]),e._v(" "),n("li",[e._v("Short transaction IDs sent to us in cmpctblock messages, and sent by\nus in getblocktxn messages, are computed using the same process as\nin version 1, but using the wtxid as defined in BIP 141 instead of\nthe txid. Note that, though a node normally SHOULD, if a node does\nnot include (ie must then include the short ID for) the coinbase\ntransaction, it must be computed by encoding the transaction in\nwitness format as defined by BIP 141.")]),e._v(" "),n("li",[e._v("Upon receipt of a getdata containing a request for a MSG_CMPCT_BLOCK\nobject for which a cmpctblock message is not sent in response, the\nblock message containing the requested block in non-compact form\nMUST be encoded with witnesses (as is sent in reply to a\nMSG_WITNESS_BLOCK getdata) if the protocol version used to encode\nthe cmpctblock message would have been 2, and encoded without\nwitnesses (as is sent in response to a MSG_BLOCK getdata) if the\nprotocol version used to encode the cmpctblock message would have\nbeen 1.")])]),e._v(" "),n("h2",{attrs:{id:"implementation-notes-implementation-notes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#implementation-notes-implementation-notes"}},[e._v("#")]),e._v(" Implementation Notes {#implementation_notes}")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("For nodes which have sufficient inbound bandwidth, sending a\nsendcmpct message with the first integer set to 1 to up to 3 peers\nis RECOMMENDED. If possible, it is RECOMMENDED that those peers be\nselected based on their past performance in providing blocks quickly\n(eg the three peers which provided the highest number of the recent\nN blocks the quickest), allowing nodes to receive blocks which come\nfrom those peers in only 0.5*RTT.")])]),e._v(" "),n("li",[n("p",[e._v("Nodes MUST NOT send such sendcmpct messages to more than three\npeers, as it encourages wasting outbound bandwidth across the\nnetwork.")])]),e._v(" "),n("li",[n("p",[e._v("All nodes SHOULD send a sendcmpct message to all appropriate peers.\nThis will reduce their outbound bandwidth usage by allowing their\npeers to request compact blocks instead of full blocks.")])]),e._v(" "),n("li",[n("p",[e._v("Nodes with limited inbound bandwidth SHOULD request blocks using\nMSG_CMPCT_BLOCK/getblocktxn requests, when possible. While this\nincreases worst-case message round-trips, it is expected to reduce\noverall transfer latency as TCP is more likely to exhibit poor\nthroughput on low-bandwidth nodes.")])]),e._v(" "),n("li",[n("p",[e._v("Nodes sending cmpctblock messages SHOULD limit prefilledtxn to 10KB\nof transactions. When in doubt, nodes SHOULD only include the\ncoinbase transaction in prefilledtxn.")])]),e._v(" "),n("li",[n("p",[e._v("Nodes MAY pick one nonce per block they wish to send, and only build\na cmpctblock message once for all peers which they wish to send a\ngiven block to. Nodes SHOULD NOT use the same nonce across multiple\ndifferent blocks.")])]),e._v(" "),n("li",[n("p",[e._v("Nodes MAY impose additional requirements on when they announce new\nblocks by sending cmpctblock messages. For example, nodes with\nlimited outbound bandwidth MAY choose to announce new blocks using\ninv/header messages (as per BIP130) to conserve outbound bandwidth.")])]),e._v(" "),n("li",[n("p",[e._v("Note that the MSG_CMPCT_BLOCK section does not require that nodes\nrespond to MSG_CMPCT_BLOCK getdata requests for blocks which they\ndid not recently announce. This allows nodes to calculate cmpctblock\nmessages at announce-time instead of at request-time. Blocks which\nare requested with a MSG_CMPCT_BLOCK getdata, but which are not\nresponded to with a cmpctblock message MUST be responded to with a\nblock message, allowing nodes to request all blocks using\nMSG_CMPCT_BLOCK getdatas and rely on their peer to pick an\nappropriate response.")])]),e._v(" "),n("li",[n("p",[e._v("While the current version sends transactions with the same encodings\nas are used in tx messages and elsewhere in the protocol, the\nversion field in sendcmpct is intended to allow this to change in\nthe future. For this reason, it is recommended that the code used to\ndecode PrefilledTransaction and BlockTransactions messages be\nprepared to take a different transaction encoding, if and when the\nversion field in sendcmpct changes in a future BIP.")])]),e._v(" "),n("li",[n("p",[e._v("Any undefined behavior in this spec may cause failure to transfer\nblock to, peer disconnection by, or self-destruction by the\nreceiving node. A node receiving non-minimally-encoded CompactSize\nencodings should make a best-effort to eat the sender's cat.")])])]),e._v(" "),n("h3",{attrs:{id:"pre-validation-relay-and-consistency-considerations-pre-validation-relay-and-consistency-considerations"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pre-validation-relay-and-consistency-considerations-pre-validation-relay-and-consistency-considerations"}},[e._v("#")]),e._v(" Pre-Validation Relay and Consistency Considerations {#pre_validation_relay_and_consistency_considerations}")]),e._v(" "),n("ol",[n("li",[n("p",[e._v("As high-bandwidth mode permits relaying of CMPCTBLOCK messages prior\nto full validation (requiring only that the block header is valid\nbefore relay), nodes SHOULD NOT ban a peer for announcing a new\nblock with a CMPCTBLOCK message that is invalid, but has a valid\nheader. For avoidance of doubt, nodes SHOULD bump their peer-to-peer\nprotocol version to 70015 or higher to signal that they will not ban\nor punish a peer for announcing compact blocks prior to full\nvalidation, and nodes SHOULD NOT announce a CMPCTBLOCK to a peer\nwith a version number below 70015 before fully validating the block.")])]),e._v(" "),n("li",[n("p",[e._v('SPV nodes which implement this spec must consider the implications\nof accepting blocks which were not validated by the node which\nprovided them. Especially SPV nodes which allow users to select a\n"trusted full node" to sync from may wish to avoid implementing\nthis spec in high-bandwidth mode.')])]),e._v(" "),n("li",[n("p",[e._v('Note that this spec does not change the requirement that nodes only\nrelay information about blocks which they have fully validated in\nresponse to GETDATA/GETHEADERS/GETBLOCKS/etc requests. Nodes which\nannounce using CMPCTBLOCK message and then receive a request for\nassociated block data SHOULD ensure that messages do not go\nunresponded to, and that the appropriate data is provided after the\nblock has been validated, subject to standard message-response\nordering requirements. Note that no requirement is added that the\nnode respond to the request with the new block included in eg\nGETHEADERS or GETBLOCKS messages, but the node SHOULD re-announce\nthe block using the associated announcement methods after validation\nhas completed if it is not included in the original response. On the\nother hand, nodes SHOULD delay responding to GETDATA requests for\nthe block until validation has completed, stalling all message\nprocessing for the associated peer. REJECT messages are not\nconsidered "responses" for the purpose of this section.')])]),e._v(" "),n("li",[n("p",[e._v("As a result of the above requirements, implementors may wish to\nconsider the potential for the introduction of delays in responses\nwhile remote peers validate blocks, avoiding delay-causing requests\nwhere possible.")])])]),e._v(" "),n("h2",{attrs:{id:"justification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#justification"}},[e._v("#")]),e._v(" Justification")]),e._v(" "),n("h4",{attrs:{id:"protocol-design-protocol-design"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#protocol-design-protocol-design"}},[e._v("#")]),e._v(" Protocol design {#protocol_design}")]),e._v(" "),n("p",[e._v("There have been many proposals to save wire bytes when relaying blocks.\nMany of them have a two-fold goal of reducing block relay time and thus\nrely on the use of significant processing power in order to avoid\nintroducing additional worst-case RTTs. Because this work is not focused\nprimarily on reducing block relay time, its design is much simpler (ie\ndoes not rely on set reconciliation protocols). Still, in testing at the\ntime of writing, nodes are able to relay blocks without the extra\ngetblocktxn/blocktxn RTT around 90% of the time. With a smart\ncompact-block-announcement policy, it is thus expected that this work\nmight allow blocks to be relayed between nodes in 0.5*RTT instead of\n1.5*RTT at least 75% of the time.")]),e._v(" "),n("h4",{attrs:{id:"short-transaction-id-calculation-short-transaction-id-calculation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#short-transaction-id-calculation-short-transaction-id-calculation"}},[e._v("#")]),e._v(" Short transaction ID calculation {#short_transaction_id_calculation}")]),e._v(" "),n("p",[e._v("There are several design goals for the Short ID calculation:")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("Performance")]),e._v(" The sender needs to compute short IDs for all block\ntransactions, and the receiver for all mempool transactions they are\nbeing compared to. As we're easily talking about several thousand\ntransactions, sub-microsecond processing per-transactions is needed.")]),e._v(" "),n("li",[n("strong",[e._v("Space")]),e._v(" cmpctblock messages are never optional in this protocol,\nand contain a short ID for each non-prefilled transaction in the\nblock. Thus, the size of short IDs is directly proportional to the\nmaximum bandwidth savings possible.")]),e._v(" "),n("li",[n("strong",[e._v("Collision resistance")]),e._v(" It should be hard for network participants\nto create transactions that cause collisions. If an attacker were\nable to cause such collisions, filling mempools (and, thus, blocks)\nwith them would cause poor network propagation of new (or\nnon-attacker, in the case of a miner) blocks.")])]),e._v(" "),n("p",[e._v("SipHash is a secure, fast, and simple 64-bit MAC designed for network\ntraffic authentication and collision-resistant hash tables. We truncate\nthe output from SipHash-2-4 to 48 bits (see next section) in order to\nminimize space. The resulting 48-bit hash is certainly not large enough\nto avoid intentionally created individual collisons, but by using the\nblock hash as a key to SipHash, an attacker cannot predict what keys\nwill be used once their transactions are actually included in a relayed\nblock. We mix in a per-connection 64-bit nonce to obtain independent\nshort IDs on every connection, so that even block creators cannot\ncontrol where collisions occur, and random collisions only ever affect a\nsmall number of connections at any given time. The mixing is done using\nSHA256(block_header || nonce), which is slow compared to SipHash, but\nonly done once per block. It also adds the ability for nodes to choose\nthe nonce in a better than random way to minimize collisions, though\nthat is not necessary for correct behaviour. Conversely, nodes can also\nabuse this ability to increase their ability to introduce collisions in\nthe blocks they relay themselves. However, they can already cause more\nproblems by simply refusing to relay blocks. That is inevitable, and\nthis design only seeks to prevent network-wide misbehavior.")]),e._v(" "),n("h4",{attrs:{id:"random-collision-probabilty-random-collision-probabilty"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#random-collision-probabilty-random-collision-probabilty"}},[e._v("#")]),e._v(" Random collision probabilty {#random_collision_probabilty}")]),e._v(" "),n("p",[e._v("Thanks to the block-header-based SipHash keys, we can assume that the\nonly collisions on links between honest nodes are random ones.")]),e._v(" "),n("p",[e._v("For each of the "),n("em",[e._v("t")]),e._v(" block transactions, the receiver will compare its\nreceived short ID with that of a set of "),n("em",[e._v("m")]),e._v(" mempool transactions. We\nassume that each of those "),n("em",[e._v("t")]),e._v(" has a chance "),n("em",[e._v("r")]),e._v(" to be included in that\nset of "),n("em",[e._v("m")]),e._v(". If we use "),n("em",[e._v("B")]),e._v(" bits short IDs, for each comparison between a\nreceived short ID and a mempool transaction, there is a chance of *P = 1")]),e._v(" "),n("ul",[n("li",[e._v("1 / 2^B* that a mismatch is detected as such.")])]),e._v(" "),n("p",[e._v("When comparing a given block transaction to the whole set of mempool\ntransactions, there are 5 cases to distinguish:")]),e._v(" "),n("ol",[n("li",[e._v("The receiver has exactly one match, which is the correct one. This\nhas chance "),n("em",[e._v("r * P^(m - 1)")]),e._v(".")]),e._v(" "),n("li",[e._v("The receiver has no matches. This has chance "),n("em",[e._v("(1 - r) * P^m")]),e._v(".")]),e._v(" "),n("li",[e._v("The receiver has at least two matches, one of which is correct. This\nhas chance "),n("em",[e._v("r * (1 - P^(m - 1))")]),e._v(".")]),e._v(" "),n("li",[e._v("The receiver has at least two matches, both of which are incorrect.\nThis has chance "),n("em",[e._v("(1 - r) * (1 - P^m - m * (1 - P) * P^(m -\n1))")]),e._v(".")]),e._v(" "),n("li",[e._v("The receiver has exactly one match, but an incorrect one. This has\nchance "),n("em",[e._v("(1 - r) * m * (1 - P) * P^(m - 1)")]),e._v(".")])]),e._v(" "),n("p",[e._v("(note that these 5 numbers always add up to 100%)")]),e._v(" "),n("p",[e._v("In case 1, we're good. In cases 2, 3, or 4, we request the full\ntransaction because we know we're uncertain. Only in case 5, we fail to\nreconstruct. The chance that case 5 does not occur in any of the "),n("em",[e._v("t")]),e._v("\ntransactions in a block is "),n("em",[e._v("(1 - (1 - r) * m * (1 - P) * P^(m -\n1))^t")]),e._v(". This expression is well approximated by *1 - (1 - r) * m * (1")]),e._v(" "),n("ul",[n("li",[e._v("P) * t* = "),n("em",[e._v("1 - (1 - r) * m * t / 2^B")]),e._v(". Thus, if we want only one\nin F block transmissions between honest nodes to fail under the\nconservative "),n("em",[e._v("r = 0")]),e._v(" assumption, we need "),n("em",[e._v("log2(F * m * t)")]),e._v(" bits hash\nfunctions.")])]),e._v(" "),n("p",[e._v("This means that "),n("em",[e._v("B = 48")]),e._v(" bits short IDs suffice for blocks with up to "),n("em",[e._v("t\n= 10000")]),e._v(" transactions, mempools up to "),n("em",[e._v("m = 100000")]),e._v(" transactions, with\nfailure to reconstruct at most one in "),n("em",[e._v("F = 281474")]),e._v(" blocks. Since failure\nto reconstruct just means we fall back to normal inv/header based relay,\nit isn't necessary to avoid such failure completely. It just needs to\nbe sufficiently rare they have a lower impact than random transmission\nfailures (for example, network disconnection, node overloaded, ...).")]),e._v(" "),n("h4",{attrs:{id:"separate-version-for-segregated-witness-separate-version-for-segregated-witness"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#separate-version-for-segregated-witness-separate-version-for-segregated-witness"}},[e._v("#")]),e._v(" Separate version for segregated witness {#separate_version_for_segregated_witness}")]),e._v(" "),n("p",[e._v("The changes to transaction and block relay in BIP 144 introduce separate\nMSG_FILTERED_ versions of messages in getdata, allowing a receiver to\nchoose individually where witness data is wanted.")]),e._v(" "),n("p",[e._v("This method is not useful for compact blocks because `cmpctblock`\nblocks can be sent unsolicitedly in high-bandwidth mode, so we need to\nnegotiate at least whether those should include witness data up front.\nThere is little use for a validating node that only sometimes processes\nwitness data, so we may as well use that negotiation for everything and\nturn it into a separate protocol version. We also need a means to\ndistinguish different versions of the same transaction with different\nwitnesses for correct reconstruction, so this also forces us to use\nwtxids instead of txids for short IDs everywhere in that case.")]),e._v(" "),n("h2",{attrs:{id:"backward-compatibility-backward-compatibility"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#backward-compatibility-backward-compatibility"}},[e._v("#")]),e._v(" Backward compatibility {#backward_compatibility}")]),e._v(" "),n("p",[e._v("Older clients remain fully compatible and interoperable after this\nchange.")]),e._v(" "),n("h2",{attrs:{id:"implementation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/bitcoin/bitcoin/pull/8068",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/bitcoin/bitcoin/pull/8068"),n("OutboundLink")],1),e._v(" for version 1.\n"),n("a",{attrs:{href:"https://github.com/bitcoin/bitcoin/pull/8393",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/bitcoin/bitcoin/pull/8393"),n("OutboundLink")],1),e._v(" for version 2.")]),e._v(" "),n("h2",{attrs:{id:"acknowledgements"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#acknowledgements"}},[e._v("#")]),e._v(" Acknowledgements")]),e._v(" "),n("p",[e._v("Thanks to Gregory Maxwell for the initial suggestion as well as a lot of\nback-and-forth design and significant testing. Thanks to Nicolas Dorier\nfor the protocol flow diagram.")]),e._v(" "),n("h2",{attrs:{id:"copyright"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),n("p",[e._v("This document is placed in the public domain.")])])}),[],!1,null,null,null);t.default=s.exports}}]);