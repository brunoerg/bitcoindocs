(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{433:function(e,t,n){"use strict";n.r(t);var s=n(43),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_151"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_151"}},[e._v("#")]),e._v(" 151")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  BIP: 151\n  Layer: Peer Services\n  Title: Peer-to-Peer Communication Encryption\n  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n  Comments-Summary: Controversial; some recommendation, and some discouragement\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0151\n  Status: Withdrawn\n  Type: Standards Track\n  Created: 2016-03-23\n  License: PD\n")])])]),n("h2",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("This BIP describes an alternative way that a peer can encrypt their\ncommunication between a selective subset of remote peers.")]),e._v(" "),n("h2",{attrs:{id:"motivation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),n("p",[e._v("The Bitcoin network does not encrypt communication between peers today.\nThis opens up security issues (eg: traffic manipulation by others) and\nallows for mass surveillance / analysis of bitcoin users. Mostly this is\nnegligible because of the nature of Bitcoin's trust model, however, for\nSPV nodes this can have significant privacy impacts [1] and could\nreduce the censorship-resistance of a peer.")]),e._v(" "),n("p",[e._v("Encrypting peer traffic will make analysis and specific user targeting\nmuch more difficult than it currently is. Today it's trivial for a\nnetwork provider or any other men-in-the-middle to identify a Bitcoin\nuser and its controlled addresses/keys (and link with his Google\nprofile, etc.). Just created and broadcasted transactions will reveal\nthe amount and the payee to the network provider.")]),e._v(" "),n("p",[e._v("This BIP also describes a way that data manipulation (blocking commands\nby a intercepting TCP/IP node) would be identifiable by the\ncommunicating peers.")]),e._v(" "),n("p",[e._v("Analyzing the type of p2p communication would still be possible because\nof the characteristics (size, sending-interval, etc.) of the encrypted\nmessages.")]),e._v(" "),n("p",[e._v("Encrypting traffic between peers is already possible with VPN, tor,\nstunnel, curveCP or any other encryption mechanism on a deeper OSI\nlevel, however, most mechanisms are not practical for SPV or other\nDHCP/NAT environment and will require significant knowhow in how to\nsetup such a secure channel.")]),e._v(" "),n("h2",{attrs:{id:"specification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),n("p",[e._v("A peer that supports encryption must accept encryption requests from all\npeers.")]),e._v(" "),n("p",[e._v("An independent ECDH negotiation for both communication directions is\nrequired and therefore a bidirectional communication will use two\nsymmetric cipher keys (one per direction).")]),e._v(" "),n("p",[e._v("Both peers must only send encrypted messages after a successful ECDH\nnegotiation in "),n("em",[e._v("both directions")]),e._v(".")]),e._v(" "),n("p",[e._v("Encryption initialization must happen before sending any other messages\nto the responding peer ("),n("code",[e._v("encinit")]),e._v(" message after a "),n("code",[e._v("version")]),e._v(" message must\nbe ignored).")]),e._v(" "),n("h3",{attrs:{id:"symmetric-encryption-cipher-keys-symmetric-encryption-cipher-keys"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#symmetric-encryption-cipher-keys-symmetric-encryption-cipher-keys"}},[e._v("#")]),e._v(" Symmetric Encryption Cipher Keys {#symmetric_encryption_cipher_keys}")]),e._v(" "),n("p",[e._v("The symmetric encryption cipher keys will be calculated with ECDH/HKDF\nby sharing the pubkeys of an ephemeral key. Once the ECDH secret is\ncalculated on each side, the symmetric encryption cipher keys must be\nderived with HKDF [2] after the following specification:")]),e._v(" "),n("p",[e._v("1. HKDF extraction\n"),n("code",[e._v('PRK = HKDF_EXTRACT(hash=SHA256, salt="bitcoinecdh", ikm=ecdh_secret|cipher-type)')]),e._v(".")]),e._v(" "),n("p",[e._v("2. Derive Key1\n"),n("code",[e._v('K_1 = HKDF_EXPAND(prk=PRK, hash=SHA256, info="BitcoinK1", L=32)')])]),e._v(" "),n("p",[e._v("3. Derive Key2\n"),n("code",[e._v('K_2 = HKDF_EXPAND(prk=PRK, hash=SHA256, info="BitcoinK2", L=32)')])]),e._v(" "),n("p",[e._v("It is important to include the cipher-type into the symmetric cipher key\nderivation to avoid weak-cipher-attacks.")]),e._v(" "),n("h3",{attrs:{id:"session-id-session-id"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#session-id-session-id"}},[e._v("#")]),e._v(" Session ID {#session_id}")]),e._v(" "),n("p",[e._v("Both sides must also calculate the 256bit session-id using\n"),n("code",[e._v('SID = HKDF_EXPAND(prk=PRK, hash=SHA256, info="BitcoinSessionID", L=32)')]),e._v(".\nThe session-id can be used for linking the encryption-session to an\nidentity check.")]),e._v(" "),n("h3",{attrs:{id:"the-encinit-message-type-the-encinit-message-type"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-encinit-message-type-the-encinit-message-type"}},[e._v("#")]),e._v(" The "),n("code",[e._v("encinit")]),e._v(" message type {#the_encinit_message_type}")]),e._v(" "),n("p",[e._v("To request encrypted communication, the requesting peer generates an EC\nephemeral-session-keypair and sends an "),n("code",[e._v("encinit")]),e._v(" message to the\nresponding peer and waits for an "),n("code",[e._v("encack")]),e._v(" message. The responding node\nmust do the same "),n("code",[e._v("encinit")]),e._v("/"),n("code",[e._v("encack")]),e._v(" interaction for the opposite\ncommunication direction.")]),e._v(" "),n("p",[e._v("Field Size   Description                 Data type      Comments")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("33bytes      ephemeral-pubkey            comp.-pubkey   The session pubkey from the requesting peer\n1bytes       symmetric key cipher type   int8           symmetric key cipher type to use")]),e._v(" "),n("p",[e._v("Possible symmetric key ciphers types")]),e._v(" "),n("p",[e._v("Number   symmetric key ciphers type")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("0        chacha20-poly1305@openssh.com")]),e._v(" "),n("h3",{attrs:{id:"chacha20-poly1305-cipher-suite-chacha20-poly1305-cipher-suite"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#chacha20-poly1305-cipher-suite-chacha20-poly1305-cipher-suite"}},[e._v("#")]),e._v(" ChaCha20-Poly1305 Cipher Suite {#chacha20_poly1305_cipher_suite}")]),e._v(" "),n("p",[e._v("ChaCha20 is a stream cipher designed by Daniel Bernstein [3]. It\noperates by permuting 128 fixed bits, 128 or 256 bits of key, a 64 bit\nnonce and a 64 bit counter into 64 bytes of output. This output is used\nas a keystream, with any unused bytes simply discarded.")]),e._v(" "),n("p",[e._v("Poly1305, also by Daniel Bernstein [4], is a one-time Carter-Wegman\nMAC that computes a 128 bit integrity tag given a message and a\nsingle-use 256 bit secret key.")]),e._v(" "),n("p",[e._v("The chacha20-poly1305@openssh.com specified and defined by openssh\n[5] combines these two primitives into an authenticated encryption\nmode. The construction used is based on that proposed for TLS by Adam\nLangley [6], but differs in the layout of data passed to the MAC and\nin the addition of encyption of the packet lengths.")]),e._v(" "),n("p",[n("code",[e._v("K_1")]),e._v(" must be used to only encrypt the payload size of the encrypted\nmessage to avoid leaking information by revealing the message size.")]),e._v(" "),n("p",[n("code",[e._v("K_2")]),e._v(" must be used in conjunction with poly1305 to build an AEAD.")]),e._v(" "),n("p",[e._v("Optimized implementations of ChaCha20-Poly1305 are very fast in general,\ntherefore it is very likely that encrypted messages require less CPU\ncycles per byte then the current unencrypted p2p message format. A quick\nanalysis by Pieter Wuille of the current "),n("em",[e._v("standard implementations")]),e._v(" has\nshown that SHA256 requires more CPU cycles per byte then ChaCha20 &\nPoly1304.")]),e._v(" "),n("h3",{attrs:{id:"the-encack-message-type-the-encack-message-type"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-encack-message-type-the-encack-message-type"}},[e._v("#")]),e._v(" The "),n("code",[e._v("encack")]),e._v(" message type {#the_encack_message_type}")]),e._v(" "),n("p",[e._v("The responding peer accepts the encryption request by sending an\n"),n("code",[e._v("encack")]),e._v(" message.")]),e._v(" "),n("p",[e._v("Field Size   Description        Data type      Comments")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("33bytes      ephemeral-pubkey   comp.-pubkey   The session pubkey from the responding peer")]),e._v(" "),n("p",[e._v("At this point, the shared secret key for the symmetric key cipher must\nbe calculated by using ECDH (own privkey x remote pub key). Private keys\nwill never be transmitted. The shared secret can only be calculated if\nan attacker knows at least one private key and the remote peer's public\nkey.")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("The "),n("code",[e._v("encinit")]),e._v("/"),n("code",[e._v("encack")]),e._v(" interaction must be done from both sides.")])]),e._v(" "),n("li",[e._v("Each communication direction uses its own secret key for the\nsymmetric cipher.")]),e._v(" "),n("li",[e._v("The second "),n("code",[e._v("encinit")]),e._v(" request (from the responding peer) must use the\nsame symmetric cipher type.")]),e._v(" "),n("li",[e._v("All unencrypted messages before the second "),n("code",[e._v("encack")]),e._v(" response (from\nthe responding peer) must be ignored.")]),e._v(" "),n("li",[e._v("After a successful "),n("code",[e._v("encinit")]),e._v("/"),n("code",[e._v("encack")]),e._v(' interaction, the "encrypted\nmessages structure" must be used. Non-encrypted messages from the\nrequesting peer must lead to a connection termination.')])]),e._v(" "),n("p",[e._v("After a successful "),n("code",[e._v("encinit")]),e._v("/"),n("code",[e._v("encack")]),e._v(' interaction from both sides, the\nmessages format must use the "encrypted messages structure".\nNon-encrypted messages from the requesting peer must lead to a\nconnection termination (can be detected by the 4 byte network magic in\nthe unencrypted message structure).')]),e._v(" "),n("h3",{attrs:{id:"encrypted-messages-structure-encrypted-messages-structure"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#encrypted-messages-structure-encrypted-messages-structure"}},[e._v("#")]),e._v(" Encrypted Messages Structure {#encrypted_messages_structure}")]),e._v(" "),n("p",[e._v("Field Size   Description          Data type   Comments")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("4            length               uint32_t    Length of ciphertext payload in number of bytes\n?            ciphertext payload   ?           One or many ciphertext command & message data\n16           MAC tag              ?           128bit MAC-tag")]),e._v(" "),n("p",[e._v("Encrypted messages do not have the 4byte network magic.")]),e._v(" "),n("p",[e._v("The maximum message length needs to be chosen carefully. The 4 byte\nlength field can lead to a required message buffer of 4 GiB. Processing\nthe message before the authentication succeeds must not be done.")]),e._v(" "),n("p",[e._v("The 4byte sha256 checksum is no longer required because the AEAD.")]),e._v(" "),n("p",[e._v("Both peers need to track the message sequence number (uint32) of sent\nmessages to the remote peer for building a 64 bit symmetric cipher IV.\nSequence numbers are allowed to overflow to zero after 4294967295\n(2^32-1).")]),e._v(" "),n("p",[e._v("The encrypted payload will result decrypted in one or many unencrypted\nmessages:")]),e._v(" "),n("p",[e._v("Field Size   Description   Data type   Comments")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("?            command       varlen      ASCII string identifying the packet content, we are using varlen in the encrypted messages.\n4            length        uint32_t    Length of plaintext payload\n?            payload       ?           The actual data")]),e._v(" "),n("p",[e._v("If more data is present, another message must be deserialized. There is\nno explicit amount-of-messages integer.")]),e._v(" "),n("h3",{attrs:{id:"re-keying-re-keying"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#re-keying-re-keying"}},[e._v("#")]),e._v(" Re-Keying {#re_keying}")]),e._v(" "),n("p",[e._v("A responding peer can inform the requesting peer over a re-keying with\nan "),n("code",[e._v("encack")]),e._v(" message containing 33byte of zeros to indicate that all\nencrypted message following after this "),n("code",[e._v("encack")]),e._v(" message will be\nencrypted with "),n("em",[e._v("the next symmetric cipher key")]),e._v(".")]),e._v(" "),n("p",[e._v("The new symmetric cipher key will be calculated by\n"),n("code",[e._v("SHA256(SHA256(session_id || old_symmetric_cipher_key))")]),e._v(".")]),e._v(" "),n("p",[e._v("Re-Keying interval is a peer policy with a minimum timespan of 10\nseconds.")]),e._v(" "),n("p",[e._v("The Re-Keying must be done after every 1GB of data sent or received\n(recommended by RFC4253 SSH Transport).")]),e._v(" "),n("h3",{attrs:{id:"risks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#risks"}},[e._v("#")]),e._v(" Risks")]),e._v(" "),n("p",[e._v("The encryption does not include an identity authentication scheme. This\nBIP does not cover a proposal to avoid MITM attacks during the\nencryption initialization.")]),e._v(" "),n("p",[e._v("Identity authentication will be covered in another BIP and will presume\ncommunication encryption after this BIP.")]),e._v(" "),n("h2",{attrs:{id:"compatibility"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#compatibility"}},[e._v("#")]),e._v(" Compatibility")]),e._v(" "),n("p",[e._v("This proposal is backward compatible. Non-supporting peers will ignore\nthe "),n("code",[e._v("encinit")]),e._v(" messages.")]),e._v(" "),n("h2",{attrs:{id:"reference-implementation-reference-implementation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reference-implementation-reference-implementation"}},[e._v("#")]),e._v(" Reference implementation {#reference_implementation}")]),e._v(" "),n("h2",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),n("ul",[n("li",[e._v("[1]\n"),n("a",{attrs:{href:"https://e-collection.library.ethz.ch/eserv/eth:48205/eth-48205-01.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://e-collection.library.ethz.ch/eserv/eth:48205/eth-48205-01.pdf"),n("OutboundLink")],1)]),e._v(" "),n("li",[e._v("[2] HKDF (RFC 5869) "),n("a",{attrs:{href:"https://tools.ietf.org/html/rfc5869",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://tools.ietf.org/html/rfc5869"),n("OutboundLink")],1)]),e._v(" "),n("li",[e._v("[3] ChaCha20 "),n("a",{attrs:{href:"https://cr.yp.to/chacha/chacha-20080128.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://cr.yp.to/chacha/chacha-20080128.pdf"),n("OutboundLink")],1)]),e._v(" "),n("li",[e._v("[4] Poly1305 "),n("a",{attrs:{href:"https://cr.yp.to/mac/poly1305-20050329.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://cr.yp.to/mac/poly1305-20050329.pdf"),n("OutboundLink")],1)]),e._v(" "),n("li",[e._v("[5]\n"),n("a",{attrs:{href:"https://github.com/openssh/openssh-portable/blob/05855bf2ce7d5cd0a6db18bc0b4214ed5ef7516d/PROTOCOL.chacha20poly1305",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/openssh/openssh-portable/blob/05855bf2ce7d5cd0a6db18bc0b4214ed5ef7516d/PROTOCOL.chacha20poly1305"),n("OutboundLink")],1)]),e._v(" "),n("li",[e._v('[6] "ChaCha20 and Poly1305 based Cipher Suites for TLS", Adam\nLangley\n'),n("a",{attrs:{href:"https://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-03"),n("OutboundLink")],1)])]),e._v(" "),n("h2",{attrs:{id:"acknowledgements"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#acknowledgements"}},[e._v("#")]),e._v(" Acknowledgements")]),e._v(" "),n("ul",[n("li",[e._v("Pieter Wuille and Gregory Maxwell for most of the ideas in this BIP.")])]),e._v(" "),n("h2",{attrs:{id:"copyright"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),n("p",[e._v("This work is placed in the public domain.")])])}),[],!1,null,null,null);t.default=i.exports}}]);