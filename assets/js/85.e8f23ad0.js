(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{460:function(e,t,n){"use strict";n.r(t);var s=n(43),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_339"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_339"}},[e._v("#")]),e._v(" 339")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  BIP: 330\n  Layer: Peer Services\n  Title: Transaction announcements reconciliation\n  Author: Gleb Naumenko <naumenko.gs@gmail.com>\n          Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0330\n  Status: Draft\n  Type: Standards Track\n  Created: 2019-09-25\n  License: CC0-1.0\n  License-Code: MIT\n")])])]),n("h2",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("This document specifies a P2P protocol extension for reconciliation of\ntransaction announcements "),n("code",[e._v("<b>")]),e._v(" between 2 nodes"),n("code",[e._v("</b>")]),e._v(" ,\nwhich is a building block for efficient transaction relay protocols\n(e.g., "),n("a",{attrs:{href:"https://arxiv.org/pdf/1905.10518.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Erlay"),n("OutboundLink")],1),e._v("). This is a step\ntowards increasing the connectivity of the network for almost no\nbandwidth cost.")]),e._v(" "),n("h2",{attrs:{id:"motivation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),n("p",[e._v("Currently in the Bitcoin network, every 32-byte transaction ID is\nannounced in at least one direction between every pair of connected\npeers, via INV messages. This results in high cost of announcing\ntransactions: "),n("em",[e._v("O(nodes * connections_per_node)")]),e._v(".")]),e._v(" "),n("p",[e._v("A "),n("code",[e._v("<b>")]),e._v(" reconciliation-based protocol"),n("code",[e._v("</b>")]),e._v("  which uses the\ntechnique suggested in this document can have better scaling properties\nthan INV-based flooding.")]),e._v(" "),n("p",[e._v("Increasing the connectivity of the network makes the network more robust\nto partitioning attacks; thus, improving the bandwidth scaling of\ntransaction relay to "),n("em",[e._v("O(nodes)")]),e._v(" (and without a high constant overhead)\nwould allow us to improve the security of the network by increasing\nconnectivity. It would also reduce the bandwidth required to run a\nBitcoin node and potentially enable more users to run full nodes.")]),e._v(" "),n("h3",{attrs:{id:"erlay"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#erlay"}},[e._v("#")]),e._v(" Erlay")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://arxiv.org/pdf/1905.10518.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Erlay"),n("OutboundLink")],1),e._v(" is an example of a\nhigh-level transaction relay protocol which employs set reconciliation\nfor bandwidth efficiency.")]),e._v(" "),n("p",[e._v("Erlay uses both flooding (announcing using INV messages to all peers)\nand reconciliation to announce transactions. Flooding is expensive, so\nErlay seeks to use it sparingly and in strategic locations - only\nwell-connected publicly reachable nodes flood transactions to other\npublicly reachable nodes via outbound connections. Since every\nunreachable node is directly connected to several reachable nodes, this\npolicy ensures that a transaction is quickly propagated to be within one\nhop from most of the nodes in the network.")]),e._v(" "),n("p",[e._v("All transactions not propagated through flooding are propagated through\nefficient set reconciliation. To do this, every node keeps a\nreconciliation set for each peer, in which transactions are placed which\nwould have been announced using INV messages absent this protocol. Every\n2 seconds every node chooses a peer from its outbound connections in a\npredetermined order to reconcile with, resulting in both sides learning\nthe transactions known to the other side. After every reconciliation\nround, the corresponding reconciliation set is cleared. A more detailed\ndescription of a set reconciliation round and other implementation\ndetails can be found in the paper.")]),e._v(" "),n("p",[e._v("Erlay allows us to:")]),e._v(" "),n("ul",[n("li",[e._v("save 40% of the bandwidth consumed by a node, given typical network\nconnectivity as of July 2019.")]),e._v(" "),n("li",[e._v("achieve similar latency")]),e._v(" "),n("li",[e._v("increase network connectivity for almost no bandwidth or latency\ncost")]),e._v(" "),n("li",[e._v("improves privacy as a side-effect")])]),e._v(" "),n("p",[e._v("This document proposes a P2P-layer extension which is required to enable\nefficient reconciliation-based protocols (like Erlay) for transaction\nrelay.")]),e._v(" "),n("h2",{attrs:{id:"specification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),n("h3",{attrs:{id:"new-data-structures-new-data-structures"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-data-structures-new-data-structures"}},[e._v("#")]),e._v(" New data structures {#new_data_structures}")]),e._v(" "),n("p",[e._v("Several new data structures are introduced to the P2P protocol first, to\naid with efficient transaction relay.")]),e._v(" "),n("h4",{attrs:{id:"_32-bit-short-transaction-ids-bit-short-transaction-ids"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_32-bit-short-transaction-ids-bit-short-transaction-ids"}},[e._v("#")]),e._v(" 32-bit short transaction IDs {#bit_short_transaction_ids}")]),e._v(" "),n("p",[e._v("During reconciliation, significantly abbreviated transaction IDs are\nused of just 32 bits in size. To prevent attackers from constructing\nsets of transactions that cause network-wide collisions, the short ID\ncomputation is salted on a per-link basis using 64 bits of entropy\ncontributed by both communication partners.")]),e._v(" "),n("p",[e._v("Short IDs are computed as follows:")]),e._v(" "),n("ul",[n("li",[e._v("Let "),n("em",[e._v("salt~1~")]),e._v(" and "),n("em",[e._v("salt~2~")]),e._v(' be the entropy contributed by both\nsides; see the "sendrecon" message further for details how they\nare exchanged.')]),e._v(" "),n("li",[e._v("Sort the two salts such that "),n("em",[e._v("salt~1~ â‰¤ salt~2~")]),e._v(" (which side sent\nwhat doesn't matter).")]),e._v(" "),n("li",[e._v("Compute "),n("em",[e._v('h = SHA256("Tx Relay Salting" || salt~1~ ||\nsalt~2~)')]),e._v(", where the two salts are encoded in 64-bit little-endian\nbyte order.")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("k~0~")]),e._v(" be the 64-bit integer obtained by interpreting the first\n8 bytes of "),n("em",[e._v("h")]),e._v(" in little-endian byte order.")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("k~1~")]),e._v(" be the 64-bit integer obtained by interpreting the second\n8 bytes of "),n("em",[e._v("h")]),e._v(" in little-endian byte order.")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("s = SipHash-2-4((k~0~,k~1~),wtxid)")]),e._v(", where "),n("em",[e._v("wtxid")]),e._v(" is the\ntransaction hash including witness data as defined by BIP141.")]),e._v(" "),n("li",[e._v("The short ID is equal to "),n("em",[e._v("1 + (s mod 0xFFFFFFFF)")]),e._v(".")])]),e._v(" "),n("p",[e._v("This results in approximately uniformly distributed IDs in the range\n"),n("em",[e._v("[1..0xFFFFFFFF]")]),e._v(", which is a requirement for using them as elements\nin 32-bit sketches. See the next paragraph for details.")]),e._v(" "),n("h4",{attrs:{id:"short-transaction-id-sketches-short-transaction-id-sketches"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#short-transaction-id-sketches-short-transaction-id-sketches"}},[e._v("#")]),e._v(" Short transaction ID sketches {#short_transaction_id_sketches}")]),e._v(" "),n("p",[e._v("Reconciliation-based relay uses\n"),n("a",{attrs:{href:"https://www.cs.bu.edu/~reyzin/code/fuzzy.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("PinSketch"),n("OutboundLink")],1),e._v(" BCH-based\nsecure sketches as introduced by the "),n("a",{attrs:{href:"https://www.cs.bu.edu/~reyzin/fuzzy.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Fuzzy Extractors\npaper"),n("OutboundLink")],1),e._v(". They are a form of set\nchecksums with the following properties:")]),e._v(" "),n("ul",[n("li",[e._v("Sketches have a predetermined capacity, and when the number of\nelements in the set does not exceed the capacity, it is always\npossible to recover the entire set from the sketch by decoding the\nsketch. A sketch of nonzero b-bit elements with capacity c can be\nstored in bc bits.")]),e._v(" "),n("li",[e._v("A sketch of the "),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Symmetric_difference",target:"_blank",rel:"noopener noreferrer"}},[e._v("symmetric\ndifference"),n("OutboundLink")],1),e._v("\nbetween the two sets (i.e., all elements that occur in one but not\nboth input sets), can be obtained by combining the sketches of those\nsets.")])]),e._v(" "),n("p",[e._v("The sketches used here consists of elements of the "),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Finite_field",target:"_blank",rel:"noopener noreferrer"}},[e._v("finite\nfield"),n("OutboundLink")],1),e._v(" "),n("em",[e._v("GF(2^32^)")]),e._v(".\nSpecifically, we represent finite field elements as polynomials in "),n("em",[e._v("x")]),e._v("\nover "),n("em",[e._v("GF(2)")]),e._v(" modulo "),n("em",[e._v("x^32^7"),n("code",[e._v("</sup>")]),e._v("  + x^3^ + x^2^ + 1")]),e._v(". To map\nintegers to finite field elements, simply treat each bit "),n("em",[e._v("i")]),e._v(" (with value\n"),n("em",[e._v("2^i^")]),e._v(") in the integer as the coefficient of "),n("em",[e._v("x^i^")]),e._v(" in the polynomial\nrepresentation. For example the integer "),n("em",[e._v("101 = 2^6^ + 2^5^ + 2^2^ + 1")]),e._v("\nis mapped to field element "),n("em",[e._v("x^6^ + x^5^ + x^2^ + 1")]),e._v(". These field\nelements can be added and multiplied together, but the specifics of that\nare out of scope for this document.")]),e._v(" "),n("p",[e._v("A short ID sketch with capacity "),n("em",[e._v("c")]),e._v(" consists of a sequence of "),n("em",[e._v("c")]),e._v(" field\nelements. The first is the sum of all short IDs in the set, the second\nis the sum of the 3rd powers of all short IDs, the third is the sum of\nthe 5th powers etc., up to the last element with is the sum of the\n*(2c-1)*th powers. These elements are then encoded as 32-bit integers in\nlittle endian byte order, resulting in a "),n("em",[e._v("4c")]),e._v("-byte serialization.")]),e._v(" "),n("p",[e._v("The following Python 3.2+ code implements the creation of sketches:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('FIELD_BITS = 32\nFIELD_MODULUS = (1 << FIELD_BITS) + 0b10001101\n\ndef mul2(x):\n    """Compute 2*x in GF(2^FIELD_BITS)"""\n    return (x << 1) ^ (FIELD_MODULUS if x.bit_length() >= FIELD_BITS else 0)\n\ndef mul(x, y):\n    """Compute x*y in GF(2^FIELD_BITS)"""\n    ret = 0\n    for bit in [(x >> i) & 1 for i in range(x.bit_length())]:\n        ret, y = ret ^ bit * y, mul2(y)\n    return ret\n\ndef create_sketch(shortids, capacity):\n    """Compute the bytes of a sketch for given shortids and given capacity."""\n    odd_sums = [0 for _ in range(capacity)]\n    for shortid in shortids:\n        squared = mul(shortid, shortid)\n        for i in range(capacity):\n            odd_sums[i] ^= shortid\n            shortid = mul(shortid, squared)\n    return b\'\'.join(elem.to_bytes(4, \'little\') for elem in odd_sums)\n')])])]),n("p",[e._v("The "),n("a",{attrs:{href:"https://github.com/sipa/minisketch/",target:"_blank",rel:"noopener noreferrer"}},[e._v("minisketch"),n("OutboundLink")],1),e._v(" library implements\nthe construction, merging, and decoding of these sketches efficiently.")]),e._v(" "),n("h4",{attrs:{id:"truncated-transaction-ids-truncated-transaction-ids"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#truncated-transaction-ids-truncated-transaction-ids"}},[e._v("#")]),e._v(" Truncated transaction IDs {#truncated_transaction_ids}")]),e._v(" "),n("p",[e._v("For announcing and relaying transaction outside of reconciliation, we\nneed an unambiguous, unsalted way to refer to transactions to\ndeduplicate transaction requests. As we're introducing a new scheme\nanyway, this is a good opportunity to switch to wtxid-based requests\nrather than txid-based ones. While using full 256-bit wtxids is\npossible, this is overkill as they contribute significantly to the total\nbandwidth as well. Instead, we truncate the wtxid to just their first\n128 bits. These are referred to as truncated IDs.")]),e._v(" "),n("h3",{attrs:{id:"intended-protocol-flow-intended-protocol-flow"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#intended-protocol-flow-intended-protocol-flow"}},[e._v("#")]),e._v(" Intended Protocol Flow {#intended_protocol_flow}")]),e._v(" "),n("p",[e._v("Set reconciliation primarily consists of the transmission and decoding\nof a reconciliation set sketch upon request.")]),e._v(" "),n("p",[e._v('[framed|center|Set reconciliation protocol\nflow](File:bip-0330/recon_scheme_merged.png "wikilink")')]),e._v(" "),n("h4",{attrs:{id:"bisection"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bisection"}},[e._v("#")]),e._v(" Bisection")]),e._v(" "),n("p",[e._v("If a node is unable to reconstruct the set difference from the received\nsketch, the node then makes an additional reconciliation request,\nsimilar to the initial one, but this request is applied to only a\nfraction of possible transactions (e.g., in the range 0x0--0x8). Because\nof the linearity of sketches, a sketch of a subset of transactions would\nallow the node to compute a sketch for the remainder, which saves\nbandwidth.")]),e._v(" "),n("p",[e._v('[framed|300px|center|Bisection](File:bip-0330/bisection.png "wikilink")')]),e._v(" "),n("h3",{attrs:{id:"new-messages-new-messages"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-messages-new-messages"}},[e._v("#")]),e._v(" New messages {#new_messages}")]),e._v(" "),n("p",[e._v("Several new protocol messages are added: sendrecon, reqreconcil, sketch,\nreqbisec, reconcildiff, invtx, gettx. This section describes their\nserialization, contents, and semantics.")]),e._v(" "),n("p",[e._v("In what follows, all integers are serialized in little-endian byte\norder. Boolean values are encoded as a single byte that must be 0 or 1\nexactly. Arrays are serialized with the CompactSize prefix that encodes\ntheir length, as is common in other P2P messages.")]),e._v(" "),n("h4",{attrs:{id:"sendrecon"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sendrecon"}},[e._v("#")]),e._v(" sendrecon")]),e._v(" "),n("p",[e._v("The sendrecon message announces support for the reconciliation protocol.\nIt is expected to be only sent once, and ignored by nodes that don't\nsupport it.")]),e._v(" "),n("p",[e._v("Its payload consists of:")]),e._v(" "),n("p",[e._v("Data type   Name        Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v('bool        sender      Indicates whether the sender will send "reqreconcil" message\nbool        responder   Indicates whether the sender will respond to "reqreconcil" messages.\nuint32      version     Sender must set this to 1 currently, otherwise receiver should ignore the message.\nuint64      salt        The salt used in the short transaction ID computation.')]),e._v(" "),n("p",[e._v('"reqreconcil" messages can only be sent if the sender has sent a\n"sendrecon" message with sender=true, and the receiver has sent a\n"sendrecon" message with responder=true.')]),e._v(" "),n("h4",{attrs:{id:"reqreconcil"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reqreconcil"}},[e._v("#")]),e._v(" reqreconcil")]),e._v(" "),n("p",[e._v("The reqreconcil message initiates a reconciliation round.")]),e._v(" "),n("p",[e._v("Data type   Name       Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("uint16      set_size   Size of the sender's reconciliation set, used to estimate set difference.\nuint8       q          Coefficient used to estimate set difference. Multiplied by PRECISION=2^6 and rounded up by the sender and divided by PRECISION by the receiver.")]),e._v(" "),n("p",[e._v('Upon receipt of a "reqreconcil" message, the receiver:')]),e._v(" "),n("ul",[n("li",[e._v('Constructs and sends a "sketch" message (see below), with a sketch\nof capacity computed as '),n("em",[e._v("|set_size - local_set_size| + q *\n(set_size + local_set_size) + c")]),e._v(", where "),n("em",[e._v("local_set_size")]),e._v(" represents\nsize of the receiver's reconciliation set.")]),e._v(" "),n("li",[e._v('Makes a snapshot of their current reconciliation set, and clears the\nset itself. The snapshot is kept until a "reconcildiff" message is\nreceived by the node.')])]),e._v(" "),n("p",[e._v("It is suggested to use "),n("em",[e._v("c=1")]),e._v(" to avoid sending empty sketches and reduce\nthe overhead caused by under-estimations.")]),e._v(" "),n("p",[e._v("Intuitively, "),n("em",[e._v("q")]),e._v(" represents the discrepancy in sets: the closer the sets\nare, the lower optimal "),n("em",[e._v("q")]),e._v(" is. As suggested by Erlay, "),n("em",[e._v("q")]),e._v(" should be\nderived as an optimal "),n("em",[e._v("q")]),e._v(" value for the previous reconciliation with a\ngiven peer, once the actual set sizes and set difference are known.\nAlternatively, "),n("em",[e._v("q=0.1")]),e._v(" should be used as a default value. For example,\nif in previous round "),n("em",[e._v("set_size=30")]),e._v(" and "),n("em",[e._v("local_set_size=20")]),e._v(", and the\n*actual* difference was "),n("em",[e._v("4")]),e._v(", then a node should compute "),n("em",[e._v("q")]),e._v(" as\nfollowing: "),n("em",[e._v("q=(|30-20| - 1) / (30+20)=0.18")]),e._v(" The derivation of "),n("em",[e._v("q")]),e._v(" can\nbe changed according to the version of the protocol.")]),e._v(" "),n("p",[e._v('No new "reqreconcil" message can be sent until a "reconcildiff"\nmessage is sent.')]),e._v(" "),n("h4",{attrs:{id:"sketch"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#sketch"}},[e._v("#")]),e._v(" sketch")]),e._v(" "),n("p",[e._v("The sketch message is used to communicate a sketch required to perform\nset reconciliation.")]),e._v(" "),n("p",[e._v("Data type   Name     Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("byte[]    skdata   The sketch of the sender's reconciliation snapshot")]),e._v(" "),n("p",[e._v('Upon receipt of a "sketch" message, a node computes the set difference\nby combining the receiver sketch with a sketch computed locally for a\ncorresponding reconciliation set. If this is the 2nd time for this round\na "sketch" message was received, the bisection approach is used, and\nby combining the new sketch with the previous one, two difference\nsketches are obtained, one for the first half and one for the second\nhalf of the short id range. The receiving node then tries to decode this\nsketch (or sketches), and based on the result:')]),e._v(" "),n("ul",[n("li",[e._v('If decoding fails, a "reconcildiff" message is sent with the\nfailure flag set (success=false). If this was the first "sketch"\nin the round, a "reqbisec" message may be sent instead.')]),e._v(" "),n("li",[e._v('If decoding succeeds, a "reconcildiff" message is sent with the\ntruncated IDs of all locally known transactions that appear in the\ndecode result, and the short IDs of the unrecognized ones.')])]),e._v(" "),n("p",[e._v('The receiver also makes snapshot of their current reconciliation set,\nand clears the set itself. The snapshot is kept until a "reconcildiff"\nmessage is sent by the node.')]),e._v(" "),n("h4",{attrs:{id:"reqbisec"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reqbisec"}},[e._v("#")]),e._v(" reqbisec")]),e._v(" "),n("p",[e._v("The reqbisec message is used to signal that set reconciliation has\nfailed and an extra sketch is needed to find set difference.")]),e._v(" "),n("p",[e._v("It has an empty payload.")]),e._v(" "),n("p",[e._v('Upon receipt of a "reqbisec" message, a node responds to it with a\n"sketch" message, which contains a sketch of a subset of corresponding\nreconciliation set '),n("code",[e._v("<b>")]),e._v(" snapshot"),n("code",[e._v("</b>")]),e._v('  (stored when\n"reqreconcil" message for the current round was processed) (values in\nrange '),n("em",[e._v("[0..(2^31)]")]),e._v(").")]),e._v(" "),n("h4",{attrs:{id:"reconcildiff"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reconcildiff"}},[e._v("#")]),e._v(" reconcildiff")]),e._v(" "),n("p",[e._v("The reconcildiff message is used to announce transactions which are\nfound to be missing during set reconciliation on the sender's side.")]),e._v(" "),n("p",[e._v("Data type    Name           Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("uint8        success        Indicates whether sender of the message succeeded at set difference decoding.\nuint32[]   ask_shortids   The short IDs that the sender did not have.")]),e._v(" "),n("p",[e._v('Upon receipt a "reconcildiff" message with '),n("em",[e._v("success=1")]),e._v(', a node sends a\n"invtx" message for the transactions requested by 32-bit IDs (first\nvector) containing their 128-bit truncated IDs (with parent transactions\noccuring before their dependencies), and can request announced\ntransactions (second vector) it does not have via a "gettx" message.\nOtherwise if '),n("em",[e._v("success=0")]),e._v(", receiver should request bisection via\n"),n("em",[e._v("reqbisec")]),e._v(' (if failure happened for the first time). If failure happened\nfor the second time, receiver should announce the transactions from the\nreconciliation set via an "invtx" message, excluding the transactions\nannounced from the sender.')]),e._v(" "),n("p",[e._v("The "),n("code",[e._v("<b>")]),e._v(" snapshot"),n("code",[e._v("</b>")]),e._v("  of the corresponding\nreconciliation set is cleared by the sender and the receiver of the\nmessage.")]),e._v(" "),n("p",[e._v('The sender should also send their own "invtx" message along with the\nreconcildiff message to announce transactions which are missing on the\nreceiver\'s side.')]),e._v(" "),n("h4",{attrs:{id:"invtx"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#invtx"}},[e._v("#")]),e._v(" invtx")]),e._v(" "),n("p",[e._v('The invtx message is used to announce transactions (both along with\nreconcildiff message and as a response to the reconcildiff message). It\nis the truncated ID analogue of "inv" (which cannot be used because it\nhas 256-bit elements).')]),e._v(" "),n("p",[e._v("Data type     Name           Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("uint128[]   inv_truncids   The truncated IDs of transactions the sender believes the receiver does not have.")]),e._v(" "),n("p",[e._v('Upon receipt a "invtx" message, a node requests announced transactions\nit does not have. The '),n("code",[e._v("<b>")]),e._v(" snapshot"),n("code",[e._v("</b>")]),e._v("  of the\ncorresponding reconciliation set is cleared by the sender of the\nmessage.")]),e._v(" "),n("h4",{attrs:{id:"gettx"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#gettx"}},[e._v("#")]),e._v(" gettx")]),e._v(" "),n("p",[e._v('The gettx message is used to request transactions by 128-bit truncated\nIDs. It is the truncated ID analogue of "getdata".')]),e._v(" "),n("p",[e._v("Data type     Name           Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("uint128[]   ask_truncids   The truncated IDs of transactions the sender wants the full transaction data for.")]),e._v(" "),n("p",[e._v('Upon receipt a "gettx" message, a node sends "tx" messages for the\nrequested transactions.')]),e._v(" "),n("h2",{attrs:{id:"local-state-local-state"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#local-state-local-state"}},[e._v("#")]),e._v(" Local state {#local_state}")]),e._v(" "),n("p",[e._v("This BIP suggests a stateful protocol and it requires storing several\nvariables at every node to operate properly.")]),e._v(" "),n("h4",{attrs:{id:"reconciliation-sets-reconciliation-sets"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reconciliation-sets-reconciliation-sets"}},[e._v("#")]),e._v(" Reconciliation sets {#reconciliation_sets}")]),e._v(" "),n("p",[e._v("Every node stores a set of 128-bit truncated IDs for every peer which\nsupports transaction reconciliation, representing the transactions which\nwould have been sent according to the regular flooding protocol.\nIncoming transactions are added to sets when those transactions are\nreceived (if they satisfy the policies such as minimum fee set by a\npeer). A reconciliation set is moved to the corresponding set snapshot\nafter the transmission of the initial sketch.")]),e._v(" "),n("h4",{attrs:{id:"reconciliation-set-snapshot-reconciliation-set-snapshot"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reconciliation-set-snapshot-reconciliation-set-snapshot"}},[e._v("#")]),e._v(" Reconciliation set snapshot {#reconciliation_set_snapshot}")]),e._v(" "),n("p",[e._v("After the transmitting of the initial sketch (either sending or\nreceiving of reconcildiff message), every node should store the snapshot\nof the current reconciliation set, and clear the set. This is important\nto make bisection more stable during the reconciliation round (bisection\nshould be applied to the snapshot). The snapshot is also used to\nefficiently lookup the transactions requested by short ID. The snapshot\nis cleared after the end of the reconciliation round (sending or\nreceiving of the reconcildiff message).")]),e._v(" "),n("h4",{attrs:{id:"q-coefficient-q-coefficient"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q-coefficient-q-coefficient"}},[e._v("#")]),e._v(" q-coefficient {#q_coefficient}")]),e._v(" "),n("p",[e._v("The q value should be stored to make efficient difference estimation. It\nis shared across peers and changed after every reconciliation.\nq-coefficient represents the discrepancy in sets: the closer the sets\nare, the lower optimal "),n("em",[e._v("q")]),e._v(" is. In future implementations, q could vary\nacross different peers or become static.")]),e._v(" "),n("h2",{attrs:{id:"backward-compatibility-backward-compatibility"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#backward-compatibility-backward-compatibility"}},[e._v("#")]),e._v(" Backward compatibility {#backward_compatibility}")]),e._v(" "),n("p",[e._v("Older clients remain fully compatible and interoperable after this\nchange.")]),e._v(" "),n("p",[e._v("Clients which do not implement this protocol remain fully compatible\nafter this change using existing protocols, because transaction\nannouncement reconciliation is used only for peers that negotiate\nsupport for it.")]),e._v(" "),n("h2",{attrs:{id:"rationale"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),n("h4",{attrs:{id:"why-using-pinsketch-for-set-reconciliation-why-using-pinsketch-for-set-reconciliation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#why-using-pinsketch-for-set-reconciliation-why-using-pinsketch-for-set-reconciliation"}},[e._v("#")]),e._v(" Why using PinSketch for set reconciliation? {#why_using_pinsketch_for_set_reconciliation}")]),e._v(" "),n("p",[e._v("PinSketch is more bandwidth efficient than IBLT, especially for the\nsmall differences in sets we expect to operate over. PinSketch is as\nbandwidth efficient as CPISync, but PinSketch has quadratic decoding\ncomplexity, while CPISync have cubic decoding complexity. This makes\nPinSketch significantly faster.")]),e._v(" "),n("h4",{attrs:{id:"why-using-32-bit-short-transaction-ids-why-using-32-bit-short-transaction-ids"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#why-using-32-bit-short-transaction-ids-why-using-32-bit-short-transaction-ids"}},[e._v("#")]),e._v(" Why using 32-bit short transaction IDs? {#why_using_32_bit_short_transaction_ids}")]),e._v(" "),n("p",[e._v("To use Minisketch in practice, transaction IDs should be shortened\n(ideally, not more than 64 bits per element). Small number of bits per\ntransaction also allows to save extra bandwidth and make operations over\nsketches faster. According to our estimates, 32 bits provides low\ncollision rate in a non-adversarial model (which is enabled by using\nindependent salts per-link).")]),e._v(" "),n("h4",{attrs:{id:"why-using-128-bit-short-ids-why-using-128-bit-short-ids"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#why-using-128-bit-short-ids-why-using-128-bit-short-ids"}},[e._v("#")]),e._v(" Why using 128-bit short IDs? {#why_using_128_bit_short_ids}")]),e._v(" "),n("p",[e._v("To avoid problems caused by the delays in the network, our protocol\nrequires extra round of announcing unsalted transaction IDs.\n"),n("a",{attrs:{href:"https://arxiv.org/pdf/1905.10518.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Erlay"),n("OutboundLink")],1),e._v(" protocol on top of this\nwork also requires announcing unsalted transaction IDs for flooding.\nBoth of these measures allow to deduplicate transaction announcements\nacross the peers. However, using full 256-bit IDs to uniquely identify\ntransactions seems to be an overkill. 128 is the highest power of 2\nwhich provides good enough collision-resistance in an adversarial model,\nand trivially saves a significant portion of the bandwidth related to\nthese announcements.")]),e._v(" "),n("h4",{attrs:{id:"why-using-bisection-instead-of-extending-the-sketch-why-using-bisection-instead-of-extending-the-sketch"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#why-using-bisection-instead-of-extending-the-sketch-why-using-bisection-instead-of-extending-the-sketch"}},[e._v("#")]),e._v(" Why using bisection instead of extending the sketch? {#why_using_bisection_instead_of_extending_the_sketch}")]),e._v(" "),n("p",[e._v("Unlike extended sketches, bisection does not require operating over\nsketches of higher order. This allows to avoid the high computational\ncost caused by quadratic decoding complexity.")]),e._v(" "),n("h2",{attrs:{id:"implementation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),n("p",[e._v("TODO")]),e._v(" "),n("h2",{attrs:{id:"acknowledgments"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#acknowledgments"}},[e._v("#")]),e._v(" Acknowledgments")]),e._v(" "),n("p",[e._v("A large fraction of this proposal was done during designing Erlay with\nGregory Maxwell, Sasha Fedorova and Ivan Beschastnikh. We would like to\nthank Suhas Daftuar for contributions to the design and BIP structure.\nWe would like to thank Ben Woosley for contributions to the high-level\ndescription of the idea.")]),e._v(" "),n("h2",{attrs:{id:"copyright"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),n("p",[e._v("This document is licensed under the Creative Commons CC0 1.0 Universal\nlicense.")])])}),[],!1,null,null,null);t.default=i.exports}}]);