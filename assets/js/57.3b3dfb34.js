(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{469:function(e,t,n){"use strict";n.r(t);var a=n(43),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_150"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_150"}},[e._v("#")]),e._v(" 150")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  BIP: 150\n  Layer: Peer Services\n  Title: Peer Authentication\n  Author: Jonas Schnelli <dev@jonasschnelli.ch>\n  Comments-Summary: Discouraged for implementation (one person)\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0150\n  Status: Draft\n  Type: Standards Track\n  Created: 2016-03-23\n  License: PD\n")])])]),n("h2",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("This BIP describes a way for peers to authenticate to other peers to\nguarantee node ownership and/or allow peers to access additional or\nlimited node services, without the possibility of fingerprinting.")]),e._v(" "),n("h2",{attrs:{id:"motivation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),n("p",[e._v("We assume peer operators want to limit the access of different node\nservices or increase datastream priorities to a selective subset of\npeers. Also we assume that peers want to connect to specific peers to\nbroadcast or filter transactions (or similar actions that reveal\nsensitive information) and therefore operators want to authenticate the\nremote peer and ensure that they have not connected to a MITM\n(man-in-the-middle) attacker.")]),e._v(" "),n("p",[e._v("Benefits of peer authentication:")]),e._v(" "),n("ul",[n("li",[e._v("Peers can detect MITM attacks when connecting to known peers")]),e._v(" "),n("li",[e._v("Peers can allow resource hungry transaction filtering only to\nspecific peers")]),e._v(" "),n("li",[e._v("Peers can allow access to sensitive information that can lead to\nnode fingerprinting (fee estimation)")]),e._v(" "),n("li",[e._v("Peers can allow custom message types (private extensions) to\nauthenticated peers")])]),e._v(" "),n("p",[e._v("A simple authentication scheme based on elliptic cryptography will allow\npeers to identify each other and selectively allow access to restricted\nservices or reject the connection if the peer identity cannot be\nverified.")]),e._v(" "),n("h2",{attrs:{id:"specification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),n("p",[e._v("The authentication scheme proposed in this BIP uses ECDSA, "),n("strong",[e._v("secrets\nwill never be transmitted")]),e._v(".")]),e._v(" "),n("p",[n("strong",[e._v("Authentication initialization must only happen if encrypted channels\nhave been established (according to BIP-151 [1]).")])]),e._v(" "),n("p",[e._v("The "),n("strong",[e._v("encryption-session-ID")]),e._v(" is available once channels are encrypted\n(according to BIP-151 [1]).")]),e._v(" "),n("p",[e._v('The identity-public-keys used for the authentication must be pre-shared\nover a different channel (mail/PGP, physical paper exchange, etc.). This\nBIP does not cover a "trust on first use" (TOFU) concept.')]),e._v(" "),n("p",[e._v("The authentication state must be kept until the encryption/connection\nterminates.")]),e._v(" "),n("p",[e._v("Only one authentication process is allowed per connection.\nRe-authentication require re-establishing the connection.")]),e._v(" "),n("h3",{attrs:{id:"known-peers-and-authorized-peers-database-known-peers-and-authorized-peers-database"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#known-peers-and-authorized-peers-database-known-peers-and-authorized-peers-database"}},[e._v("#")]),e._v(" Known-peers and authorized-peers database {#known_peers_and_authorized_peers_database}")]),e._v(" "),n("p",[e._v('Each peer that supports p2p authentication must provide two\nuser-editable "databases".')]),e._v(" "),n("ol",[n("li",[n("strong",[e._v("known-peers")]),e._v(' contains known identity-public-keys together with a\nnetwork identifier (IP & port), similar to the "known-host" file\nsupported by openssh.')]),e._v(" "),n("li",[n("strong",[e._v("authorized-peers")]),e._v(" contains authorized identity-public-keys")])]),e._v(" "),n("h3",{attrs:{id:"local-identity-key-management-local-identity-key-management"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#local-identity-key-management-local-identity-key-management"}},[e._v("#")]),e._v(" Local identity key management {#local_identity_key_management}")]),e._v(" "),n("p",[e._v("Each peer can configure multiple identity-keys (ECC, 32 bytes). Peers\nshould make sure that each network interface (IPv4, IPv6, tor) has its\nown identity-key (otherwise it would be possible to link a tor address\nto a IPvX address). The identity-public-key(s) can be shared over a\ndifferent channel with other node-operators (or non-validating clients)\nto grant authorized access.")]),e._v(" "),n("h3",{attrs:{id:"authentication-procedure-authentication-procedure"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#authentication-procedure-authentication-procedure"}},[e._v("#")]),e._v(" Authentication procedure {#authentication_procedure}")]),e._v(" "),n("p",[e._v("Authentication based on this BIP will require both sides to\nauthenticate. Signatures/public-keys will only be revealed if the remote\npeer can prove that they already know the remote identity-public-key.")]),e._v(" "),n("ol",[n("li",[e._v("-> Requesting peer sends "),n("code",[e._v("AUTHCHALLENGE")]),e._v(" (hash)")]),e._v(" "),n("li",[e._v("<- Responding peer sends "),n("code",[e._v("AUTHREPLY")]),e._v(" (signature)")]),e._v(" "),n("li",[e._v("-> Requesting peer sends "),n("code",[e._v("AUTHPROPOSE")]),e._v(" (hash)")]),e._v(" "),n("li",[e._v("<- Responding peer sends "),n("code",[e._v("AUTHCHALLENGE")]),e._v(" (hash)")]),e._v(" "),n("li",[e._v("-> Requesting peer sends "),n("code",[e._v("AUTHREPLY")]),e._v(" (signature)")])]),e._v(" "),n("p",[e._v("For privacy reasons, dropping the connection or aborting during the\nauthentication process must not be allowed.")]),e._v(" "),n("h3",{attrs:{id:"authchallenge-message-authchallenge-message"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#authchallenge-message-authchallenge-message"}},[e._v("#")]),e._v(" "),n("code",[e._v("AUTHCHALLENGE")]),e._v(" message {#authchallenge_message}")]),e._v(" "),n("p",[e._v("A peer can send an authentication challenge to see if the responding\npeer can produce a valid signature with the expected responding peer's\nidentity-public-key by sending an "),n("code",[e._v("AUTHCHALLENGE")]),e._v("-message to the remote\npeer.")]),e._v(" "),n("p",[e._v("The responding peer needs to check if the hash matches the hash\ncalculated with his own local identity-public-key. Fingerprinting the\nrequesting peer is not possible.")]),e._v(" "),n("p",[e._v("Field Size   Description      Data type   Comments")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("32bytes      challenge-hash   hash        "),n("code",[e._v("<code>")]),e._v(" hash(encryption-session-ID")]),e._v(" "),n("p",[n("code",[e._v("challenge_type")]),e._v(" is a single character. "),n("code",[e._v("i")]),e._v(" if the\n"),n("code",[e._v("AUTHCHALLENGE")]),e._v("-message is the first, requesting challenge or "),n("code",[e._v("r")]),e._v(" if\nit's the second, remote peers challenge message.")]),e._v(" "),n("h3",{attrs:{id:"authreply-message-authreply-message"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#authreply-message-authreply-message"}},[e._v("#")]),e._v(" "),n("code",[e._v("AUTHREPLY")]),e._v(" message {#authreply_message}")]),e._v(" "),n("p",[e._v("A peer must reply an "),n("code",[e._v("AUTHCHALLENGE")]),e._v("-message with an\n"),n("code",[e._v("AUTHREPLY")]),e._v("-message.")]),e._v(" "),n("p",[e._v("Field Size   Description   Data type                    Comments")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("64bytes      signature     normalized comp.-signature   A signature of the encryption-session-ID done with the identity-key")]),e._v(" "),n("p",[e._v("If the challenge-hash from the "),n("code",[e._v("AUTHCHALLENGE")]),e._v("-message did not match the\nlocal authentication public-key, the signature must contain 64 bytes of\nzeros.")]),e._v(" "),n("p",[e._v("The requesting peer can check the responding peer's identity by\nchecking the validity of the sent signature against with the pre-shared\nremote peers identity-public-key.")]),e._v(" "),n("p",[e._v("If the signature was invalid, the requesting peer must still proceed\nwith the authentication by sending an "),n("code",[e._v("AUTHPROPOSE")]),e._v("-message with 32\nrandom bytes.")]),e._v(" "),n("h3",{attrs:{id:"authpropose-message-authpropose-message"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#authpropose-message-authpropose-message"}},[e._v("#")]),e._v(" "),n("code",[e._v("AUTHPROPOSE")]),e._v(" message {#authpropose_message}")]),e._v(" "),n("p",[e._v("A peer can propose authentication of the channel by sending an\n"),n("code",[e._v("AUTHPROPOSE")]),e._v("-message to the remote peer.")]),e._v(" "),n("p",[e._v("If the signature sent in "),n("code",[e._v("AUTHREPLY")]),e._v(" was invalid, the peer must still\nsend an "),n("code",[e._v("AUTHPROPOSE")]),e._v("-message containing 32 random bytes.")]),e._v(" "),n("p",[e._v("The "),n("code",[e._v("AUTHPROPOSE")]),e._v(" message must be answered with an\n"),n("code",[e._v("AUTHCHALLENGE")]),e._v("-message - even if the proposed requesting-peers\nidentity-public-key has not been found in the authorized-peers database.\nIn case of no match, the responding "),n("code",[e._v("AUTHCHALLENGE")]),e._v("-message must\ncontains 32 bytes of zeros.")]),e._v(" "),n("p",[e._v("Field Size   Description         Data type   Comments")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("32bytes      auth-propose-hash   hash        "),n("code",[e._v("<code>")]),e._v(" hash(encryption-session-ID")]),e._v(" "),n("h2",{attrs:{id:"post-authentication-re-keying-post-authentication-re-keying"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#post-authentication-re-keying-post-authentication-re-keying"}},[e._v("#")]),e._v(" Post-Authentication Re-Keying {#post_authentication_re_keying}")]),e._v(" "),n("p",[e._v("After the second "),n("code",[e._v("AUTHREPLY")]),e._v(" message (requesting peer's signature ->\nresponding peer), both clients must re-key the symmetric encryption\naccording to BIP151 while using "),n("strong",[e._v("a slightly different re-key key\nderivation hash")]),e._v(".")]),e._v(" "),n("p",[e._v("Both peers re-key with\n"),n("code",[e._v("hash(encryption-session-ID || old_symmetric_cipher_key || requesting-peer-identity-public-key || responding-peer-identity-public-key)")])]),e._v(" "),n("h2",{attrs:{id:"identity-addresses-identity-addresses"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#identity-addresses-identity-addresses"}},[e._v("#")]),e._v(" Identity-Addresses {#identity_addresses}")]),e._v(" "),n("p",[e._v("The peers should display/log the identity-public-key as an\nidentity-address to the users, which is a base58-check encoded\nripemd160(sha256) hash. The purpose of this is for better visual\ncomparison (logs, accept-dialogs). The base58check identity byte is\n"),n("code",[e._v("0x0F")]),e._v(" followed by an identity-address version number (="),n("code",[e._v("0xFF01")]),e._v(").")]),e._v(" "),n("p",[e._v("An identity address would look like\n"),n("code",[e._v("TfG4ScDgysrSpodWD4Re5UtXmcLbY5CiUHA")]),e._v(" and can be interpreted as a remote\npeer's fingerprint.")]),e._v(" "),n("h2",{attrs:{id:"compatibility"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#compatibility"}},[e._v("#")]),e._v(" Compatibility")]),e._v(" "),n("p",[e._v("This proposal is backward compatible. Non-supporting peers will ignore\nthe new "),n("code",[e._v("AUTH*")]),e._v(" messages.")]),e._v(" "),n("h2",{attrs:{id:"example-of-an-auth-interaction-example-of-an-auth-interaction"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example-of-an-auth-interaction-example-of-an-auth-interaction"}},[e._v("#")]),e._v(" Example of an auth interaction {#example_of_an_auth_interaction}")]),e._v(" "),n("p",[e._v("Before authentication (once during peer setup or upgrade)")]),e._v(" "),n("ol",[n("li",[e._v("Requesting peer and responding peer create each an identity-keypair\n(standard ECC priv/pubkey)")]),e._v(" "),n("li",[e._v("Requesting and responding peer share the identity-public-key over a\ndifferent channel (mail/PGP, physical paper exchange, etc.)")]),e._v(" "),n("li",[e._v("Responding peer stores requesting peers identity-public-key in its\nauthorized-peers database (A)")]),e._v(" "),n("li",[e._v("Requesting peer stores responding peers identity-public-key in its\nknown-peers database together with its IP and port (B)")])]),e._v(" "),n("p",[e._v("Encryption")]),e._v(" "),n("ol",[n("li",[e._v("Encrypted channels must be established (according to BIP-151 [1])")])]),e._v(" "),n("p",[e._v("Authentication")]),e._v(" "),n("ol",[n("li",[e._v("Requesting peer sends an "),n("code",[e._v("AUTHCHALLENGE")]),e._v(" message")])]),e._v(" "),n("p",[n("code",[e._v("AUTHCHALLENGE:")]),n("br"),e._v(" "),n("code",[e._v('[32 bytes, hash(encryption-session-ID || "i" ||  <remote-peers-expected-identity-public-key>')]),e._v(" "),n("code",[e._v(")]")])]),e._v(" "),n("ol",[n("li",[e._v("Responding peer does create the same hash\n"),n("code",[e._v('(encryption-session-ID || "i" || <remote-peers-expected-identity-public-key>')]),e._v(" "),n("code",[e._v(")")]),e._v("\nwith its local identity-public-key")]),e._v(" "),n("li",[e._v("If the hash does not match, response with an "),n("code",[e._v("AUTHREPLY")]),e._v(" message\ncontaining 64bytes of zeros.")]),e._v(" "),n("li",[e._v("In case of a match, response with an "),n("code",[e._v("AUTHREPLY")]),e._v(" message")])]),e._v(" "),n("p",[n("code",[e._v("AUTHREPLY:")]),n("br"),e._v(" "),n("code",[e._v("[64 bytes normalized compact ECDSA signature (H)] (sig of the encryption-session-ID done with the identity-key)")])]),e._v(" "),n("ol",[n("li",[e._v("Requesting peer does verify the signature with the\n"),n("code",[e._v("remote-peers-identity-public-key")])]),e._v(" "),n("li",[e._v("If the signature is invalid, requesting peer answers with an\n"),n("code",[e._v("AUTHREPLY")]),e._v(" message containing 32 random bytes")]),e._v(" "),n("li",[e._v("In case of a valid signature, requesting peer sends an "),n("code",[e._v("AUTHPROPOSE")]),e._v("\nmessage")])]),e._v(" "),n("p",[n("code",[e._v("AUTHPROPOSE:")]),n("br"),e._v(" "),n("code",[e._v('[32 bytes, hash(encryption-session-ID || "p" ||  <client-identity-public-key>')]),e._v(" "),n("code",[e._v(")]")])]),e._v(" "),n("ol",[n("li",[e._v("Responding peer iterates over authorized-peers database (A), hashes\nthe identical data and looks for a match.")]),e._v(" "),n("li",[e._v("If the hash does not match, responding peer answer with an\n"),n("code",[e._v("AUTHCHALLENGE")]),e._v(" message containing 32 bytes of zeros.")]),e._v(" "),n("li",[e._v("In case of a match, responding peer sends an "),n("code",[e._v("AUTHCHALLENGE")]),e._v(" message\nwith the hashed client public-key")])]),e._v(" "),n("p",[n("code",[e._v("AUTHCHALLENGE:")]),n("br"),e._v(" "),n("code",[e._v('[32 bytes, hash(encryption-session-ID || "r" ||  <client-identity-public-key>')]),e._v(" "),n("code",[e._v(")]")])]),e._v(" "),n("ol",[n("li",[e._v("Requesting peer sends an "),n("code",[e._v("AUTHREPLY")]),e._v(" message containing 64 bytes of\nzeros if server failed to authenticate")]),e._v(" "),n("li",[e._v("Otherwise, response with signature in the "),n("code",[e._v("AUTHREPLY")]),e._v(" message")])]),e._v(" "),n("p",[n("code",[e._v("AUTHREPLY:")]),n("br"),e._v(" "),n("code",[e._v("[64 bytes normalized compact ECDSA signature (H)] (sig of the encryption-session-ID done with the identity-key)")])]),e._v(" "),n("ol",[n("li",[e._v("Responding peer must verify the signature and can grant access to\nrestricted services.")]),e._v(" "),n("li",[e._v("Both peers re-key the encryption after BIP151 including the\nrequesting-peer-identity-public-key and\nresponding-peer-identity-public-key")])]),e._v(" "),n("h2",{attrs:{id:"disadvantages"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#disadvantages"}},[e._v("#")]),e._v(" Disadvantages")]),e._v(" "),n("p",[e._v("The protocol may be slow if a peer has a large authorized-peers database\ndue to the requirement of iterating and hashing over all available\nauthorized peer identity-public-keys.")]),e._v(" "),n("h2",{attrs:{id:"reference-implementation-reference-implementation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reference-implementation-reference-implementation"}},[e._v("#")]),e._v(" Reference implementation {#reference_implementation}")]),e._v(" "),n("h2",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),n("ul",[n("li",[e._v("[1] "),n("a",{attrs:{href:"bip-0151.mediawiki",title:"wikilink"}},[e._v("BIP 151: Peer-to-Peer Communication\nEncryption")])])]),e._v(" "),n("h2",{attrs:{id:"acknowledgements"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#acknowledgements"}},[e._v("#")]),e._v(" Acknowledgements")]),e._v(" "),n("ul",[n("li",[e._v("Gregory Maxwell and Pieter Wuille for most of the ideas in this BIP.")]),e._v(" "),n("li",[e._v("Bryan Bishop for editing.")])]),e._v(" "),n("h2",{attrs:{id:"copyright"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),n("p",[e._v("This work is placed in the public domain.")])])}),[],!1,null,null,null);t.default=i.exports}}]);