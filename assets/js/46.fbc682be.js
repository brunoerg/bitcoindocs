(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{420:function(e,t,i){"use strict";i.r(t);var s=i(43),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"_137"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_137"}},[e._v("#")]),e._v(" 137")]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[e._v("  BIP: 137\n  Layer: Applications\n  Title: Signatures of Messages using Private Keys\n  Author: Christopher Gilliard <christopher.gilliard@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0137\n  Status: Final\n  Type: Standards Track\n  Created: 2019-02-16\n  License: BSD-2-Clause\n")])])]),i("h2",{attrs:{id:"abstract"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),i("p",[e._v("This document describes a signature format for signing messages with\nBitcoin private keys.")]),e._v(" "),i("p",[e._v("The specification is intended to describe the standard for signatures of\nmessages that can be signed and verfied between different clients that\nexist in the field today. Note: that a new signature format has been\ndefined which has a number of advantages over this BIP, but to be\nbackwards compatible with existing implementations this BIP will be\nuseful. See BIP 322 [1] for full details on the new signature scheme.")]),e._v(" "),i("p",[e._v("One of the key problems in this area is that there are several different\ntypes of Bitcoin addresses and without introducing specific standards it\nis unclear which type of address format is being used. See [2]. This\nBIP will attempt to address these issues and define a clear and concise\nformat for Bitcoin signatures.")]),e._v(" "),i("h2",{attrs:{id:"copyright"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),i("p",[e._v("This BIP is licensed under the 2-clause BSD license.")]),e._v(" "),i("h2",{attrs:{id:"motivation"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),i("p",[e._v("Since Bitcoin private keys can not only be used to sign Bitcoin\ntransactions, but also any other message, it has become customary to use\nthem to sign various messages for differing purposes. Some applications\nof signing messages with a Bitcoin private key are as follows: proof of\nfunds for collateral, credit worthiness, enterence to events, airdrops,\naudits as well as other applications. While there was no BIP written for\nhow to digitally sign messages with Bitcoin private keys with P2PKH\naddresses it is a fairly well understood process, however with the\nintroduction of Segwit (both in the form of P2SH and bech32) addresses,\nit is unclear how to distinguish a P2PKH, P2SH, or bech32 address from\none another. This BIP proposes a standard signature format that will\nallow clients to distinguish between the different address formats.")]),e._v(" "),i("h2",{attrs:{id:"specification"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),i("h3",{attrs:{id:"background-on-ecdsa-signatures-background-on-ecdsa-signatures"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#background-on-ecdsa-signatures-background-on-ecdsa-signatures"}},[e._v("#")]),e._v(" Background on ECDSA Signatures {#background_on_ecdsa_signatures}")]),e._v(" "),i("p",[e._v("(For readers who already understand how ECDSA signatures work, you can\nskip this section as this is only intended as background information.)\nElliptic Curve Digital Signature Algorithm or ECDSA is a cryptographic\nalgorithm used by Bitcoin to ensure that funds can only be spent by\ntheir rightful owners.")]),e._v(" "),i("p",[e._v("A few concepts related to ECDSA:")]),e._v(" "),i("p",[i("code",[e._v("<b>")]),e._v(" private key"),i("code",[e._v("</b>")]),e._v(" : A secret number, known only to the\nperson that generated it. A private key is essentially a randomly\ngenerated number. In Bitcoin, someone with the private key that\ncorresponds to funds on the block chain can spend the funds. In Bitcoin,\na private key is a single unsigned 256 bit integer (32 bytes).")]),e._v(" "),i("p",[i("code",[e._v("<b>")]),e._v(" public key"),i("code",[e._v("</b>")]),e._v(" : A number that corresponds to a\nprivate key, but does not need to be kept secret. A public key can be\ncalculated from a private key, but not vice versa. A public key can be\nused to determine if a signature is genuine (in other words, produced\nwith the proper key) without requiring the private key to be divulged.\nIn Bitcoin, public keys are either compressed or uncompressed.\nCompressed public keys are 33 bytes, consisting of a prefix either 0x02\nor 0x03, and a 256-bit integer called x. The older uncompressed keys are\n65 bytes, consisting of constant prefix (0x04), followed by two 256-bit\nintegers called x and y (2 * 32 bytes). The prefix of a compressed key\nallows for the y value to be derived from the x value.")]),e._v(" "),i("p",[i("code",[e._v("<b>")]),e._v(" signature"),i("code",[e._v("</b>")]),e._v(" : A number that proves that a signing\noperation took place. A signature is mathematically generated from a\nhash of something to be signed, plus a private key. The signature itself\nis two numbers known as r and s. With the public key, a mathematical\nalgorithm can be used on the signature to determine that it was\noriginally produced from the hash and the private key, without needing\nto know the private key. Signatures are either 73, 72, or 71 bytes long,\nwith probabilities approximately 25%, 50% and 25% respectively, although\nsizes even smaller than that are possible with exponentially decreasing\nprobability. Source [3].")]),e._v(" "),i("h3",{attrs:{id:"conventions-with-signatures-used-in-bitcoin-conventions-with-signatures-used-in-bitcoin"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#conventions-with-signatures-used-in-bitcoin-conventions-with-signatures-used-in-bitcoin"}},[e._v("#")]),e._v(" Conventions with signatures used in Bitcoin {#conventions_with_signatures_used_in_bitcoin}")]),e._v(" "),i("p",[e._v("Bitcoin signatures have the r and s values mentioned above, and a\nheader. The header is a single byte and the r and s are each 32 bytes so\na signature's size is 65 bytes. The header is used to specify\ninformation about the signature. It can be thought of as a bitmask with\neach bit in this byte having a meaning. The serialization format of a\nBitcoin signature is as follows:")]),e._v(" "),i("p",[e._v("[1 byte of header data][32 bytes for r value][32 bytes for s\nvalue]")]),e._v(" "),i("p",[e._v("The header byte has a few components to it. First, it stores something\nknown as the recId. This value is stored in the least significant 2 bits\nof the header. If the header is between a value of 31 and 34, this\nindicates that it is a compressed address. If the header value is\nbetween 35 and 38 inclusive, it is a p2sh segwit address. If the header\nvalue is between 39 and 42, it is a bech32 address.")]),e._v(" "),i("h3",{attrs:{id:"procedure-for-signing-verifying-a-signature-procedure-for-signingverifying-a-signature"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#procedure-for-signing-verifying-a-signature-procedure-for-signingverifying-a-signature"}},[e._v("#")]),e._v(" Procedure for signing/verifying a signature {#procedure_for_signingverifying_a_signature}")]),e._v(" "),i("p",[e._v("As noted above the signature is composed of three components, the\nheader, r and s values. r/s can be computed with standard ECDSA library\nfunctions. Part of the header includes something called a recId. This is\npart of every ECDSA signature and should be generated by the ECDSA\nlibrary. The recId is a number between 0 and 3 inclusive. The header is\nthe recId plus a constant which indicates what type of Bitcoin address\nthis is. For P2PKH address using an uncompressed public key this value\nis 27. For P2PKH address using compressed public key this value is 31.\nFor P2SH-P2WPKH this value is 35 and for P2WPKH (version 0 witness)\naddress this value is 39. So, you have the following ranges:")]),e._v(" "),i("ul",[i("li",[e._v("27-30: P2PKH uncompressed")]),e._v(" "),i("li",[e._v("31-34: P2PKH compressed")]),e._v(" "),i("li",[e._v("35-38: Segwit P2SH")]),e._v(" "),i("li",[e._v("39-42: Segwit Bech32")])]),e._v(" "),i("p",[e._v("To verify a signature, the recId is obtained by subtracting this\nconstant from the header value.")]),e._v(" "),i("h3",{attrs:{id:"sample-code-for-processing-a-signature-sample-code-for-processing-a-signature"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#sample-code-for-processing-a-signature-sample-code-for-processing-a-signature"}},[e._v("#")]),e._v(" Sample Code for processing a signature {#sample_code_for_processing_a_signature}")]),e._v(" "),i("p",[e._v("Note: this code is a modification of the BitcoinJ code which is written\nin java.")]),e._v(" "),i("p",[i("code",[e._v("public static ECKey signedMessageToKey(String message, String signatureBase64) throws SignatureException {")]),i("br"),e._v(" "),i("code",[e._v("byte[] signatureEncoded;")]),i("br"),e._v(" "),i("code",[e._v("try {")]),i("br"),e._v(" "),i("code",[e._v("signatureEncoded = Base64.decode(signatureBase64);")]),i("br"),e._v(" "),i("code",[e._v("} catch (RuntimeException e) {")]),i("br"),e._v(" "),i("code",[e._v("// This is what you get back from Bouncy Castle if base64 doesn't decode :(")]),i("br"),e._v(" "),i("code",[e._v('throw new SignatureException("Could not decode base64", e);')]),i("br"),e._v(" "),i("code",[e._v("}")]),i("br"),e._v(" "),i("code",[e._v("// Parse the signature bytes into r/s and the selector value.")]),i("br"),e._v(" "),i("code",[e._v("if (signatureEncoded.length < 65)")]),i("br"),e._v(" "),i("code",[e._v('throw new SignatureException("Signature truncated, expected 65 bytes and got " + signatureEncoded.length);')]),i("br"),e._v(" "),i("code",[e._v("int header = signatureEncoded[0] & 0xFF;")]),i("br"),e._v(" "),i("code",[e._v("// The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,")]),i("br"),e._v(" "),i("code",[e._v("//                  0x1D = second key with even y, 0x1E = second key with odd y")]),i("br"),e._v(" "),i("code",[e._v("if (header < 27 || header > 42)")]),i("br"),e._v(" "),i("code",[e._v('throw new SignatureException("Header byte out of range: " + header);')]),i("br"),e._v(" "),i("code",[e._v("BigInteger r = new BigInteger(1, Arrays.copyOfRange(signatureEncoded, 1, 33));")]),i("br"),e._v(" "),i("code",[e._v("BigInteger s = new BigInteger(1, Arrays.copyOfRange(signatureEncoded, 33, 65));")]),i("br"),e._v(" "),i("code",[e._v("ECDSASignature sig = new ECDSASignature(r, s);")]),i("br"),e._v(" "),i("code",[e._v("byte[] messageBytes = formatMessageForSigning(message);")]),i("br"),e._v(" "),i("code",[e._v("// Note that the C++ code doesn't actually seem to specify any character encoding. Presumably it's whatever")]),i("br"),e._v(" "),i("code",[e._v("// JSON-SPIRIT hands back. Assume UTF-8 for now.")]),i("br"),e._v(" "),i("code",[e._v("Sha256Hash messageHash = Sha256Hash.twiceOf(messageBytes);")]),i("br"),e._v(" "),i("code",[e._v("boolean compressed = false;")]),i("br"),e._v(" "),i("code",[e._v("// this section is added to support new signature types")]),i("br"),e._v(" "),i("code",[e._v("if(header>= 39) // this is a bech32 signature")]),i("br"),e._v(" "),i("code",[e._v("{")]),i("br"),e._v(" "),i("code",[e._v("header -= 12;")]),i("br"),e._v(" "),i("code",[e._v("compressed = true;")]),i("br"),e._v(" "),i("code",[e._v("} // this is a segwit p2sh signature")]),i("br"),e._v(" "),i("code",[e._v("else if(header >= 35)")]),i("br"),e._v(" "),i("code",[e._v("{")]),i("br"),e._v(" "),i("code",[e._v("header -= 8;")]),i("br"),e._v(" "),i("code",[e._v("compressed = true;")]),i("br"),e._v(" "),i("code",[e._v("} // this is a compressed key signature")]),i("br"),e._v(" "),i("code",[e._v("else if (header >= 31) {")]),i("br"),e._v(" "),i("code",[e._v("compressed = true;")]),i("br"),e._v(" "),i("code",[e._v("header -= 4;")]),i("br"),e._v(" "),i("code",[e._v("}")]),i("br"),e._v(" "),i("code",[e._v("int recId = header - 27;")]),i("br"),e._v(" "),i("code",[e._v("ECKey key = ECKey.recoverFromSignature(recId, sig, messageHash, compressed);")]),i("br"),e._v(" "),i("code",[e._v("if (key == null)")]),i("br"),e._v(" "),i("code",[e._v('throw new SignatureException("Could not recover public key from signature");')]),i("br"),e._v(" "),i("code",[e._v("return key;")]),i("br"),e._v(" "),i("code",[e._v("}")])]),e._v(" "),i("h2",{attrs:{id:"backwards-compatibility-backwards-compatibility"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility-backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility {#backwards_compatibility}")]),e._v(" "),i("p",[e._v("Since this format includes P2PKH keys, it is backwards compatible, but\nkeep in mind some software has checks for ranges of headers and will\nreport the newer segwit header types as errors.")]),e._v(" "),i("h2",{attrs:{id:"implications"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#implications"}},[e._v("#")]),e._v(" Implications")]),e._v(" "),i("p",[e._v("Message signing is an important use case and potentially underused due\nto the fact that, up until now, there has not been a formal\nspecification for how wallets can sign messages using Bitcoin private\nkeys. Bitcoin wallets should be interoperable and use the same\nconventions for determing a signature's validity. This BIP can also be\nupdated as new signature formats emerge.")]),e._v(" "),i("h2",{attrs:{id:"acknowledgements"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#acknowledgements"}},[e._v("#")]),e._v(" Acknowledgements")]),e._v(" "),i("ul",[i("li",[e._v("Konstantin Bay - review")]),e._v(" "),i("li",[e._v("Holly Casaletto - review")]),e._v(" "),i("li",[e._v("James Bryrer - review")])]),e._v(" "),i("p",[e._v("Note that the background on ECDSA signatures was taken from\nen.bitcoin.it and code sample modified from BitcoinJ.")]),e._v(" "),i("h2",{attrs:{id:"references"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),i("p",[e._v("[1] - "),i("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0322.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/bitcoin/bips/blob/master/bip-0322.mediawiki"),i("OutboundLink")],1)]),e._v(" "),i("p",[e._v("[2] - "),i("a",{attrs:{href:"https://github.com/bitcoin/bitcoin/issues/10542",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/bitcoin/bitcoin/issues/10542"),i("OutboundLink")],1)]),e._v(" "),i("p",[e._v("[3] -\n"),i("a",{attrs:{href:"https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://en.bitcoin.it/wiki/Elliptic_Curve_Digital_Signature_Algorithm"),i("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);