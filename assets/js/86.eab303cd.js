(window.webpackJsonp=window.webpackJsonp||[]).push([[86],{461:function(e,t,n){"use strict";n.r(t);var i=n(43),a=Object(i.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_340"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_340"}},[e._v("#")]),e._v(" 340")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  BIP: 340\n  Title: Schnorr Signatures for secp256k1\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n          Jonas Nick <jonasd.nick@gmail.com>\n          Tim Ruffing <crypto@timruffing.de>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0340\n  Status: Draft\n  Type: Standards Track\n  License: BSD-2-Clause\n  Created: 2020-01-19\n  Post-History: 2018-07-06: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016203.html [bitcoin-dev] Schnorr signatures BIP\n")])])]),n("h2",{attrs:{id:"introduction"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),n("h3",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("This document proposes a standard for 64-byte Schnorr signatures over\nthe elliptic curve "),n("em",[e._v("secp256k1")]),e._v(".")]),e._v(" "),n("h3",{attrs:{id:"copyright"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),n("p",[e._v("This document is licensed under the 2-clause BSD license.")]),e._v(" "),n("h3",{attrs:{id:"motivation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),n("p",[e._v("Bitcoin has traditionally used\n"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm",target:"_blank",rel:"noopener noreferrer"}},[e._v("ECDSA"),n("OutboundLink")],1),e._v("\nsignatures over the "),n("a",{attrs:{href:"https://www.secg.org/sec2-v2.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("secp256k1 curve"),n("OutboundLink")],1),e._v("\nwith "),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/SHA-2",target:"_blank",rel:"noopener noreferrer"}},[e._v("SHA256"),n("OutboundLink")],1),e._v(" hashes for\nauthenticating transactions. These are\n"),n("a",{attrs:{href:"https://www.secg.org/sec1-v2.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("standardized"),n("OutboundLink")],1),e._v(", but have a number of\ndownsides compared to "),n("a",{attrs:{href:"http://publikationen.ub.uni-frankfurt.de/opus4/files/4280/schnorr.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Schnorr\nsignatures"),n("OutboundLink")],1),e._v("\nover the same curve:")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("Provable security")]),e._v(": Schnorr signatures are provably secure. In\nmore detail, they are "),n("em",[e._v("strongly unforgeable under chosen message\nattack (SUF-CMA)")]),e._v("[^1] "),n("a",{attrs:{href:"https://www.di.ens.fr/~pointche/Documents/Papers/2000_joc.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("in the random oracle model assuming the\nhardness of the elliptic curve discrete logarithm problem\n(ECDLP)"),n("OutboundLink")],1),e._v("\nand "),n("a",{attrs:{href:"http://www.neven.org/papers/schnorr.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("in the generic group model assuming variants of preimage and\nsecond preimage resistance of the used hash\nfunction"),n("OutboundLink")],1),e._v("[^2]. In contrast,\nthe "),n("a",{attrs:{href:"https://nbn-resolving.de/urn:nbn:de:hbz:294-60803",target:"_blank",rel:"noopener noreferrer"}},[e._v("best known results for the provable security of\nECDSA"),n("OutboundLink")],1),e._v(" rely on\nstronger assumptions.")]),e._v(" "),n("li",[n("strong",[e._v("Non-malleability")]),e._v(": The SUF-CMA security of Schnorr signatures\nimplies that they are non-malleable. On the other hand, ECDSA\nsignatures are inherently malleable[^3]; a third party without\naccess to the secret key can alter an existing valid signature for a\ngiven public key and message into another signature that is valid\nfor the same key and message. This issue is discussed in\n"),n("a",{attrs:{href:"bip-0062.mediawiki",title:"wikilink"}},[e._v("BIP62")]),e._v(" and\n"),n("a",{attrs:{href:"bip-0146.mediawiki",title:"wikilink"}},[e._v("BIP146")]),e._v(".")]),e._v(" "),n("li",[n("strong",[e._v("Linearity")]),e._v(": Schnorr signatures provide a simple and efficient\nmethod that enables multiple collaborating parties to produce a\nsignature that is valid for the sum of their public keys. This is\nthe building block for various higher-level constructions that\nimprove efficiency and privacy, such as multisignatures and others\n(see Applications below).")])]),e._v(" "),n("p",[e._v("For all these advantages, there are virtually no disadvantages, apart\nfrom not being standardized. This document seeks to change that. As we\npropose a new standard, a number of improvements not specific to Schnorr\nsignatures can be made:")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("Signature encoding")]),e._v(": Instead of using\n"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/X.690#DER_encoding",target:"_blank",rel:"noopener noreferrer"}},[e._v("DER"),n("OutboundLink")],1),e._v("-encoding for\nsignatures (which are variable size, and up to 72 bytes), we can use\na simple fixed 64-byte format.")]),e._v(" "),n("li",[n("strong",[e._v("Public key encoding")]),e._v(": Instead of using\n"),n("a",{attrs:{href:"https://www.secg.org/sec1-v2.pdf",target:"_blank",rel:"noopener noreferrer"}},[n("em",[e._v("compressed")]),n("OutboundLink")],1),e._v(" 33-byte encodings\nof elliptic curve points which are common in Bitcoin today, public\nkeys in this proposal are encoded as 32 bytes.")]),e._v(" "),n("li",[n("strong",[e._v("Batch verification")]),e._v(": The specific formulation of ECDSA signatures\nthat is standardized cannot be verified more efficiently in batch\ncompared to individually, unless additional witness data is added.\nChanging the signature scheme offers an opportunity to address this.")]),e._v(" "),n("li",[n("strong",[e._v("Completely specified")]),e._v(": To be safe for usage in consensus systems,\nthe verification algorithm must be completely specified at the byte\nlevel. This guarantees that nobody can construct a signature that is\nvalid to some verifiers but not all. This is traditionally not a\nrequirement for digital signature schemes, and the lack of exact\nspecification for the DER parsing of ECDSA signatures has caused\nproblems for Bitcoin "),n("a",{attrs:{href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2015-July/009697.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("in the\npast"),n("OutboundLink")],1),e._v(",\nneeding "),n("a",{attrs:{href:"bip-0066.mediawiki",title:"wikilink"}},[e._v("BIP66")]),e._v(" to address it. In\nthis document we aim to meet this property by design. For batch\nverification, which is inherently non-deterministic as the verifier\ncan choose their batches, this property implies that the outcome of\nverification may only differ from individual verifications with\nnegligible probability, even to an attacker who intentionally tries\nto make batch- and non-batch verification differ.")])]),e._v(" "),n("p",[e._v("By reusing the same curve and hash function as Bitcoin uses for ECDSA,\nwe are able to retain existing mechanisms for choosing secret and public\nkeys, and we avoid introducing new assumptions about the security of\nelliptic curves and hash functions.")]),e._v(" "),n("h2",{attrs:{id:"description"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#description"}},[e._v("#")]),e._v(" Description")]),e._v(" "),n("p",[e._v("We first build up the algebraic formulation of the signature scheme by\ngoing through the design choices. Afterwards, we specify the exact\nencodings and operations.")]),e._v(" "),n("h3",{attrs:{id:"design"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#design"}},[e._v("#")]),e._v(" Design")]),e._v(" "),n("p",[n("strong",[e._v("Schnorr signature variant")]),e._v(" Elliptic Curve Schnorr signatures for\nmessage "),n("em",[e._v("m")]),e._v(" and public key "),n("em",[e._v("P")]),e._v(" generally involve a point "),n("em",[e._v("R")]),e._v(", integers\n"),n("em",[e._v("e")]),e._v(" and "),n("em",[e._v("s")]),e._v(" picked by the signer, and the base point "),n("em",[e._v("G")]),e._v(" which satisfy\n"),n("em",[e._v("e = hash(R || m)")]),e._v(" and "),n("em",[e._v("s⋅G = R + e⋅P")]),e._v(". Two formulations exist,\ndepending on whether the signer reveals "),n("em",[e._v("e")]),e._v(" or "),n("em",[e._v("R")]),e._v(":")]),e._v(" "),n("ol",[n("li",[e._v("Signatures are pairs "),n("em",[e._v("(e, s)")]),e._v(" that satisfy "),n("em",[e._v("e = hash(s⋅G - e⋅P\n|| m)")]),e._v(". This variant avoids minor complexity introduced by the\nencoding of the point "),n("em",[e._v("R")]),e._v(' in the signature (see paragraphs\n"Encoding R and public key point P" and "Implicit Y coordinates"\nfurther below in this subsection). Moreover, revealing '),n("em",[e._v("e")]),e._v(" instead\nof "),n("em",[e._v("R")]),e._v(" allows for potentially shorter signatures: Whereas an\nencoding of "),n("em",[e._v("R")]),e._v(" inherently needs about 32 bytes, the hash "),n("em",[e._v("e")]),e._v(" can be\ntuned to be shorter than 32 bytes, and "),n("a",{attrs:{href:"http://www.neven.org/papers/schnorr.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("a short hash of only 16\nbytes suffices to provide SUF-CMA security at the target security\nlevel of 128 bits"),n("OutboundLink")],1),e._v(".\nHowever, a major drawback of this optimization is that finding\ncollisions in a short hash function is easy. This complicates the\nimplementation of secure signing protocols in scenarios in which a\ngroup of mutually distrusting signers work together to produce a\nsingle joint signature (see Applications below). In these scenarios,\nwhich are not captured by the SUF-CMA model due its assumption of a\nsingle honest signer, a promising attack strategy for malicious\nco-signers is to find a collision in the hash function in order to\nobtain a valid signature on a message that an honest co-signer did\nnot intend to sign.")]),e._v(" "),n("li",[e._v("Signatures are pairs "),n("em",[e._v("(R, s)")]),e._v(" that satisfy "),n("em",[e._v("s⋅G = R + hash(R ||\nm)⋅P")]),e._v(". This supports batch verification, as there are no elliptic\ncurve operations inside the hashes. Batch verification enables\nsignificant speedups.")])]),e._v(" "),n("p",[n("img",{attrs:{src:"bip-0340/speedup-batch.png",alt:"This graph shows the ratio between the time it takes to verify nsignatures individually and to verify a batch of n signatures. Thisratio goes up logarithmically with the number of signatures, or in otherwords: the total time to verify n signatures grows with O(n / logn).",title:"This graph shows the ratio between the time it takes to verify n signatures individually and to verify a batch of n signatures. This ratio goes up logarithmically with the number of signatures, or in other words: the total time to verify n signatures grows with O(n / log n)."}})]),e._v(" "),n("p",[e._v("Since we would like to avoid the fragility that comes with short hashes,\nthe "),n("em",[e._v("e")]),e._v(" variant does not provide significant advantages. We choose the\n"),n("em",[e._v("R")]),e._v("-option, which supports batch verification.")]),e._v(" "),n("p",[n("strong",[e._v("Key prefixing")]),e._v(' Using the verification rule above directly makes\nSchnorr signatures vulnerable to "related-key attacks" in which a\nthird party can convert a signature '),n("em",[e._v("(R, s)")]),e._v(" for public key "),n("em",[e._v("P")]),e._v(" into a\nsignature "),n("em",[e._v("(R, s + a⋅hash(R || m))")]),e._v(" for public key "),n("em",[e._v("P + a⋅G")]),e._v(" and the\nsame message "),n("em",[e._v("m")]),e._v(", for any given additive tweak "),n("em",[e._v("a")]),e._v(" to the signing key.\nThis would render signatures insecure when keys are generated using\n"),n("a",{attrs:{href:"bip-0032.mediawiki#public-parent-key--public-child-key",title:"wikilink"}},[e._v("BIP32's unhardened\nderivation")]),e._v("\nand other methods that rely on additive tweaks to existing keys such as\nTaproot.")]),e._v(" "),n("p",[e._v("To protect against these attacks, we choose "),n("em",[e._v("key prefixed")]),e._v("[^4] Schnorr\nsignatures which means that the public key is prefixed to the message in\nthe challenge hash input. This changes the equation to "),n("em",[e._v("s⋅G = R + hash(R\n|| P || m)⋅P")]),e._v(". "),n("a",{attrs:{href:"https://eprint.iacr.org/2015/1135.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("It can be\nshown"),n("OutboundLink")],1),e._v(" that key prefixing\nprotects against related-key attacks with additive tweaks. In general,\nkey prefixing increases robustness in multi-user settings, e.g., it\nseems to be a requirement for proving the MuSig multisignature scheme\nsecure (see Applications below).")]),e._v(" "),n("p",[e._v("We note that key prefixing is not strictly necessary for transaction\nsignatures as used in Bitcoin currently, because signed transactions\nindirectly commit to the public keys already, i.e., "),n("em",[e._v("m")]),e._v(" contains a\ncommitment to "),n("em",[e._v("pk")]),e._v(". However, this indirect commitment should not be\nrelied upon because it may change with proposals such as SIGHASH_NOINPUT\n("),n("a",{attrs:{href:"bip-0118.mediawiki",title:"wikilink"}},[e._v("BIP118")]),e._v("), and would render the\nsignature scheme unsuitable for other purposes than signing\ntransactions, e.g., "),n("a",{attrs:{href:"https://bitcoin.org/en/developer-reference#signmessage",target:"_blank",rel:"noopener noreferrer"}},[e._v("signing ordinary\nmessages"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("p",[n("strong",[e._v("Encoding R and public key point P")]),e._v(" There exist several possibilities\nfor encoding elliptic curve points:")]),e._v(" "),n("ol",[n("li",[e._v("Encoding the full X and Y coordinates of "),n("em",[e._v("P")]),e._v(" and "),n("em",[e._v("R")]),e._v(", resulting in a\n64-byte public key and a 96-byte signature.")]),e._v(" "),n("li",[e._v("Encoding the full X coordinate and one bit of the Y coordinate to\ndetermine one of the two possible Y coordinates. This would result\nin 33-byte public keys and 65-byte signatures.")]),e._v(" "),n("li",[e._v("Encoding only the X coordinate, resulting in 32-byte public keys and\n64-byte signatures.")])]),e._v(" "),n("p",[e._v("Using the first option would be slightly more efficient for verification\n(around 10%), but we prioritize compactness, and therefore choose option\n3.")]),e._v(" "),n("p",[n("strong",[e._v("Implicit Y coordinates")]),e._v(" In order to support efficient verification\nand batch verification, the Y coordinate of "),n("em",[e._v("P")]),e._v(" and of "),n("em",[e._v("R")]),e._v(" cannot be\nambiguous (every valid X coordinate has two possible Y coordinates). We\nhave a choice between several options for symmetry breaking:")]),e._v(" "),n("ol",[n("li",[e._v("Implicitly choosing the Y coordinate that is in the lower half.")]),e._v(" "),n("li",[e._v("Implicitly choosing the Y coordinate that is even[^5].")]),e._v(" "),n("li",[e._v("Implicitly choosing the Y coordinate that is a quadratic residue\n(i.e. has a square root modulo "),n("em",[e._v("p")]),e._v(").")])]),e._v(" "),n("p",[e._v("The second option offers the greatest compatibility with existing key\ngeneration systems, where the standard 33-byte compressed public key\nformat consists of a byte indicating the oddness of the Y coordinate,\nplus the full X coordinate. To avoid gratuitous incompatibilities, we\npick that option for "),n("em",[e._v("P")]),e._v(", and thus our X-only public keys become\nequivalent to a compressed public key that is the X-only key prefixed by\nthe byte 0x02. For consistency, the same is done for "),n("em",[e._v("R")]),e._v("[^6].")]),e._v(" "),n("p",[e._v("Despite halving the size of the set of valid public keys, implicit Y\ncoordinates are not a reduction in security. Informally, if a fast\nalgorithm existed to compute the discrete logarithm of an X-only public\nkey, then it could also be used to compute the discrete logarithm of a\nfull public key: apply it to the X coordinate, and then optionally\nnegate the result. This shows that breaking an X-only public key can be\nat most a small constant term faster than breaking a full one.[^7].")]),e._v(" "),n("p",[n("strong",[e._v("Tagged Hashes")]),e._v(" Cryptographic hash functions are used for multiple\npurposes in the specification below and in Bitcoin in general. To make\nsure hashes used in one context can't be reinterpreted in another one,\nhash functions can be tweaked with a context-dependent tag name, in such\na way that collisions across contexts can be assumed to be infeasible.\nSuch collisions obviously can not be ruled out completely, but only for\nschemes using tagging with a unique name. As for other schemes\ncollisions are at least less likely with tagging than without.")]),e._v(" "),n("p",[e._v("For example, without tagged hashing a BIP340 signature could also be\nvalid for a signature scheme where the only difference is that the\narguments to the hash function are reordered. Worse, if the BIP340 nonce\nderivation function was copied or independently created, then the nonce\ncould be accidentally reused in the other scheme leaking the secret key.")]),e._v(" "),n("p",[e._v("This proposal suggests to include the tag by prefixing the hashed data\nwith "),n("em",[e._v("SHA256(tag) || SHA256(tag)")]),e._v(". Because this is a 64-byte long\ncontext-specific constant and the "),n("em",[e._v("SHA256")]),e._v(" block size is also 64 bytes,\noptimized implementations are possible (identical to SHA256 itself, but\nwith a modified initial state). Using SHA256 of the tag name itself is\nreasonably simple and efficient for implementations that don't choose\nto use the optimization.")]),e._v(" "),n("p",[n("strong",[e._v("Final scheme")]),e._v(" As a result, our final scheme ends up using public key\n"),n("em",[e._v("pk")]),e._v(" which is the X coordinate of a point "),n("em",[e._v("P")]),e._v(" on the curve whose Y\ncoordinate is even and signatures "),n("em",[e._v("(r,s)")]),e._v(" where "),n("em",[e._v("r")]),e._v(" is the X coordinate\nof a point "),n("em",[e._v("R")]),e._v(" whose Y coordinate is even. The signature satisfies "),n("em",[e._v("s⋅G\n= R + tagged_hash(r || pk || m)⋅P")]),e._v(".")]),e._v(" "),n("h3",{attrs:{id:"specification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),n("p",[e._v("The following conventions are used, with constants as defined for\n"),n("a",{attrs:{href:"https://www.secg.org/sec2-v2.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("secp256k1"),n("OutboundLink")],1),e._v(". We note that adapting\nthis specification to other elliptic curves is not straightforward and\ncan result in an insecure scheme[^8].")]),e._v(" "),n("ul",[n("li",[e._v("Lowercase variables represent integers or byte arrays.\n"),n("ul",[n("li",[e._v("The constant "),n("em",[e._v("p")]),e._v(" refers to the field size,\n"),n("em",[e._v("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F")]),e._v(".")]),e._v(" "),n("li",[e._v("The constant "),n("em",[e._v("n")]),e._v(" refers to the curve order,\n"),n("em",[e._v("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141")]),e._v(".")])])]),e._v(" "),n("li",[e._v("Uppercase variables refer to points on the curve with equation "),n("em",[e._v("y^2^\n= x^3^ + 7")]),e._v(" over the integers modulo "),n("em",[e._v("p")]),e._v(".\n"),n("ul",[n("li",[n("em",[e._v("is_infinite(P)")]),e._v(" returns whether or not "),n("em",[e._v("P")]),e._v(" is the point at\ninfinity.")]),e._v(" "),n("li",[n("em",[e._v("x(P)")]),e._v(" and "),n("em",[e._v("y(P)")]),e._v(" are integers in the range "),n("em",[e._v("0..p-1")]),e._v(" and refer\nto the X and Y coordinates of a point "),n("em",[e._v("P")]),e._v(" (assuming it is not\ninfinity).")]),e._v(" "),n("li",[e._v("The constant "),n("em",[e._v("G")]),e._v(" refers to the base point, for which "),n("em",[e._v("x(G) =\n0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798")]),e._v("\nand "),n("em",[e._v("y(G) =\n0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8")]),e._v(".")]),e._v(" "),n("li",[e._v("Addition of points refers to the usual "),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Elliptic_curve#The_group_law",target:"_blank",rel:"noopener noreferrer"}},[e._v("elliptic curve group\noperation"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("li",[n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication",target:"_blank",rel:"noopener noreferrer"}},[e._v("Multiplication (⋅) of an integer and a\npoint"),n("OutboundLink")],1),e._v("\nrefers to the repeated application of the group operation.")])])]),e._v(" "),n("li",[e._v("Functions and operations:\n"),n("ul",[n("li",[n("em",[e._v("||")]),e._v(" refers to byte array concatenation.")]),e._v(" "),n("li",[e._v("The function "),n("em",[e._v("x[i:j]")]),e._v(", where "),n("em",[e._v("x")]),e._v(" is a byte array and "),n("em",[e._v("i, j ≥\n0")]),e._v(", returns a "),n("em",[e._v("(j - i)")]),e._v("-byte array with a copy of the "),n("em",[e._v("i")]),e._v("-th\nbyte (inclusive) to the "),n("em",[e._v("j")]),e._v("-th byte (exclusive) of "),n("em",[e._v("x")]),e._v(".")]),e._v(" "),n("li",[e._v("The function "),n("em",[e._v("bytes(x)")]),e._v(", where "),n("em",[e._v("x")]),e._v(" is an integer, returns the\n32-byte encoding of "),n("em",[e._v("x")]),e._v(", most significant byte first.")]),e._v(" "),n("li",[e._v("The function "),n("em",[e._v("bytes(P)")]),e._v(", where "),n("em",[e._v("P")]),e._v(" is a point, returns\n"),n("em",[e._v("bytes(x(P))")]),e._v(".")]),e._v(" "),n("li",[e._v("The function "),n("em",[e._v("int(x)")]),e._v(", where "),n("em",[e._v("x")]),e._v(" is a 32-byte array, returns the\n256-bit unsigned integer whose most significant byte first\nencoding is "),n("em",[e._v("x")]),e._v(".")]),e._v(" "),n("li",[e._v("The function "),n("em",[e._v("has_even_y(P)")]),e._v(", where "),n("em",[e._v("P")]),e._v(" is a point for which\n"),n("em",[e._v("not is_infinite(P)")]),e._v(", returns "),n("em",[e._v("y(P) mod 2 = 0")]),e._v(".")]),e._v(" "),n("li",[e._v("The function "),n("em",[e._v("lift_x(x)")]),e._v(", where "),n("em",[e._v("x")]),e._v(" is an integer in range\n"),n("em",[e._v("0..p-1")]),e._v(", returns the point "),n("em",[e._v("P")]),e._v(" for which "),n("em",[e._v("x(P) =\nx")]),n("code",[e._v("<ref>")])])])])]),e._v(" "),n("p",[n("code",[e._v("Given a candidate X coordinate")]),n("em",[n("code",[e._v("x")])]),n("code",[e._v("in the range")]),n("em",[n("code",[e._v("0..p-1")])]),n("code",[e._v(", there exist either exactly two or exactly zero valid Y coordinates. If no valid Y coordinate exists, then")]),n("em",[n("code",[e._v("x")])]),n("code",[e._v("is not a valid X coordinate either, i.e., no point")]),n("em",[n("code",[e._v("P")])]),n("code",[e._v("exists for which")]),n("em",[n("code",[e._v("x(P)`` ``=`` ``x")])]),n("code",[e._v(". The valid Y coordinates for a given candidate")]),n("em",[n("code",[e._v("x")])]),n("code",[e._v("are the square roots of")]),n("em",[n("code",[e._v("c`` ``=`` ``x")]),e._v("^"),n("code",[e._v("3")]),e._v("^"),n("code",[e._v("``+`` ``7`` ``mod`` ``p")])]),n("code",[e._v("and they can be computed as")]),n("em",[n("code",[e._v("y`` ``=`` ``±c")]),e._v("^"),n("code",[e._v("(p+1)/4")]),e._v("^"),n("code",[e._v("``mod`` ``p")])]),n("code",[e._v("(see")]),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Quadratic_residue#Prime_or_prime_power_modulus",target:"_blank",rel:"noopener noreferrer"}},[n("code",[e._v("Quadratic`` ``residue")]),n("OutboundLink")],1),n("code",[e._v(") if they exist, which can be checked by squaring and comparing with")]),n("em",[n("code",[e._v("c")])]),n("code",[e._v(". </ref>")]),e._v(" "),n("code",[e._v("and")]),n("em",[n("code",[e._v("has_even_y(P)")])]),n("code",[e._v(", or fails if no such point exists. The function")]),n("em",[n("code",[e._v("lift_x(x)")])]),n("code",[e._v("is equivalent to the following pseudocode:")])]),e._v(" "),n("ul",[n("li",[n("ul",[n("li",[e._v("Let "),n("em",[e._v("c = x^3^ + 7 mod p")]),e._v(".")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("y = c^(p+1)/4^ mod p")]),e._v(".")]),e._v(" "),n("li",[e._v("Fail if "),n("em",[e._v("c ≠ y^2^ mod p")]),e._v(".")]),e._v(" "),n("li",[e._v("Return the unique point "),n("em",[e._v("P")]),e._v(" such that "),n("em",[e._v("x(P) = x")]),e._v(" and "),n("em",[e._v("y(P) = y")]),e._v("\nif "),n("em",[e._v("y mod 2 = 0")]),e._v(" or "),n("em",[e._v("y(P) = p-y")]),e._v(" otherwise.")])])]),e._v(" "),n("li",[n("ul",[n("li",[e._v("The function "),n("em",[e._v("hash~tag~(x)")]),e._v(" where "),n("em",[e._v("tag")]),e._v(" is a UTF-8 encoded tag\nname and "),n("em",[e._v("x")]),e._v(" is a byte array returns the 32-byte hash\n"),n("em",[e._v("SHA256(SHA256(tag) || SHA256(tag) || x)")]),e._v(".")])])])]),e._v(" "),n("h4",{attrs:{id:"public-key-generation-public-key-generation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#public-key-generation-public-key-generation"}},[e._v("#")]),e._v(" Public Key Generation {#public_key_generation}")]),e._v(" "),n("p",[e._v("Input:")]),e._v(" "),n("ul",[n("li",[e._v("The secret key "),n("em",[e._v("sk")]),e._v(": a 32-byte array, freshly generated uniformly at\nrandom")])]),e._v(" "),n("p",[e._v("The algorithm "),n("em",[e._v("PubKey(sk)")]),e._v(" is defined as:")]),e._v(" "),n("ul",[n("li",[e._v("Let "),n("em",[e._v("d' = int(sk)")]),e._v(".")]),e._v(" "),n("li",[e._v("Fail if "),n("em",[e._v("d' = 0")]),e._v(" or "),n("em",[e._v("d' ≥ n")]),e._v(".")]),e._v(" "),n("li",[e._v("Return "),n("em",[e._v("bytes(d'⋅G)")]),e._v(".")])]),e._v(" "),n("p",[e._v("Note that we use a very different public key format (32 bytes) than the\nones used by existing systems (which typically use elliptic curve points\nas public keys, or 33-byte or 65-byte encodings of them). A side effect\nis that "),n("em",[e._v("PubKey(sk) = PubKey(bytes(n - int(sk))")]),e._v(", so every public key\nhas two corresponding secret keys.")]),e._v(" "),n("h4",{attrs:{id:"public-key-conversion-public-key-conversion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#public-key-conversion-public-key-conversion"}},[e._v("#")]),e._v(" Public Key Conversion {#public_key_conversion}")]),e._v(" "),n("p",[e._v("As an alternative to generating keys randomly, it is also possible and\nsafe to repurpose existing key generation algorithms for ECDSA in a\ncompatible way. The secret keys constructed by such an algorithm can be\nused as "),n("em",[e._v("sk")]),e._v(" directly. The public keys constructed by such an algorithm\n(assuming they use the 33-byte compressed encoding) need to be converted\nby dropping the first byte. Specifically,\n"),n("a",{attrs:{href:"bip-0032.mediawiki",title:"wikilink"}},[e._v("BIP32")]),e._v(" and schemes built on top of it\nremain usable.")]),e._v(" "),n("h4",{attrs:{id:"default-signing-default-signing"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#default-signing-default-signing"}},[e._v("#")]),e._v(" Default Signing {#default_signing}")]),e._v(" "),n("p",[e._v("Input:")]),e._v(" "),n("ul",[n("li",[e._v("The secret key "),n("em",[e._v("sk")]),e._v(": a 32-byte array")]),e._v(" "),n("li",[e._v("The message "),n("em",[e._v("m")]),e._v(": a 32-byte array")]),e._v(" "),n("li",[e._v("Auxiliary random data "),n("em",[e._v("a")]),e._v(": a 32-byte array")])]),e._v(" "),n("p",[e._v("The algorithm "),n("em",[e._v("Sign(sk, m)")]),e._v(" is defined as:")]),e._v(" "),n("ul",[n("li",[e._v("Let "),n("em",[e._v("d' = int(sk)")])]),e._v(" "),n("li",[e._v("Fail if "),n("em",[e._v("d' = 0")]),e._v(" or "),n("em",[e._v("d' ≥ n")])]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("P = d'⋅G")])]),e._v(" "),n("li",[e._v("Let ''d = d' '' if "),n("em",[e._v("has_even_y(P)")]),e._v(", otherwise let ''d = n -\nd' ''.")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("t")]),e._v(" be the byte-wise xor of "),n("em",[e._v("bytes(d)")]),e._v(" and\n"),n("em",[e._v("hash~BIP0340/aux~(a)")]),e._v("[^9].")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("rand = hash~BIP0340/nonce~(t || bytes(P) || m)")]),e._v("[^10].")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("k' = int(rand) mod n")]),e._v("[^11].")]),e._v(" "),n("li",[e._v("Fail if "),n("em",[e._v("k' = 0")]),e._v(".")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("R = k'⋅G")]),e._v(".")]),e._v(" "),n("li",[e._v("Let ''k = k' '' if "),n("em",[e._v("has_even_y(R)")]),e._v(", otherwise let ''k = n -\nk' ''.")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("e = int(hash~BIP0340/challenge~(bytes(R) || bytes(P) || m))\nmod n")]),e._v(".")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("sig = bytes(R) || bytes((k + ed) mod n)")]),e._v(".")]),e._v(" "),n("li",[e._v("If "),n("em",[e._v("Verify(bytes(P), m, sig)")]),e._v(" (see below) returns failure,\nabort[^12].")]),e._v(" "),n("li",[e._v("Return the signature "),n("em",[e._v("sig")]),e._v(".")])]),e._v(" "),n("p",[e._v("The auxiliary random data should be set to fresh randomness generated at\nsigning time, resulting in what is called a "),n("em",[e._v("synthetic nonce")]),e._v(". Using 32\nbytes of randomness is optimal. If obtaining randomness is expensive, 16\nrandom bytes can be padded with 16 null bytes to obtain a 32-byte array.\nIf randomness is not available at all at signing time, a simple counter\nwide enough to not repeat in practice (e.g., 64 bits or wider) and\npadded with null bytes to a 32 byte-array can be used, or even the\nconstant array with 32 null bytes. Using any non-repeating value\nincreases protection against "),n("a",{attrs:{href:"https://moderncrypto.org/mail-archive/curves/2017/000925.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("fault injection\nattacks"),n("OutboundLink")],1),e._v(".\nUsing unpredictable randomness additionally increases protection against\nother side-channel attacks, and is "),n("strong",[e._v("recommended whenever available")]),e._v(".\nNote that while this means the resulting nonce is not deterministic, the\nrandomness is only supplemental to security. The normal security\nproperties (excluding side-channel attacks) do not depend on the quality\nof the signing-time RNG.")]),e._v(" "),n("h4",{attrs:{id:"alternative-signing-alternative-signing"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#alternative-signing-alternative-signing"}},[e._v("#")]),e._v(" Alternative Signing {#alternative_signing}")]),e._v(" "),n("p",[e._v("It should be noted that various alternative signing algorithms can be\nused to produce equally valid signatures. The 32-byte "),n("em",[e._v("rand")]),e._v(" value may\nbe generated in other ways, producing a different but still valid\nsignature (in other words, this is not a "),n("em",[e._v("unique")]),e._v(" signature scheme).\n"),n("strong",[e._v("No matter which method is used to generate the "),n("em",[e._v("rand")]),e._v(" value, the value\nmust be a fresh uniformly random 32-byte string which is not even\npartially predictable for the attacker.")]),e._v(" For nonces without randomness\nthis implies that the same inputs must not be presented in another\ncontext. This can be most reliably accomplished by not reusing the same\nprivate key across different signing schemes. For example, if the "),n("em",[e._v("rand")]),e._v("\nvalue was computed as per RFC6979 and the same secret key is used in\ndeterministic ECDSA with RFC6979, the signatures can leak the secret key\nthrough nonce reuse.")]),e._v(" "),n("p",[n("strong",[e._v("Nonce exfiltration protection")]),e._v(" It is possible to strengthen the nonce\ngeneration algorithm using a second device. In this case, the second\ndevice contributes randomness which the actual signer provably\nincorporates into its nonce. This prevents certain attacks where the\nsigner device is compromised and intentionally tries to leak the secret\nkey through its nonce selection.")]),e._v(" "),n("p",[n("strong",[e._v("Multisignatures")]),e._v(" This signature scheme is compatible with various\ntypes of multisignature and threshold schemes such as\n"),n("a",{attrs:{href:"https://eprint.iacr.org/2018/068",target:"_blank",rel:"noopener noreferrer"}},[e._v("MuSig"),n("OutboundLink")],1),e._v(", where a single public key\nrequires holders of multiple secret keys to participate in signing (see\nApplications below). "),n("strong",[e._v("It is important to note that multisignature\nsigning schemes in general are insecure with the "),n("em",[e._v("rand")]),e._v(" generation from\nthe default signing algorithm above (or any other deterministic\nmethod).")])]),e._v(" "),n("p",[n("strong",[e._v("Precomputed public key data")]),e._v(" For many uses the compressed 33-byte\nencoding of the public key corresponding to the secret key may already\nbe known, making it easy to evaluate "),n("em",[e._v("has_even_y(P)")]),e._v(" and "),n("em",[e._v("bytes(P)")]),e._v(". As\nsuch, having signers supply this directly may be more efficient than\nrecalculating the public key from the secret key. However, if this\noptimization is used and additionally the signature verification at the\nend of the signing algorithm is dropped for increased efficiency,\nsigners must ensure the public key is correctly calculated and not taken\nfrom untrusted sources.")]),e._v(" "),n("h4",{attrs:{id:"verification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#verification"}},[e._v("#")]),e._v(" Verification")]),e._v(" "),n("p",[e._v("Input:")]),e._v(" "),n("ul",[n("li",[e._v("The public key "),n("em",[e._v("pk")]),e._v(": a 32-byte array")]),e._v(" "),n("li",[e._v("The message "),n("em",[e._v("m")]),e._v(": a 32-byte array")]),e._v(" "),n("li",[e._v("A signature "),n("em",[e._v("sig")]),e._v(": a 64-byte array")])]),e._v(" "),n("p",[e._v("The algorithm "),n("em",[e._v("Verify(pk, m, sig)")]),e._v(" is defined as:")]),e._v(" "),n("ul",[n("li",[e._v("Let "),n("em",[e._v("P = lift_x(int(pk))")]),e._v("; fail if that fails.")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("r = int(sig[0:32])")]),e._v("; fail if "),n("em",[e._v("r ≥ p")]),e._v(".")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("s = int(sig[32:64])")]),e._v("; fail if "),n("em",[e._v("s ≥ n")]),e._v(".")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("e = int(hash~BIP0340/challenge~(bytes(r) || bytes(P) || m))\nmod n")]),e._v(".")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("R = s⋅G - e⋅P")]),e._v(".")]),e._v(" "),n("li",[e._v("Fail if "),n("em",[e._v("is_infinite(R)")]),e._v(".")]),e._v(" "),n("li",[e._v("Fail if "),n("em",[e._v("not has_even_y(R)")]),e._v(".")]),e._v(" "),n("li",[e._v("Fail if "),n("em",[e._v("x(R) ≠ r")]),e._v(".")]),e._v(" "),n("li",[e._v("Return success iff no failure occurred before reaching this point.")])]),e._v(" "),n("p",[e._v("For every valid secret key "),n("em",[e._v("sk")]),e._v(" and message "),n("em",[e._v("m")]),e._v(",\n"),n("em",[e._v("Verify(PubKey(sk),m,Sign(sk,m))")]),e._v(" will succeed.")]),e._v(" "),n("p",[e._v("Note that the correctness of verification relies on the fact that\n"),n("em",[e._v("lift_x")]),e._v(" always returns a point with an even Y coordinate. A\nhypothetical verification algorithm that treats points as public keys,\nand takes the point "),n("em",[e._v("P")]),e._v(" directly as input would fail any time a point\nwith odd Y is used. While it is possible to correct for this by negating\npoints with odd Y coordinate before further processing, this would\nresult in a scheme where every (message, signature) pair is valid for\ntwo public keys (a type of malleability that exists for ECDSA as well,\nbut we don't wish to retain). We avoid these problems by treating just\nthe X coordinate as public key.")]),e._v(" "),n("h4",{attrs:{id:"batch-verification-batch-verification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#batch-verification-batch-verification"}},[e._v("#")]),e._v(" Batch Verification {#batch_verification}")]),e._v(" "),n("p",[e._v("Input:")]),e._v(" "),n("ul",[n("li",[e._v("The number "),n("em",[e._v("u")]),e._v(" of signatures")]),e._v(" "),n("li",[e._v("The public keys "),n("em",[e._v("pk~1..u~")]),e._v(": "),n("em",[e._v("u")]),e._v(" 32-byte arrays")]),e._v(" "),n("li",[e._v("The messages "),n("em",[e._v("m~1..u~")]),e._v(": "),n("em",[e._v("u")]),e._v(" 32-byte arrays")]),e._v(" "),n("li",[e._v("The signatures "),n("em",[e._v("sig~1..u~")]),e._v(": "),n("em",[e._v("u")]),e._v(" 64-byte arrays")])]),e._v(" "),n("p",[e._v("The algorithm "),n("em",[e._v("BatchVerify(pk~1..u~, m~1..u~, sig~1..u~)")]),e._v(" is defined as:")]),e._v(" "),n("ul",[n("li",[e._v("Generate "),n("em",[e._v("u-1")]),e._v(" random integers "),n("em",[e._v("a~2...u~")]),e._v(" in the range "),n("em",[e._v("1...n-1")]),e._v(".\nThey are generated deterministically using a\n"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator",target:"_blank",rel:"noopener noreferrer"}},[e._v("CSPRNG"),n("OutboundLink")],1),e._v("\nseeded by a cryptographic hash of all inputs of the algorithm, i.e.\n"),n("em",[e._v("seed = seed_hash(pk~1~..pk~u~ || m~1~..m~u~ || sig~1~..sig~u~\n)")]),e._v(". A safe choice is to instantiate "),n("em",[e._v("seed_hash")]),e._v(" with SHA256 and use\n"),n("a",{attrs:{href:"https://tools.ietf.org/html/rfc8439",target:"_blank",rel:"noopener noreferrer"}},[e._v("ChaCha20"),n("OutboundLink")],1),e._v(" with key "),n("em",[e._v("seed")]),e._v(" as a\nCSPRNG to generate 256-bit integers, skipping integers not in the\nrange "),n("em",[e._v("1...n-1")]),e._v(".")]),e._v(" "),n("li",[e._v("For "),n("em",[e._v("i = 1 .. u")]),e._v(":\n"),n("ul",[n("li",[e._v("Let "),n("em",[e._v("P~i~ = lift_x(int(pk~i~))")]),e._v("; fail if it fails.")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("r~i~ = int(sig~i~[0:32])")]),e._v("; fail if "),n("em",[e._v("r~i~ ≥ p")]),e._v(".")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("s~i~ = int(sig~i~[32:64])")]),e._v("; fail if "),n("em",[e._v("s~i~ ≥ n")]),e._v(".")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("e~i~ = int(hash~BIP0340/challenge~(bytes(r~i~) ||\nbytes(P~i~) || m~i~)) mod n")]),e._v(".")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("R~i~ = lift_x(r~i~)")]),e._v("; fail if "),n("em",[e._v("lift_x(r~i~)")]),e._v(" fails.")])])]),e._v(" "),n("li",[e._v("Fail if "),n("em",[e._v("(s~1~ + a~2~s~2~ + ... + a~u~s~u~)⋅G ≠ R~1~ + a~2~⋅R~2~ +\n... + a~u~⋅R~u~ + e~1~⋅P~1~ + (a~2~e~2~)⋅P~2~ + ... +\n(a~u~e~u~)⋅P~u~")]),e._v(".")]),e._v(" "),n("li",[e._v("Return success iff no failure occurred before reaching this point.")])]),e._v(" "),n("p",[e._v("If all individual signatures are valid (i.e., "),n("em",[e._v("Verify")]),e._v(" would return\nsuccess for them), "),n("em",[e._v("BatchVerify")]),e._v(" will always return success. If at least\none signature is invalid, "),n("em",[e._v("BatchVerify")]),e._v(" will return success with at most\na negligible probability.")]),e._v(" "),n("h2",{attrs:{id:"applications"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#applications"}},[e._v("#")]),e._v(" Applications")]),e._v(" "),n("p",[e._v("There are several interesting applications beyond simple signatures.\nWhile recent academic papers claim that they are also possible with\nECDSA, consensus support for Schnorr signature verification would\nsignificantly simplify the constructions.")]),e._v(" "),n("h3",{attrs:{id:"multisignatures-and-threshold-signatures-multisignatures-and-threshold-signatures"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#multisignatures-and-threshold-signatures-multisignatures-and-threshold-signatures"}},[e._v("#")]),e._v(" Multisignatures and Threshold Signatures {#multisignatures_and_threshold_signatures}")]),e._v(" "),n("p",[e._v("By means of an interactive scheme such as\n"),n("a",{attrs:{href:"https://eprint.iacr.org/2018/068",target:"_blank",rel:"noopener noreferrer"}},[e._v("MuSig"),n("OutboundLink")],1),e._v(", participants can aggregate\ntheir public keys into a single public key which they can jointly sign\nfor. This allows "),n("em",[e._v("n")]),e._v("-of-"),n("em",[e._v("n")]),e._v(" multisignatures which, from a verifier's\nperspective, are no different from ordinary signatures, giving improved\nprivacy and efficiency versus "),n("em",[e._v("CHECKMULTISIG")]),e._v(" or other means.")]),e._v(" "),n("p",[e._v("Moreover, Schnorr signatures are compatible with "),n("a",{attrs:{href:"https://web.archive.org/web/20031003232851/http://www.research.ibm.com/security/dkg.ps",target:"_blank",rel:"noopener noreferrer"}},[e._v("distributed key\ngeneration"),n("OutboundLink")],1),e._v(",\nwhich enables interactive threshold signatures schemes, e.g., the\nschemes described by "),n("a",{attrs:{href:"http://cacr.uwaterloo.ca/techreports/2001/corr2001-13.ps",target:"_blank",rel:"noopener noreferrer"}},[e._v("Stinson and Strobl\n(2001)"),n("OutboundLink")],1),e._v(" or\n"),n("a",{attrs:{href:"https://web.archive.org/web/20060911151529/http://theory.lcs.mit.edu/~stasio/Papers/gjkr03.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Gennaro, Jarecki and Krawczyk\n(2003)"),n("OutboundLink")],1),e._v(".\nThese protocols make it possible to realize "),n("em",[e._v("k")]),e._v("-of-"),n("em",[e._v("n")]),e._v(" threshold\nsignatures, which ensure that any subset of size "),n("em",[e._v("k")]),e._v(" of the set of "),n("em",[e._v("n")]),e._v("\nsigners can sign but no subset of size less than "),n("em",[e._v("k")]),e._v(" can produce a valid\nSchnorr signature. However, the practicality of the existing schemes is\nlimited: most schemes in the literature have been proven secure only for\nthe case "),n("em",[e._v("k-1 < n/2")]),e._v(", are not secure when used concurrently in multiple\nsessions, or require a reliable broadcast mechanism to be secure.\nFurther research is necessary to improve this situation.")]),e._v(" "),n("h3",{attrs:{id:"adaptor-signatures-adaptor-signatures"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#adaptor-signatures-adaptor-signatures"}},[e._v("#")]),e._v(" Adaptor Signatures {#adaptor_signatures}")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2018-05-18-l2/slides.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Adaptor\nsignatures"),n("OutboundLink")],1),e._v("\ncan be produced by a signer by offsetting his public nonce with a known\npoint "),n("em",[e._v("T = t⋅G")]),e._v(", but not offsetting his secret nonce. A correct\nsignature (or partial signature, as individual signers' contributions\nto a multisignature are called) on the same message with same nonce will\nthen be equal to the adaptor signature offset by "),n("em",[e._v("t")]),e._v(", meaning that\nlearning "),n("em",[e._v("t")]),e._v(" is equivalent to learning a correct signature. This can be\nused to enable atomic swaps or even "),n("a",{attrs:{href:"https://eprint.iacr.org/2018/472",target:"_blank",rel:"noopener noreferrer"}},[e._v("general payment\nchannels"),n("OutboundLink")],1),e._v(" in which the atomicity of\ndisjoint transactions is ensured using the signatures themselves, rather\nthan Bitcoin script support. The resulting transactions will appear to\nverifiers to be no different from ordinary single-signer transactions,\nexcept perhaps for the inclusion of locktime refund logic.")]),e._v(" "),n("p",[e._v("Adaptor signatures, beyond the efficiency and privacy benefits of\nencoding script semantics into constant-sized signatures, have\nadditional benefits over traditional hash-based payment channels.\nSpecifically, the secret values "),n("em",[e._v("t")]),e._v(" may be reblinded between hops,\nallowing long chains of transactions to be made atomic while even the\nparticipants cannot identify which transactions are part of the chain.\nAlso, because the secret values are chosen at signing time, rather than\nkey generation time, existing outputs may be repurposed for different\napplications without recourse to the blockchain, even multiple times.")]),e._v(" "),n("h3",{attrs:{id:"blind-signatures-blind-signatures"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#blind-signatures-blind-signatures"}},[e._v("#")]),e._v(" Blind Signatures {#blind_signatures}")]),e._v(" "),n("p",[e._v("A blind signature protocol is an interactive protocol that enables a\nsigner to sign a message at the behest of another party without learning\nany information about the signed message or the signature. Schnorr\nsignatures admit a very "),n("a",{attrs:{href:"https://www.math.uni-frankfurt.de/~dmst/research/papers/schnorr.blind_sigs_attack.2001.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("simple blind signature\nscheme"),n("OutboundLink")],1),e._v("\nwhich is however insecure because it's vulnerable to "),n("a",{attrs:{href:"https://www.iacr.org/archive/crypto2002/24420288/24420288.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Wagner's\nattack"),n("OutboundLink")],1),e._v(".\nA known mitigation is to let the signer abort a signing session with a\ncertain probability, and the resulting scheme can be "),n("a",{attrs:{href:"https://eprint.iacr.org/2019/877",target:"_blank",rel:"noopener noreferrer"}},[e._v("proven secure\nunder non-standard cryptographic\nassumptions"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("p",[e._v("Blind Schnorr signatures could for example be used in "),n("a",{attrs:{href:"https://github.com/ElementsProject/scriptless-scripts/blob/master/md/partially-blind-swap.md",target:"_blank",rel:"noopener noreferrer"}},[e._v("Partially Blind\nAtomic\nSwaps"),n("OutboundLink")],1),e._v(",\na construction to enable transferring of coins, mediated by an untrusted\nescrow agent, without connecting the transactors in the public\nblockchain transaction graph.")]),e._v(" "),n("h2",{attrs:{id:"test-vectors-and-reference-code-test-vectors-and-reference-code"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#test-vectors-and-reference-code-test-vectors-and-reference-code"}},[e._v("#")]),e._v(" Test Vectors and Reference Code {#test_vectors_and_reference_code}")]),e._v(" "),n("p",[e._v("For development and testing purposes, we provide a "),n("a",{attrs:{href:"bip-0340/test-vectors.csv",title:"wikilink"}},[e._v("collection of test\nvectors in CSV format")]),e._v(" and a\nnaive, highly inefficient, and non-constant time "),n("a",{attrs:{href:"bip-0340/reference.py",title:"wikilink"}},[e._v("pure Python 3.7\nreference implementation of the signing and verification\nalgorithm")]),e._v(". The reference\nimplementation is for demonstration purposes only and not to be used in\nproduction environments.")]),e._v(" "),n("h2",{attrs:{id:"footnotes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#footnotes"}},[e._v("#")]),e._v(" Footnotes")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<references />\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("h2",{attrs:{id:"acknowledgements"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#acknowledgements"}},[e._v("#")]),e._v(" Acknowledgements")]),e._v(" "),n("p",[e._v("This document is the result of many discussions around Schnorr based\nsignatures over the years, and had input from Johnson Lau, Greg Maxwell,\nAndrew Poelstra, Rusty Russell, and Anthony Towns. The authors further\nwish to thank all those who provided valuable feedback and reviews,\nincluding the participants of the "),n("a",{attrs:{href:"https://github.com/ajtowns/taproot-review",target:"_blank",rel:"noopener noreferrer"}},[e._v("structured\nreviews"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("p",[e._v("[^1]: Informally, this means that without knowledge of the secret key\nbut given valid signatures of arbitrary messages, it is not possible\nto come up with further valid signatures.")]),e._v(" "),n("p",[e._v("[^2]: A detailed security proof in the random oracle model, which\nessentially restates "),n("a",{attrs:{href:"https://www.di.ens.fr/~pointche/Documents/Papers/2000_joc.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("the original security proof by Pointcheval and\nStern"),n("OutboundLink")],1),e._v("\nmore explicitly, can be found in "),n("a",{attrs:{href:"https://eprint.iacr.org/2016/191",target:"_blank",rel:"noopener noreferrer"}},[e._v("a paper by Kiltz, Masny and\nPan"),n("OutboundLink")],1),e._v(". All these security proofs\nassume a variant of Schnorr signatures that use "),n("em",[e._v("(e,s)")]),e._v(" instead of\n"),n("em",[e._v("(R,s)")]),e._v(" (see Design above). Since we use a unique encoding of "),n("em",[e._v("R")]),e._v(",\nthere is an efficiently computable bijection that maps "),n("em",[e._v("(R,s)")]),e._v(" to\n"),n("em",[e._v("(e,s)")]),e._v(", which allows to convert a successful SUF-CMA attacker for\nthe "),n("em",[e._v("(e,s)")]),e._v(" variant to a successful SUF-CMA attacker for the "),n("em",[e._v("(R,s)")]),e._v("\nvariant (and vice-versa). Furthermore, the proofs consider a variant\nof Schnorr signatures without key prefixing (see Design above), but\nit can be verified that the proofs are also correct for the variant\nwith key prefixing. As a result, all the aforementioned security\nproofs apply to the variant of Schnorr signatures proposed in this\ndocument.")]),e._v(" "),n("p",[e._v("[^3]: If "),n("em",[e._v("(r,s)")]),e._v(" is a valid ECDSA signature for a given message and key,\nthen "),n("em",[e._v("(r,n-s)")]),e._v(" is also valid for the same message and key. If ECDSA\nis restricted to only permit one of the two variants (as Bitcoin\ndoes through a policy rule on the network), it can be\n"),n("a",{attrs:{href:"https://nbn-resolving.de/urn:nbn:de:hbz:294-60803",target:"_blank",rel:"noopener noreferrer"}},[e._v("proven"),n("OutboundLink")],1),e._v("\nnon-malleable under stronger than usual assumptions.")]),e._v(" "),n("p",[e._v("[^4]: A limitation of committing to the public key (rather than to a\nshort hash of it, or not at all) is that it removes the ability for\npublic key recovery or verifying signatures against a short public\nkey hash. These constructions are generally incompatible with batch\nverification.")]),e._v(" "),n("p",[e._v("[^5]: Since "),n("em",[e._v("p")]),e._v(" is odd, negation modulo "),n("em",[e._v("p")]),e._v(" will map even numbers to odd\nnumbers and the other way around. This means that for a valid X\ncoordinate, one of the corresponding Y coordinates will be even, and\nthe other will be odd.")]),e._v(" "),n("p",[e._v("[^6]: An earlier version of this draft used the third option instead,\nbased on a belief that this would in general trade signing\nefficiency for verification efficiency. When using Jacobian\ncoordinates, a common optimization in ECC implementations, it is\npossible to determine if a Y coordinate is a quadratic residue by\ncomputing the Legendre symbol, without converting to affine\ncoordinates first (which needs a modular inversion). As modular\ninverses and Legendre symbols have similar\n"),n("a",{attrs:{href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-August/018081.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("performance"),n("OutboundLink")],1),e._v("\nin practice, this trade-off is not worth it.")]),e._v(" "),n("p",[e._v("[^7]: This can be formalized by a simple reduction that reduces an\nattack on Schnorr signatures with implicit Y coordinates to an\nattack to Schnorr signatures with explicit Y coordinates. The\nreduction works by reencoding public keys and negating the result of\nthe hash function, which is modeled as random oracle, whenever the\nchallenge public key has an explicit Y coordinate that is odd. A\nproof sketch can be found\n"),n("a",{attrs:{href:"https://medium.com/blockstream/reducing-bitcoin-transaction-sizes-with-x-only-pubkeys-f86476af05d7",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("p",[e._v("[^8]: Among other pitfalls, using the specification with a curve whose\norder is not close to the size of the range of the nonce derivation\nfunction is insecure.")]),e._v(" "),n("p",[e._v("[^9]: The auxiliary random data is hashed (with a unique tag) as a\nprecaution against situations where the randomness may be correlated\nwith the private key itself. It is xored with the private key\n(rather than combined with it in a hash) to reduce the number of\noperations exposed to the actual secret key.")]),e._v(" "),n("p",[e._v("[^10]: Including the "),n("a",{attrs:{href:"https://moderncrypto.org/mail-archive/curves/2020/001012.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("public key as input to the nonce\nhash"),n("OutboundLink")],1),e._v("\nhelps ensure the robustness of the signing algorithm by preventing\nleakage of the secret key if the calculation of the public key "),n("em",[e._v("P")]),e._v("\nis performed incorrectly or maliciously, for example if it is left\nto the caller for performance reasons.")]),e._v(" "),n("p",[e._v("[^11]: Note that in general, taking a uniformly random 256-bit integer\nmodulo the curve order will produce an unacceptably biased result.\nHowever, for the secp256k1 curve, the order is sufficiently close to\n"),n("em",[e._v("2^256^")]),e._v(" that this bias is not observable ("),n("em",[e._v("1 - n / 2^256^")]),e._v(" is\naround "),n("em",[e._v("1.27 * 2^-128^")]),e._v(").")]),e._v(" "),n("p",[e._v("[^12]: Verifying the signature before leaving the signer prevents random\nor attacker provoked computation errors. This prevents publishing\ninvalid signatures which may leak information about the secret key.\nIt is recommended, but can be omitted if the computation cost is\nprohibitive.")])])}),[],!1,null,null,null);t.default=a.exports}}]);