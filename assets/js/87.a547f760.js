(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{462:function(e,t,n){"use strict";n.r(t);var i=n(43),a=Object(i.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_341"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_341"}},[e._v("#")]),e._v(" 341")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  BIP: 341\n  Layer: Consensus (soft fork)\n  Title: Taproot: SegWit version 1 spending rules\n  Author: Pieter Wuille <pieter.wuille@gmail.com>\n          Jonas Nick <jonasd.nick@gmail.com>\n          Anthony Towns <aj@erisian.com.au>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0341\n  Status: Draft\n  Type: Standards Track\n  Created: 2020-01-19\n  License: BSD-3-Clause\n  Requires: 340\n  Post-History: 2019-05-06: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-May/016914.html [bitcoin-dev] Taproot proposal\n                2019-10-09: https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2019-October/017378.html [bitcoin-dev] Taproot updates\n")])])]),n("h2",{attrs:{id:"introduction"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#introduction"}},[e._v("#")]),e._v(" Introduction")]),e._v(" "),n("h3",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("This document proposes a new SegWit version 1 output type, with spending\nrules based on Taproot, Schnorr signatures, and Merkle branches.")]),e._v(" "),n("h3",{attrs:{id:"copyright"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),n("p",[e._v("This document is licensed under the 3-clause BSD license.")]),e._v(" "),n("h3",{attrs:{id:"motivation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),n("p",[e._v("This proposal aims to improve privacy, efficiency, and flexibility of\nBitcoin's scripting capabilities without adding new security\nassumptions[^1]. Specifically, it seeks to minimize how much information\nabout the spendability conditions of a transaction output is revealed on\nchain at creation or spending time and to add a number of upgrade\nmechanisms, while fixing a few minor but long-standing issues.")]),e._v(" "),n("h2",{attrs:{id:"design"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#design"}},[e._v("#")]),e._v(" Design")]),e._v(" "),n("p",[e._v("A number of related ideas for improving Bitcoin's scripting\ncapabilities have been previously proposed: Schnorr signatures\n("),n("a",{attrs:{href:"bip-0340.mediawiki",title:"wikilink"}},[e._v("BIP340")]),e._v('), Merkle branches ("MAST",\n'),n("a",{attrs:{href:"bip-0114.mediawiki",title:"wikilink"}},[e._v("BIP114")]),e._v(",\n"),n("a",{attrs:{href:"bip-0117.mediawiki",title:"wikilink"}},[e._v("BIP117")]),e._v("), new sighash modes\n("),n("a",{attrs:{href:"bip-0118.mediawiki",title:"wikilink"}},[e._v("BIP118")]),e._v("), new opcodes like\nCHECKSIGFROMSTACK,\n"),n("a",{attrs:{href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-January/015614.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Taproot"),n("OutboundLink")],1),e._v(",\n"),n("a",{attrs:{href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-February/015700.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Graftroot"),n("OutboundLink")],1),e._v(",\n"),n("a",{attrs:{href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-July/016249.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("G'root"),n("OutboundLink")],1),e._v(",\nand "),n("a",{attrs:{href:"https://bitcointalk.org/index.php?topic=1377298.0",target:"_blank",rel:"noopener noreferrer"}},[e._v("cross-input\naggregation"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("p",[e._v("Combining all these ideas in a single proposal would be an extensive\nchange, be hard to review, and likely miss new discoveries that\notherwise could have been made along the way. Not all are equally mature\nas well. For example, cross-input aggregation\n"),n("a",{attrs:{href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-March/015838.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("interacts"),n("OutboundLink")],1),e._v("\nin complex ways with upgrade mechanisms, and solutions to that are still\n"),n("a",{attrs:{href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2018-October/016461.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("in\nflux"),n("OutboundLink")],1),e._v(".\nOn the other hand, separating them all into independent upgrades would\nreduce the efficiency and privacy gains to be had, and wallet and\nservice providers may not be inclined to go through many incremental\nupdates. Therefore, we're faced with a tradeoff between functionality\nand scope creep. In this design we strike a balance by focusing on the\nstructural script improvements offered by Taproot and Merkle branches,\nas well as changes necessary to make them usable and efficient. For\nthings like sighashes and opcodes we include fixes for known problems,\nbut exclude new features that can be added independently with no\ndownsides.")]),e._v(" "),n("p",[e._v("As a result we choose this combination of technologies:")]),e._v(" "),n("ul",[n("li",[n("strong",[e._v("Merkle branches")]),e._v(" let us only reveal the actually executed part of\nthe script to the blockchain, as opposed to all possible ways a\nscript can be executed. Among the various known mechanisms for\nimplementing this, one where the Merkle tree becomes part of the\nscript's structure directly maximizes the space savings, so that\napproach is chosen.")]),e._v(" "),n("li",[n("strong",[e._v("Taproot")]),e._v(" on top of that lets us merge the traditionally separate\npay-to-pubkey and pay-to-scripthash policies, making all outputs\nspendable by either a key or (optionally) a script, and\nindistinguishable from each other. As long as the key-based spending\npath is used for spending, it is not revealed whether a script path\nwas permitted as well, resulting in space savings and an increase in\nscripting privacy at spending time.")]),e._v(" "),n("li",[e._v("Taproot's advantages become apparent under the assumption that most\napplications involve outputs that could be spent by all parties\nagreeing. That's where "),n("strong",[e._v("Schnorr")]),e._v(" signatures come in, as they\npermit "),n("a",{attrs:{href:"https://eprint.iacr.org/2018/068",target:"_blank",rel:"noopener noreferrer"}},[e._v("key aggregation"),n("OutboundLink")],1),e._v(": a public\nkey can be constructed from multiple participant public keys, and\nwhich requires cooperation between all participants to sign for.\nSuch multi-party public keys and signatures are indistinguishable\nfrom their single-party equivalents. This means that with taproot\nmost applications can use the key-based spending path, which is both\nefficient and private. This can be generalized to arbitrary M-of-N\npolicies, as Schnorr signatures support threshold signing, at the\ncost of more complex setup protocols.")]),e._v(" "),n("li",[e._v("As Schnorr signatures also permit "),n("strong",[e._v("batch validation")]),e._v(", allowing\nmultiple signatures to be validated together more efficiently than\nvalidating each one independently, we make sure all parts of the\ndesign are compatible with this.")]),e._v(" "),n("li",[e._v("Where unused bits appear as a result of the above changes, they are\nreserved for mechanisms for "),n("strong",[e._v("future extensions")]),e._v(". As a result,\nevery script in the Merkle tree has an associated version such that\nnew script versions can be introduced with a soft fork while\nremaining compatible with BIP 341. Additionally, future soft forks\ncan make use of the currently unused "),n("code",[e._v("annex")]),e._v(" in the witness (see\n"),n("a",{attrs:{href:"bip-0341.mediawiki#Rationale",title:"wikilink"}},[e._v("BIP341")]),e._v(").")]),e._v(" "),n("li",[e._v("While the core semantics of the "),n("strong",[e._v("signature hashing algorithm")]),e._v(" are\nnot changed, a number of improvements are included in this proposal.\nThe new signature hashing algorithm fixes the verification\ncapabilities of offline signing devices by including amount and\nscriptPubKey in the signature message, avoids unnecessary hashing,\nuses "),n("strong",[e._v("tagged hashes")]),e._v(" and defines a default sighash byte.")]),e._v(" "),n("li",[e._v("The "),n("strong",[e._v("public key is directly included in the output")]),e._v(" in contrast to\ntypical earlier constructions which store a hash of the public key\nor script in the output. This has the same cost for senders and is\nmore space efficient overall if the key-based spending path is\ntaken. [^2]")])]),e._v(" "),n("p",[e._v("Informally, the resulting design is as follows: a new witness version is\nadded (version 1), whose programs consist of 32-byte encodings of points\n"),n("em",[e._v("Q")]),e._v(". "),n("em",[e._v("Q")]),e._v(" is computed as "),n("em",[e._v("P + hash(P||m)G")]),e._v(" for a public key "),n("em",[e._v("P")]),e._v(", and\nthe root "),n("em",[e._v("m")]),e._v(" of a Merkle tree whose leaves consist of a version number\nand a script. These outputs can be spent directly by providing a\nsignature for "),n("em",[e._v("Q")]),e._v(", or indirectly by revealing "),n("em",[e._v("P")]),e._v(", the script and leaf\nversion, inputs that satisfy the script, and a Merkle path that proves\n"),n("em",[e._v("Q")]),e._v(" committed to that leaf. All hashes in this construction (the hash\nfor computing "),n("em",[e._v("Q")]),e._v(" from "),n("em",[e._v("P")]),e._v(", the hashes inside the Merkle tree's inner\nnodes, and the signature hashes used) are tagged to guarantee domain\nseparation.")]),e._v(" "),n("h2",{attrs:{id:"specification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),n("p",[e._v("This section specifies the Taproot consensus rules. Validity is defined\nby exclusion: a block or transaction is valid if no condition exists\nthat marks it failed.")]),e._v(" "),n("p",[e._v("The notation below follows that of\n"),n("a",{attrs:{href:"bip-0340.mediawiki#design",title:"wikilink"}},[e._v("BIP340")]),e._v(". This includes the\n"),n("em",[e._v("hash~tag~(x)")]),e._v(" notation to refer to "),n("em",[e._v("SHA256(SHA256(tag) || SHA256(tag)\n|| x)")]),e._v(". To the best of the authors' knowledge, no existing use of\nSHA256 in Bitcoin feeds it a message that starts with two single SHA256\noutputs, making collisions between "),n("em",[e._v("hash~tag~")]),e._v(" with other hashes\nextremely unlikely.")]),e._v(" "),n("h3",{attrs:{id:"script-validation-rules-script-validation-rules"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#script-validation-rules-script-validation-rules"}},[e._v("#")]),e._v(" Script validation rules {#script_validation_rules}")]),e._v(" "),n("p",[e._v("A Taproot output is a native SegWit output (see\n"),n("a",{attrs:{href:"bip-0141.mediawiki",title:"wikilink"}},[e._v("BIP141")]),e._v(") with version number 1, and a\n32-byte witness program. The following rules only apply when such an\noutput is being spent. Any other outputs, including version 1 outputs\nwith lengths other than 32 bytes, or P2SH-wrapped version 1 outputs[^3],\nremain unencumbered.")]),e._v(" "),n("ul",[n("li",[e._v("Let "),n("em",[e._v("q")]),e._v(" be the 32-byte array containing the witness program (the\nsecond push in the scriptPubKey) which represents a public key\naccording to "),n("a",{attrs:{href:"bip-0340.mediawiki#design",title:"wikilink"}},[e._v("BIP340")]),e._v(".")]),e._v(" "),n("li",[e._v("Fail if the witness stack has 0 elements.")]),e._v(" "),n("li",[e._v("If there are at least two witness elements, and the first byte of\nthe last element is 0x50[^4], this last element is called "),n("em",[e._v("annex")]),e._v(" "),n("em",[e._v("a")]),e._v("[^5] and is removed from the witness stack. The annex (or the\nlack of thereof) is always covered by the signature and contributes\nto transaction weight, but is otherwise ignored during taproot\nvalidation.")]),e._v(" "),n("li",[e._v("If there is exactly one element left in the witness stack, key path\nspending is used:\n"),n("ul",[n("li",[e._v("The single witness stack element is interpreted as the signature\nand must be valid (see the next section) for the public key "),n("em",[e._v("q")]),e._v("\n(see the next subsection).")])])]),e._v(" "),n("li",[e._v("If there are at least two witness elements left, script path\nspending is used:\n"),n("ul",[n("li",[e._v("Call the second-to-last stack element "),n("em",[e._v("s")]),e._v(", the script.")]),e._v(" "),n("li",[e._v("The last stack element is called the control block "),n("em",[e._v("c")]),e._v(", and must\nhave length "),n("em",[e._v("33 + 32m")]),e._v(", for a value of "),n("em",[e._v("m")]),e._v(" that is an integer\nbetween 0 and 128[^6], inclusive. Fail if it does not have such\na length.")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("p = c[1:33]")]),e._v(" and let "),n("em",[e._v("P = lift_x(int(p))")]),e._v(" where "),n("em",[e._v("lift_x")]),e._v("\nand "),n("em",[e._v("[:]")]),e._v(" are defined as in\n"),n("a",{attrs:{href:"bip-0340.mediawiki#design",title:"wikilink"}},[e._v("BIP340")]),e._v(". Fail if this\npoint is not on the curve.")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("v = c[0] & 0xfe")]),e._v(" and call it the "),n("em",[e._v("leaf version")]),e._v("[^7].")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("k~0~ = hash~TapLeaf~(v || compact_size(size of s)\n|| s)")]),e._v("; also call it the "),n("em",[e._v("tapleaf hash")]),e._v(".")]),e._v(" "),n("li",[e._v("For "),n("em",[e._v("j")]),e._v(" in "),n("em",[e._v("[0,1,...,m-1]")]),e._v(":\n"),n("ul",[n("li",[e._v("Let "),n("em",[e._v("e~j~ = c[33+32j:65+32j]")]),e._v(".")]),e._v(" "),n("li",[e._v("Let ''k~j+1~ depend on whether "),n("em",[e._v("k~j~ < e~j~")]),e._v("\n(lexicographically)[^8]:\n"),n("ul",[n("li",[e._v("If "),n("em",[e._v("k~j~ < e~j~")]),e._v(": "),n("em",[e._v("k~j+1~ = hash~TapBranch~(k~j~ ||\ne~j~)")]),e._v("[^9].")]),e._v(" "),n("li",[e._v("If "),n("em",[e._v("k~j~ ≥ e~j~")]),e._v(": "),n("em",[e._v("k~j+1~ = hash~TapBranch~(e~j~ ||\nk~j~)")]),e._v(".")])])])])]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("t = hash~TapTweak~(p || k~m~)")]),e._v(".")]),e._v(" "),n("li",[e._v("If "),n("em",[e._v("t ≥ 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B\nBFD25E8C D0364141")]),e._v(" (order of secp256k1), fail.")]),e._v(" "),n("li",[e._v("Let "),n("em",[e._v("Q = P + int(t)G")]),e._v(".")]),e._v(" "),n("li",[e._v("If "),n("em",[e._v("q ≠ x(Q)")]),e._v(" or "),n("em",[e._v("c[0] & 1 ≠ y(Q) mod 2")]),e._v(", fail[^10].")]),e._v(" "),n("li",[e._v("Execute the script, according to the applicable script\nrules[^11], using the witness stack elements excluding the\nscript "),n("em",[e._v("s")]),e._v(", the control block "),n("em",[e._v("c")]),e._v(", and the annex "),n("em",[e._v("a")]),e._v(" if present,\nas initial stack.")])])])]),e._v(" "),n("p",[n("em",[e._v("q")]),e._v(" is referred to as "),n("em",[e._v("taproot output key")]),e._v(" and "),n("em",[e._v("p")]),e._v(" as "),n("em",[e._v("taproot internal\nkey")]),e._v(".")]),e._v(" "),n("h3",{attrs:{id:"signature-validation-rules-signature-validation-rules"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#signature-validation-rules-signature-validation-rules"}},[e._v("#")]),e._v(" Signature validation rules {#signature_validation_rules}")]),e._v(" "),n("p",[e._v("We first define a reusable common signature message calculation\nfunction, followed by the actual signature validation as it's used in\nkey path spending.")]),e._v(" "),n("h4",{attrs:{id:"common-signature-message-common-signature-message"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#common-signature-message-common-signature-message"}},[e._v("#")]),e._v(" Common signature message {#common_signature_message}")]),e._v(" "),n("p",[e._v("The function "),n("em",[e._v("SigMsg(hash_type, ext_flag)")]),e._v(" computes the message being\nsigned as a byte array. It is implicitly also a function of the spending\ntransaction and the outputs it spends, but these are not listed to keep\nnotation simple.")]),e._v(" "),n("p",[e._v("The parameter "),n("em",[e._v("hash_type")]),e._v(" is an 8-bit unsigned value. The "),n("code",[e._v("SIGHASH")]),e._v("\nencodings from the legacy script system are reused, including\n"),n("code",[e._v("SIGHASH_ALL")]),e._v(", "),n("code",[e._v("SIGHASH_NONE")]),e._v(", "),n("code",[e._v("SIGHASH_SINGLE")]),e._v(", and\n"),n("code",[e._v("SIGHASH_ANYONECANPAY")]),e._v(", plus the default "),n("em",[e._v("hash_type")]),e._v(" value "),n("em",[e._v("0x00")]),e._v(" which\nresults in signing over the whole transaction just as for "),n("code",[e._v("SIGHASH_ALL")]),e._v(".\nThe following restrictions apply, which cause validation failure if\nviolated:")]),e._v(" "),n("ul",[n("li",[e._v("Using any undefined "),n("em",[e._v("hash_type")]),e._v(" (not "),n("em",[e._v("0x00")]),e._v(", "),n("em",[e._v("0x01")]),e._v(", "),n("em",[e._v("0x02")]),e._v(", "),n("em",[e._v("0x03")]),e._v(",\n"),n("em",[e._v("0x81")]),e._v(", "),n("em",[e._v("0x82")]),e._v(", or "),n("em",[e._v("0x83")]),e._v("[^12]).")]),e._v(" "),n("li",[e._v("Using "),n("code",[e._v("SIGHASH_SINGLE")]),e._v(' without a "corresponding output" (an output\nwith the same index as the input being verified).')])]),e._v(" "),n("p",[e._v("The parameter "),n("em",[e._v("ext_flag")]),e._v(" is an integer in range 0-127, and is used for\nindicating (in the message) that extensions are added at the end of the\nmessage[^13].")]),e._v(" "),n("p",[e._v("If the parameters take acceptable values, the message is the\nconcatenation of the following data, in order (with byte size of each\nitem listed in parentheses). Numerical values in 2, 4, or 8-byte are\nencoded in little-endian.")]),e._v(" "),n("ul",[n("li",[e._v("Control:\n"),n("ul",[n("li",[n("em",[e._v("hash_type")]),e._v(" (1).")])])]),e._v(" "),n("li",[e._v("Transaction data:\n"),n("ul",[n("li",[n("em",[e._v("nVersion")]),e._v(" (4): the "),n("em",[e._v("nVersion")]),e._v(" of the transaction.")]),e._v(" "),n("li",[n("em",[e._v("nLockTime")]),e._v(" (4): the "),n("em",[e._v("nLockTime")]),e._v(" of the transaction.")]),e._v(" "),n("li",[e._v("If the "),n("em",[e._v("hash_type & 0x80")]),e._v(" does not equal "),n("code",[e._v("SIGHASH_ANYONECANPAY")]),e._v(":\n"),n("ul",[n("li",[n("em",[e._v("sha_prevouts")]),e._v(" (32): the SHA256 of the serialization of all\ninput outpoints.")]),e._v(" "),n("li",[n("em",[e._v("sha_amounts")]),e._v(" (32): the SHA256 of the serialization of all\nspent output amounts.")]),e._v(" "),n("li",[n("em",[e._v("sha_scriptpubkeys")]),e._v(" (32): the SHA256 of the serialization of\nall spent output "),n("em",[e._v("scriptPubKey")]),e._v("s.")]),e._v(" "),n("li",[n("em",[e._v("sha_sequences")]),e._v(" (32): the SHA256 of the serialization of all\ninput "),n("em",[e._v("nSequence")]),e._v(".")])])]),e._v(" "),n("li",[e._v("If "),n("em",[e._v("hash_type & 3")]),e._v(" does not equal "),n("code",[e._v("SIGHASH_NONE")]),e._v(" or\n"),n("code",[e._v("SIGHASH_SINGLE")]),e._v(":\n"),n("ul",[n("li",[n("em",[e._v("sha_outputs")]),e._v(" (32): the SHA256 of the serialization of all\noutputs in "),n("code",[e._v("CTxOut")]),e._v(" format.")])])])])]),e._v(" "),n("li",[e._v("Data about this input:\n"),n("ul",[n("li",[n("em",[e._v("spend_type")]),e._v(" (1): equal to "),n("em",[e._v("(ext_flag * 2) + annex_present")]),e._v(",\nwhere "),n("em",[e._v("annex_present")]),e._v(" is 0 if no annex is present, or 1\notherwise (the original witness stack has two or more witness\nelements, and the first byte of the last element is "),n("em",[e._v("0x50")]),e._v(")")]),e._v(" "),n("li",[e._v("If "),n("em",[e._v("hash_type & 0x80")]),e._v(" equals "),n("code",[e._v("SIGHASH_ANYONECANPAY")]),e._v(":\n"),n("ul",[n("li",[n("em",[e._v("outpoint")]),e._v(" (36): the "),n("code",[e._v("COutPoint")]),e._v(" of this input (32-byte\nhash + 4-byte little-endian).")]),e._v(" "),n("li",[n("em",[e._v("amount")]),e._v(" (8): value of the previous output spent by this\ninput.")]),e._v(" "),n("li",[n("em",[e._v("scriptPubKey")]),e._v(" (35): "),n("em",[e._v("scriptPubKey")]),e._v(" of the previous output\nspent by this input, serialized as script inside "),n("code",[e._v("CTxOut")]),e._v(".\nIts size is always 35 bytes.")]),e._v(" "),n("li",[n("em",[e._v("nSequence")]),e._v(" (4): "),n("em",[e._v("nSequence")]),e._v(" of this input.")])])]),e._v(" "),n("li",[e._v("If "),n("em",[e._v("hash_type & 0x80")]),e._v(" does not equal "),n("code",[e._v("SIGHASH_ANYONECANPAY")]),e._v(":\n"),n("ul",[n("li",[n("em",[e._v("input_index")]),e._v(" (4): index of this input in the transaction\ninput vector. Index of the first input is 0.")])])]),e._v(" "),n("li",[e._v("If an annex is present (the lowest bit of "),n("em",[e._v("spend_type")]),e._v(" is set):\n"),n("ul",[n("li",[n("em",[e._v("sha_annex")]),e._v(" (32): the SHA256 of "),n("em",[e._v("(compact_size(size of\nannex) || annex)")]),e._v(", where "),n("em",[e._v("annex")]),e._v(" includes the mandatory\n"),n("em",[e._v("0x50")]),e._v(" prefix.")])])])])]),e._v(" "),n("li",[e._v("Data about this output:\n"),n("ul",[n("li",[e._v("If "),n("em",[e._v("hash_type & 3")]),e._v(" equals "),n("code",[e._v("SIGHASH_SINGLE")]),e._v(":\n"),n("ul",[n("li",[n("em",[e._v("sha_single_output")]),e._v(" (32): the SHA256 of the corresponding\noutput in "),n("code",[e._v("CTxOut")]),e._v(" format.")])])])])])]),e._v(" "),n("p",[e._v("The total length of "),n("em",[e._v("SigMsg()")]),e._v(" is at most "),n("em",[e._v("206")]),e._v(" bytes[^14]. Note that\nthis does not include the size of sub-hashes such as "),n("em",[e._v("sha_prevouts")]),e._v(",\nwhich may be cached across signatures of the same transaction.")]),e._v(" "),n("p",[e._v("In summary, the semantics of the "),n("a",{attrs:{href:"bip-0143.mediawiki",title:"wikilink"}},[e._v("BIP143")]),e._v("\nsighash types remain unchanged, except the following:")]),e._v(" "),n("ol",[n("li",[e._v("The way and order of serialization is changed.[^15]")]),e._v(" "),n("li",[e._v("The signature message commits to the "),n("em",[e._v("scriptPubKey")]),e._v(" of the spent\noutput and if the "),n("code",[e._v("SIGHASH_ANYONECANPAY")]),e._v(" flag is not set, the\nmessage commits to the "),n("em",[e._v("scriptPubKey")]),e._v("s of "),n("em",[e._v("all")]),e._v(" outputs spent by the\ntransaction. [^16].")]),e._v(" "),n("li",[e._v("If the "),n("code",[e._v("SIGHASH_ANYONECANPAY")]),e._v(" flag is not set, the message commits\nto the amounts of "),n("em",[e._v("all")]),e._v(" transaction inputs.[^17]")]),e._v(" "),n("li",[e._v("The signature message commits to all input "),n("em",[e._v("nSequence")]),e._v(" if\n"),n("code",[e._v("SIGHASH_NONE")]),e._v(" or "),n("code",[e._v("SIGHASH_SINGLE")]),e._v(" are set (unless\n"),n("code",[e._v("SIGHASH_ANYONECANPAY")]),e._v(" is set as well).[^18]")]),e._v(" "),n("li",[e._v("The signature message includes commitments to the taproot-specific\ndata "),n("em",[e._v("spend_type")]),e._v(" and "),n("em",[e._v("annex")]),e._v(" (if present).")])]),e._v(" "),n("h4",{attrs:{id:"taproot-key-path-spending-signature-validation-taproot-key-path-spending-signature-validation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#taproot-key-path-spending-signature-validation-taproot-key-path-spending-signature-validation"}},[e._v("#")]),e._v(" Taproot key path spending signature validation {#taproot_key_path_spending_signature_validation}")]),e._v(" "),n("p",[e._v("To validate a signature "),n("em",[e._v("sig")]),e._v(" with public key "),n("em",[e._v("q")]),e._v(":")]),e._v(" "),n("ul",[n("li",[e._v("If the "),n("em",[e._v("sig")]),e._v(" is 64 bytes long, return "),n("em",[e._v("Verify(q,\nhash~TapSighash~(0x00 || SigMsg(0x00, 0)), sig)")]),e._v("[^19], where\n"),n("em",[e._v("Verify")]),e._v(" is defined in\n"),n("a",{attrs:{href:"bip-0340.mediawiki#design",title:"wikilink"}},[e._v("BIP340")]),e._v(".")]),e._v(" "),n("li",[e._v("If the "),n("em",[e._v("sig")]),e._v(" is 65 bytes long, return "),n("em",[e._v("sig[64] ≠ 0x00[^20] and\nVerify(q, hash~TapSighash~(0x00 || SigMsg(sig[64], 0)),\nsig[0:64])")]),e._v(".")]),e._v(" "),n("li",[e._v("Otherwise, fail[^21].")])]),e._v(" "),n("h2",{attrs:{id:"constructing-and-spending-taproot-outputs-constructing-and-spending-taproot-outputs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#constructing-and-spending-taproot-outputs-constructing-and-spending-taproot-outputs"}},[e._v("#")]),e._v(" Constructing and spending Taproot outputs {#constructing_and_spending_taproot_outputs}")]),e._v(" "),n("p",[e._v("This section discusses how to construct and spend Taproot outputs. It\nonly affects wallet software that chooses to implement receiving and\nspending, and is not consensus critical in any way.")]),e._v(" "),n("p",[e._v("Conceptually, every Taproot output corresponds to a combination of a\nsingle public key condition (the internal key), and zero or more general\nconditions encoded in scripts organized in a tree. Satisfying any of\nthese conditions is sufficient to spend the output.")]),e._v(" "),n("p",[n("strong",[e._v("Initial steps")]),e._v(" The first step is determining what the internal key\nand the organization of the rest of the scripts should be. The specifics\nare likely application dependent, but here are some general guidelines:")]),e._v(" "),n("ul",[n("li",[e._v("When deciding between scripts with conditionals ("),n("code",[e._v("OP_IF")]),e._v(" etc.) and\nsplitting them up into multiple scripts (each corresponding to one\nexecution path through the original script), it is generally\npreferable to pick the latter.")]),e._v(" "),n("li",[e._v("When a single condition requires signatures with multiple keys, key\naggregation techniques like MuSig can be used to combine them into a\nsingle key. The details are out of scope for this document, but note\nthat this may complicate the signing procedure.")]),e._v(" "),n("li",[e._v('If one or more of the spending conditions consist of just a single\nkey (after aggregation), the most likely one should be made the\ninternal key. If no such condition exists, it may be worthwhile\nadding one that consists of an aggregation of all keys participating\nin all scripts combined; effectively adding an "everyone agrees"\nbranch. If that is inacceptable, pick as internal key a point with\nunknown discrete logarithm. One example of such a point is '),n("em",[e._v("H =\nlift_x(0x0250929b74c1a04954b78b4b6035e97a5e078a5a0f28ec96d547bfee9ace803ac0)")]),e._v("\nwhich is\n"),n("a",{attrs:{href:"https://github.com/ElementsProject/secp256k1-zkp/blob/11af7015de624b010424273be3d91f117f172c82/src/modules/rangeproof/main_impl.h#L16",target:"_blank",rel:"noopener noreferrer"}},[e._v("constructed"),n("OutboundLink")],1),e._v("\nby taking the hash of the standard uncompressed encoding of the\n"),n("a",{attrs:{href:"https://www.secg.org/sec2-v2.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("secp256k1"),n("OutboundLink")],1),e._v(" base point "),n("em",[e._v("G")]),e._v(" as X\ncoordinate. In order to avoid leaking the information that key path\nspending is not possible it is recommended to pick a fresh integer\n"),n("em",[e._v("r")]),e._v(" in the range "),n("em",[e._v("0...n-1")]),e._v(" uniformly at random and use "),n("em",[e._v("H + rG")]),e._v(" as\ninternal key. It is possible to prove that this internal key does\nnot have a known discrete logarithm with respect to "),n("em",[e._v("G")]),e._v(" by revealing\n"),n("em",[e._v("r")]),e._v(" to a verifier who can then reconstruct how the internal key was\ncreated.")]),e._v(" "),n("li",[e._v("If the spending conditions do not require a script path, the output\nkey should commit to an unspendable script path instead of having no\nscript path. This can be achieved by computing the output key point\nas "),n("em",[e._v("Q = P + int(hash~TapTweak~(bytes(P)))G")]),e._v(". "),n("code",[e._v("<ref>")]),e._v(" "),n("strong",[e._v("Why\nshould the output key always have a taproot commitment, even if\nthere is no script path?")])])]),e._v(" "),n("p",[e._v("If the taproot output key is an aggregate of keys, there is the\npossibility for a malicious party to add a script path without being\nnoticed by the other parties. This allows to bypass the multiparty\npolicy and to steal the coin. MuSig key aggregation does not have this\nissue because it already causes the internal key to be randomized.")]),e._v(" "),n("p",[e._v("The attack works as follows: Assume Alice and Mallory want to aggregate\ntheir keys into a taproot output key without a script path. In order to\nprevent key cancellation and related attacks they use\n"),n("a",{attrs:{href:"https://eprint.iacr.org/2018/483.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("MSDL-pop"),n("OutboundLink")],1),e._v(" instead of MuSig. The\nMSDL-pop protocol requires all parties to provide a proof of possession\nof their corresponding secret key and the aggregated key is just the sum\nof the individual keys. After Mallory receives Alice's key "),n("em",[e._v("A")]),e._v(", Mallory\ncreates "),n("em",[e._v("M = M~0~ + int(t)G")]),e._v(" where "),n("em",[e._v("M~0~")]),e._v(" is Mallory's original key and\n"),n("em",[e._v("t")]),e._v(" allows a script path spend with internal key "),n("em",[e._v("P = A + M~0~")]),e._v(" and a\nscript that only contains Mallory's key. Mallory sends a proof of\npossession of "),n("em",[e._v("M")]),e._v(" to Alice and both parties compute output key "),n("em",[e._v("Q = A +\nM = P + int(t)G")]),e._v(". Alice will not be able to notice the script path, but\nMallory can unilaterally spend any coin with output key "),n("em",[e._v("Q")]),e._v(".\n"),n("code",[e._v("</ref>")])]),e._v(" "),n("ul",[n("li",[e._v("The remaining scripts should be organized into the leaves of a\nbinary tree. This can be a balanced tree if each of the conditions\nthese scripts correspond to are equally likely. If probabilities for\neach condition are known, consider constructing the tree as a\nHuffman tree.")])]),e._v(" "),n("p",[n("strong",[e._v("Computing the output script")]),e._v(" Once the spending conditions are split\ninto an internal key "),n("code",[e._v("internal_pubkey")]),e._v(" and a binary tree whose leaves\nare (leaf_version, script) tuples, the output script can be computed\nusing the Python3 algorithms below. These algorithms take advantage of\nhelper functions from the [bip-0340/referency.py BIP340 reference\ncode] for integer conversion, point multiplication, and tagged hashes.")]),e._v(" "),n("p",[e._v("First, we define "),n("code",[e._v("taproot_tweak_pubkey")]),e._v(" for 32-byte\n"),n("a",{attrs:{href:"bip-0340.mediawiki",title:"wikilink"}},[e._v("BIP340")]),e._v(" public key arrays. The function\nreturns a bit indicating the tweaked public key's Y coordinate as well\nas the public key byte array. The parity bit will be required for\nspending the output with a script path. In order to allow spending with\nthe key path, we define "),n("code",[e._v("taproot_tweak_seckey")]),e._v(" to compute the secret key\nfor a tweaked public key. For any byte string "),n("code",[e._v("h")]),e._v(" it holds that\n"),n("code",[e._v("taproot_tweak_pubkey(pubkey_gen(seckey), h)[0] == pubkey_gen(taproot_tweak_seckey(seckey, h))")]),e._v(".")]),e._v(" "),n("div",{staticClass:"language-{.python} line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('def taproot_tweak_pubkey(pubkey, h):\n    t = int_from_bytes(tagged_hash("TapTweak", pubkey + h))\n    if t >= SECP256K1_ORDER:\n        raise ValueError\n    Q = point_add(lift_x(int_from_bytes(pubkey)), point_mul(G, t))\n    return 0 if has_even_y(Q) else 1, bytes_from_int(x(Q))\n\ndef taproot_tweak_seckey(seckey0, h):\n    P = point_mul(G, int_from_bytes(seckey0))\n    seckey = seckey0 if has_even_y(P) else SECP256K1_ORDER - seckey0\n    t = int_from_bytes(tagged_hash("TapTweak", bytes_from_int(x(P)) + h))\n    if t >= SECP256K1_ORDER:\n        raise ValueError\n    return (seckey + t) % SECP256K1_ORDER\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br")])]),n("p",[e._v("The following function, "),n("code",[e._v("taproot_output_script")]),e._v(", returns a byte array\nwith the scriptPubKey (see "),n("a",{attrs:{href:"bip-0141.mediawiki",title:"wikilink"}},[e._v("BIP141")]),e._v(").\n"),n("code",[e._v("ser_script")]),e._v(" refers to a function that prefixes its input with a\nCompactSize-encoded length.")]),e._v(" "),n("div",{staticClass:"language-{.python} line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('def taproot_tree_helper(script_tree):\n    if isinstance(script_tree, tuple):\n        leaf_version, script = script_tree\n        h = tagged_hash("TapLeaf", bytes([leaf_version]) + ser_script(script))\n        return ([((leaf_version, script), bytes())], h)\n    left, left_h = taproot_tree_helper(script_tree[0])\n    right, right_h = taproot_tree_helper(script_tree[1])\n    ret = [(l, c + right_h) for l, c in left] + [(l, c + left_h) for l, c in right]\n    if right_h < left_h:\n        left_h, right_h = right_h, left_h\n    return (ret, tagged_hash("TapBranch", left_h + right_h))\n\ndef taproot_output_script(internal_pubkey, script_tree):\n    """Given a internal public key and a tree of scripts, compute the output script.\n    script_tree is either:\n     - a (leaf_version, script) tuple (leaf_version is 0xc0 for [[bip-0342.mediawiki|BIP342]] scripts)\n     - a list of two elements, each with the same structure as script_tree itself\n     - None\n    """\n    if script_tree is None:\n        h = bytes()\n    else:\n        _, h = taproot_tree_helper(script_tree)\n    output_pubkey, _ = taproot_tweak_pubkey(internal_pubkey, h)\n    return bytes([0x51, 0x20]) + output_pubkey\n')])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br"),n("span",{staticClass:"line-number"},[e._v("8")]),n("br"),n("span",{staticClass:"line-number"},[e._v("9")]),n("br"),n("span",{staticClass:"line-number"},[e._v("10")]),n("br"),n("span",{staticClass:"line-number"},[e._v("11")]),n("br"),n("span",{staticClass:"line-number"},[e._v("12")]),n("br"),n("span",{staticClass:"line-number"},[e._v("13")]),n("br"),n("span",{staticClass:"line-number"},[e._v("14")]),n("br"),n("span",{staticClass:"line-number"},[e._v("15")]),n("br"),n("span",{staticClass:"line-number"},[e._v("16")]),n("br"),n("span",{staticClass:"line-number"},[e._v("17")]),n("br"),n("span",{staticClass:"line-number"},[e._v("18")]),n("br"),n("span",{staticClass:"line-number"},[e._v("19")]),n("br"),n("span",{staticClass:"line-number"},[e._v("20")]),n("br"),n("span",{staticClass:"line-number"},[e._v("21")]),n("br"),n("span",{staticClass:"line-number"},[e._v("22")]),n("br"),n("span",{staticClass:"line-number"},[e._v("23")]),n("br"),n("span",{staticClass:"line-number"},[e._v("24")]),n("br"),n("span",{staticClass:"line-number"},[e._v("25")]),n("br")])]),n("p",[n("img",{attrs:{src:"bip-0341/tree.png",alt:"This diagram shows the hashing structure to obtain the tweak from aninternal key P and a Merkle tree consisting of 5 script leaves. A,B, C and E are TapLeaf hashes similar to D and AB is aTapBranch hash. Note that when CDE is computed E is hashed firstbecause E is less thanCD.",title:"This diagram shows the hashing structure to obtain the tweak from an internal key P and a Merkle tree consisting of 5 script leaves. A, B, C and E are TapLeaf hashes similar to D and AB is a TapBranch hash. Note that when CDE is computed E is hashed first because E is less than CD."}})]),e._v(" "),n("p",[e._v("To spend this output using script "),n("em",[e._v("D")]),e._v(", the control block would contain\nthe following data in this order:")]),e._v(" "),n("p",[n("code",[e._v("<control byte with leaf version and parity bit>")]),e._v(" "),n("code",[e._v("<internal key p>")]),e._v(" "),n("code",[e._v("<C>")]),e._v(" "),n("code",[e._v("<E>")]),e._v(" "),n("code",[e._v("<AB>")])]),e._v(" "),n("p",[e._v("The TapTweak would then be computed as described\n"),n("a",{attrs:{href:"bip-0341.mediawiki#script-validation-rules",title:"wikilink"}},[e._v("above")]),e._v(" like so:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v('D = tagged_hash("TapLeaf", bytes([leaf_version]) + ser_script(script))\nCD = tagged_hash("TapBranch", C + D)\nCDE = tagged_hash("TapBranch", E + CD)\nABCDE = tagged_hash("TapBranch", AB + CDE)\nTapTweak = tagged_hash("TapTweak", p + ABCDE)\n')])])]),n("p",[n("strong",[e._v("Spending using the key path")]),e._v(" A Taproot output can be spent with the\nsecret key corresponding to the "),n("code",[e._v("internal_pubkey")]),e._v(". To do so, a witness\nstack consists of a single element: a\n"),n("a",{attrs:{href:"bip-0340.mediawiki",title:"wikilink"}},[e._v("BIP340")]),e._v(" signature on the signature hash\nas defined above, with the secret key tweaked by the same "),n("code",[e._v("h")]),e._v(" as in the\nabove snippet. See the code below:")]),e._v(" "),n("div",{staticClass:"language-{.python} line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("def taproot_sign_key(script_tree, internal_seckey, hash_type):\n    _, h = taproot_tree_helper(script_tree)\n    output_seckey = taproot_tweak_seckey(internal_seckey, h)\n    sig = schnorr_sign(sighash(hash_type), output_seckey)\n    if hash_type != 0:\n        sig += bytes([hash_type])\n    return [sig]\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br"),n("span",{staticClass:"line-number"},[e._v("7")]),n("br")])]),n("p",[e._v("This function returns the witness stack necessary and a "),n("code",[e._v("sighash")]),e._v("\nfunction to compute the signature hash as defined above (for simplicity,\nthe snippet above ignores passing information like the transaction, the\ninput position, ... to the sighashing code).")]),e._v(" "),n("p",[n("strong",[e._v("Spending using one of the scripts")]),e._v(" A Taproot output can be spent by\nsatisfying any of the scripts used in its construction. To do so, a\nwitness stack consisting of the script's inputs, plus the script itself\nand the control block are necessary. See the code below:")]),e._v(" "),n("div",{staticClass:"language-{.python} line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("def taproot_sign_script(internal_pubkey, script_tree, script_num, inputs):\n    info, h = taproot_tree_helper(script_tree)\n    (leaf_version, script), path = info[script_num]\n    output_pubkey_y_parity, _ = taproot_tweak_pubkey(internal_pubkey, h)\n    pubkey_data = bytes([output_pubkey_y_parity + leaf_version]) + internal_pubkey\n    return inputs + [script, pubkey_data + path]\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br"),n("span",{staticClass:"line-number"},[e._v("2")]),n("br"),n("span",{staticClass:"line-number"},[e._v("3")]),n("br"),n("span",{staticClass:"line-number"},[e._v("4")]),n("br"),n("span",{staticClass:"line-number"},[e._v("5")]),n("br"),n("span",{staticClass:"line-number"},[e._v("6")]),n("br")])]),n("h2",{attrs:{id:"security"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#security"}},[e._v("#")]),e._v(" Security")]),e._v(" "),n("p",[e._v('Taproot improves the privacy of Bitcoin because instead of revealing all\npossible conditions for spending an output, only the satisfied spending\ncondition has to be published. Ideally, outputs are spent using the key\npath which prevents observers from learning the spending conditions of a\ncoin. A key path spend could be a "normal" payment from a single- or\nmulti-signature wallet or the cooperative settlement of hidden\nmultiparty contract.')]),e._v(" "),n("p",[e._v("A script path spend leaks that there is a script path and that the key\npath was not applicable - for example because the involved parties\nfailed to reach agreement. Moreover, the depth of a script in the Merkle\nroot leaks information including the minimum depth of the tree, which\nsuggests specific wallet software that created the output and helps\nclustering. Therefore, the privacy of script spends can be improved by\ndeviating from the optimal tree determined by the probability\ndistribution over the leaves.")]),e._v(" "),n("p",[e._v("Just like other existing output types, taproot outputs should never\nreuse keys, for privacy reasons. This does not only apply to the\nparticular leaf that was used to spend an output but to all leaves\ncommitted to in the output. If leaves were reused, it could happen that\nspending a different output would reuse the same Merkle branches in the\nMerkle proof. Using fresh keys implies that taproot output construction\ndoes not need to take special measures to randomizing leaf positions\nbecause they are already randomized due to the branch-sorting Merkle\ntree construction used in taproot. This does not avoid leaking\ninformation through the leaf depth and therefore only applies to\nbalanced (sub-) trees. In addition, every leaf should have a set of keys\ndistinct from every other leaf. The reason for this is to increase leaf\nentropy and prevent an observer from learning an undisclosed script\nusing brute-force search.")]),e._v(" "),n("h2",{attrs:{id:"test-vectors-test-vectors"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#test-vectors-test-vectors"}},[e._v("#")]),e._v(" Test vectors {#test_vectors}")]),e._v(" "),n("p",[e._v("Examples with creation transaction and spending transaction pairs, valid\nand invalid.")]),e._v(" "),n("p",[e._v("Examples of preimage for sighashing for each of the sighash modes.")]),e._v(" "),n("h2",{attrs:{id:"rationale"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<references />\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("h2",{attrs:{id:"deployment"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#deployment"}},[e._v("#")]),e._v(" Deployment")]),e._v(" "),n("p",[e._v("TODO")]),e._v(" "),n("h2",{attrs:{id:"backwards-compatibility-backwards-compatibility"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility-backwards-compatibility"}},[e._v("#")]),e._v(" Backwards compatibility {#backwards_compatibility}")]),e._v(" "),n("p",[e._v("As a soft fork, older software will continue to operate without\nmodification. Non-upgraded nodes, however, will consider all SegWit\nversion 1 witness programs as anyone-can-spend scripts. They are\nstrongly encouraged to upgrade in order to fully validate the new\nprograms.")]),e._v(" "),n("p",[e._v("Non-upgraded wallets can receive and send bitcoin from non-upgraded and\nupgraded wallets using SegWit version 0 programs, traditional\npay-to-pubkey-hash, etc. Depending on the implementation non-upgraded\nwallets may be able to send to Segwit version 1 programs if they support\nsending to "),n("a",{attrs:{href:"bip-0173.mediawiki",title:"wikilink"}},[e._v("BIP173")]),e._v(" Bech32 addresses.")]),e._v(" "),n("h2",{attrs:{id:"acknowledgements"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#acknowledgements"}},[e._v("#")]),e._v(" Acknowledgements")]),e._v(" "),n("p",[e._v("This document is the result of discussions around script and signature\nimprovements with many people, and had direct contributions from Greg\nMaxwell and others. It further builds on top of earlier published\nproposals such as Taproot by Greg Maxwell, and Merkle branch\nconstructions by Russell O'Connor, Johnson Lau, and Mark Friedenbach.")]),e._v(" "),n("p",[e._v("The authors wish the thank Arik Sosman for suggesting to sort Merkle\nnode children before hashes, removing the need to transfer the position\nin the tree, as well as all those who provided valuable feedback and\nreviews, including the participants of the "),n("a",{attrs:{href:"https://github.com/ajtowns/taproot-review",target:"_blank",rel:"noopener noreferrer"}},[e._v("structured\nreviews"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("p",[e._v("[^1]: "),n("strong",[e._v("What does not adding security assumptions mean?")]),e._v(" Unforgeability\nof signatures is a necessary requirement to prevent theft. At least\nwhen treating script execution as a digital signature scheme itself,\nunforgeability can be "),n("a",{attrs:{href:"https://github.com/apoelstra/taproot",target:"_blank",rel:"noopener noreferrer"}},[e._v("proven"),n("OutboundLink")],1),e._v("\nin the Random Oracle Model assuming the Discrete Logarithm problem\nis hard. A\n"),n("a",{attrs:{href:"https://nbn-resolving.de/urn:nbn:de:hbz:294-60803",target:"_blank",rel:"noopener noreferrer"}},[e._v("proof"),n("OutboundLink")],1),e._v(" for\nunforgeability of ECDSA in the current script system needs\nnon-standard assumptions on top of that. Note that it is hard in\ngeneral to model exactly what security for script means, as it\ndepends on the policies and protocols used by wallet software.")]),e._v(" "),n("p",[e._v("[^2]: "),n("strong",[e._v("Why is the public key directly included in the output?")]),e._v(" While\ntypical earlier constructions store a hash of a script or a public\nkey in the output, this is rather wasteful when a public key is\nalways involved. To guarantee batch verifiability, the public key\nmust be known to every verifier, and thus only revealing its hash as\nan output would imply adding an additional 32 bytes to the witness.\nFurthermore, to maintain "),n("a",{attrs:{href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-January/012198.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("128-bit collision\nsecurity"),n("OutboundLink")],1),e._v("\nfor outputs, a 256-bit hash would be required anyway, which is\ncomparable in size (and thus in cost for senders) to revealing the\npublic key directly. While the usage of public key hashes is often\nsaid to protect against ECDLP breaks or quantum computers, this\nprotection is very weak at best: transactions are not protected\nwhile being confirmed, and a very "),n("a",{attrs:{href:"https://twitter.com/pwuille/status/1108097835365339136",target:"_blank",rel:"noopener noreferrer"}},[e._v("large\nportion"),n("OutboundLink")],1),e._v(" of\nthe currency's supply is not under such protection regardless.\nActual resistance to such systems can be introduced by relying on\ndifferent cryptographic assumptions, but this proposal focuses on\nimprovements that do not change the security model.")]),e._v(" "),n("p",[e._v("[^3]: "),n("strong",[e._v("Why is P2SH-wrapping not supported?")]),e._v(" Using P2SH-wrapped outputs\nonly provides 80-bit collision security due to the use of a 160-bit\nhash. This is considered low, and becomes a security risk whenever\nthe output includes data from more than a single party (public keys,\nhashes, ...).")]),e._v(" "),n("p",[e._v("[^4]: "),n("strong",[e._v("Why is the first byte of the annex "),n("code",[e._v("0x50")]),e._v("?")]),e._v(" The "),n("code",[e._v("0x50")]),e._v(" is\nchosen as it could not be confused with a valid P2WPKH or P2WSH\nspending. As the control block's initial byte's lowest bit is used\nto indicate the parity of the public key's Y coordinate, each leaf\nversion needs an even byte value and the immediately following odd\nbyte value that are both not yet used in P2WPKH or P2WSH spending.\nTo indicate the annex, only an \"unpaired\" available byte is\nnecessary like "),n("code",[e._v("0x50")]),e._v(". This choice maximizes the available options\nfor future script versions.")]),e._v(" "),n("p",[e._v("[^5]: "),n("strong",[e._v("What is the purpose of the annex?")]),e._v(" The annex is a reserved\nspace for future extensions, such as indicating the validation costs\nof computationally expensive new opcodes in a way that is\nrecognizable without knowing the scriptPubKey of the output being\nspent. Until the meaning of this field is defined by another\nsoftfork, users SHOULD NOT include "),n("code",[e._v("annex")]),e._v(" in transactions, or it\nmay lead to PERMANENT FUND LOSS.")]),e._v(" "),n("p",[e._v("[^6]: "),n("strong",[e._v("Why is the Merkle path length limited to 128?")]),e._v(" The optimally\nspace-efficient Merkle tree can be constructed based on the\nprobabilities of the scripts in the leaves, using the Huffman\nalgorithm. This algorithm will construct branches with lengths\napproximately equal to "),n("em",[e._v("log~2~(1/probability)")]),e._v(", but to have branches\nlonger than 128 you would need to have scripts with an execution\nchance below 1 in "),n("em",[e._v("2^128^")]),e._v(". As that is our security bound, scripts\nthat truly have such a low chance can probably be removed entirely.")]),e._v(" "),n("p",[e._v("[^7]: "),n("strong",[e._v("What constraints are there on the leaf version?")]),e._v(" First, the\nleaf version cannot be odd as "),n("em",[e._v("c[0] & 0xfe")]),e._v(" will always be even,\nand cannot be "),n("em",[e._v("0x50")]),e._v(" as that would result in ambiguity with the\nannex. In addition, in order to support some forms of static\nanalysis that rely on being able to identify script spends without\naccess to the output being spent, it is recommended to avoid using\nany leaf versions that would conflict with a valid first byte of\neither a valid P2WPKH pubkey or a valid P2WSH script (that is, both\n"),n("em",[e._v("v")]),e._v(" and "),n("em",[e._v("v | 1")]),e._v(" should be an undefined, invalid or disabled opcode\nor an opcode that is not valid as the first opcode). The values that\ncomply to this rule are the 32 even values between "),n("em",[e._v("0xc0")]),e._v(" and "),n("em",[e._v("0xfe")]),e._v("\nand also "),n("em",[e._v("0x66")]),e._v(", "),n("em",[e._v("0x7e")]),e._v(", "),n("em",[e._v("0x80")]),e._v(", "),n("em",[e._v("0x84")]),e._v(", "),n("em",[e._v("0x96")]),e._v(", "),n("em",[e._v("0x98")]),e._v(", "),n("em",[e._v("0xba")]),e._v(",\n"),n("em",[e._v("0xbc")]),e._v(", "),n("em",[e._v("0xbe")]),e._v(". Note also that this constraint implies that leaf\nversions should be shared amongst different witness versions, as\nknowing the witness version requires access to the output being\nspent.")]),e._v(" "),n("p",[e._v("[^8]: "),n("strong",[e._v("Why are child elements sorted before hashing in the Merkle\ntree?")]),e._v(" By doing so, it is not necessary to reveal the left/right\ndirections along with the hashes in revealed Merkle branches. This\nis possible because we do not actually care about the position of\nspecific scripts in the tree; only that they are actually committed\nto.")]),e._v(" "),n("p",[e._v("[^9]: "),n("strong",[e._v("Why not use a more efficient hash construction for inner Merkle\nnodes?")]),e._v(" The chosen construction does require two invocations of the\nSHA256 compression functions, one of which can be avoided in theory\n(see "),n("a",{attrs:{href:"bip-0098.mediawiki",title:"wikilink"}},[e._v("BIP98")]),e._v("). However, it seems\npreferable to stick to constructions that can be implemented using\nstandard cryptographic primitives, both for implementation\nsimplicity and analyzability. If necessary, a significant part of\nthe second compression function can be optimized out by\n"),n("a",{attrs:{href:"https://github.com/bitcoin/bitcoin/pull/13191",target:"_blank",rel:"noopener noreferrer"}},[e._v("specialization"),n("OutboundLink")],1),e._v(" for\n64-byte inputs.")]),e._v(" "),n("p",[e._v("[^10]: "),n("strong",[e._v("Why is it necessary to reveal a bit in a script path spend and\ncheck that it matches the parity of the Y coordinate of "),n("em",[e._v("Q")]),e._v("?")]),e._v(" The\nparity of the Y coordinate is necessary to lift the X coordinate "),n("em",[e._v("q")]),e._v("\nto a unique point. While this is not strictly necessary for\nverifying the taproot commitment as described above, it is necessary\nto allow batch verification. Alternatively, "),n("em",[e._v("Q")]),e._v(" could be forced to\nhave an even Y coordinate, but that would require retrying with\ndifferent internal public keys (or different messages) until "),n("em",[e._v("Q")]),e._v(" has\nthat property. There is no downside to adding the parity bit because\notherwise the control block bit would be unused.")]),e._v(" "),n("p",[e._v("[^11]: "),n("strong",[e._v("What are the applicable script rules in script path spends?")]),e._v(" "),n("a",{attrs:{href:"bip-0342.mediawiki",title:"wikilink"}},[e._v("BIP342")]),e._v(" specifies validity rules\nthat apply for leaf version 0xc0, but future proposals can introduce\nrules for other leaf versions.")]),e._v(" "),n("p",[e._v("[^12]: "),n("strong",[e._v("Why reject unknown "),n("em",[e._v("hash_type")]),e._v(" values?")]),e._v(" By doing so, it is\neasier to reason about the worst case amount of signature hashing an\nimplementation with adequate caching must perform.")]),e._v(" "),n("p",[e._v("[^13]: "),n("strong",[e._v("What extensions use the "),n("em",[e._v("ext_flag")]),e._v(" mechanism?")]),e._v(" "),n("a",{attrs:{href:"bip-0342.mediawiki",title:"wikilink"}},[e._v("BIP342")]),e._v(" reuses the same common\nsignature message algorithm, but adds BIP342-specific data at the\nend, which is indicated using "),n("em",[e._v("ext_flag = 1")]),e._v(".")]),e._v(" "),n("p",[e._v("[^14]: "),n("strong",[e._v("What is the output length of "),n("em",[e._v("SigMsg()")]),e._v("?")]),e._v(" The total length of\n"),n("em",[e._v("SigMsg()")]),e._v(" can be computed using the following formula: "),n("em",[e._v("174 -\nis_anyonecanpay * 49 - is_none * 32 + has_annex * 32")]),e._v(".")]),e._v(" "),n("p",[e._v("[^15]: "),n("strong",[e._v("Why is the serialization in the signature message changed?")]),e._v("\nHashes that go into the signature message and the message itself are\nnow computed with a single SHA256 invocation instead of double\nSHA256. There is no expected security improvement by doubling SHA256\nbecause this only protects against length-extension attacks against\nSHA256 which are not a concern for signature messages because there\nis no secret data. Therefore doubling SHA256 is a waste of\nresources. The message computation now follows a logical order with\ntransaction level data first, then input data and output data. This\nallows to efficiently cache the transaction part of the message\nacross different inputs using the SHA256 midstate. Additionally,\nsub-hashes can be skipped when calculating the message (for example\n`sha_prevouts` if "),n("code",[e._v("SIGHASH_ANYONECANPAY")]),e._v(" is set) instead of\nsetting them to zero and then hashing them as in BIP143. Despite\nthat, collisions are made impossible by committing to the length of\nthe data (implicit in "),n("em",[e._v("hash_type")]),e._v(" and "),n("em",[e._v("spend_type")]),e._v(") before the\nvariable length data.")]),e._v(" "),n("p",[e._v("[^16]: "),n("strong",[e._v("Why does the signature message commit to the "),n("em",[e._v("scriptPubKey")]),e._v("?")]),e._v("\nThis prevents lying to offline signing devices about output being\nspent, even when the actually executed script ("),n("em",[e._v("scriptCode")]),e._v(" in\nBIP143) is correct. This means it's possible to compactly prove to\na hardware wallet what (unused) execution paths existed. Moreover,\ncommitting to all spent "),n("em",[e._v("scriptPubKey")]),e._v("s helps offline signing\ndevices to determine the subset that belong to its own wallet. This\nis useful in "),n("a",{attrs:{href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2020-April/017801.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("automated\ncoinjoins"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("p",[e._v("[^17]: "),n("strong",[e._v("Why does the signature message commit to the amounts of all\ntransaction inputs?")]),e._v(" This eliminates the possibility to lie to\noffline signing devices about the fee of a transaction.")]),e._v(" "),n("p",[e._v("[^18]: "),n("strong",[e._v("Why does the signature message commit to all input "),n("em",[e._v("nSequence")]),e._v("\nif "),n("code",[e._v("SIGHASH_SINGLE")]),e._v(" or "),n("code",[e._v("SIGHASH_NONE")]),e._v(" are set?")]),e._v(" Because setting\nthem already makes the message commit to the "),n("code",[e._v("prevouts")]),e._v(" part of all\ntransaction inputs, it is not useful to treat the "),n("em",[e._v("nSequence")]),e._v(" any\ndifferent. Moreover, this change makes "),n("em",[e._v("nSequence")]),e._v(" consistent with\nthe view that "),n("code",[e._v("SIGHASH_SINGLE")]),e._v(" and "),n("code",[e._v("SIGHASH_NONE")]),e._v(" only modify the\nsignature message with respect to transaction outputs and not\ninputs.")]),e._v(" "),n("p",[e._v("[^19]: "),n("strong",[e._v("Why is the input to "),n("em",[e._v("hash~TapSighash~")]),e._v(" prefixed with 0x00?")]),e._v("\nThis prefix is called the sighash epoch, and allows reusing the\n"),n("em",[e._v("hash~TapSighash~")]),e._v(" tagged hash in future signature algorithms that\nmake invasive changes to how hashing is performed (as opposed to the\n"),n("em",[e._v("ext_flag")]),e._v(" mechanism that is used for incremental extensions). An\nalternative is having them use a different tag, but supporting a\ngrowing number of tags may become undesirable.")]),e._v(" "),n("p",[e._v("[^20]: "),n("strong",[e._v("Why can the "),n("code",[e._v("hash_type")]),e._v(" not be "),n("code",[e._v("0x00")]),e._v(" in 65-byte signatures?")]),e._v("\nPermitting that would enable malleating (by third parties, including\nminers) 64-byte signatures into 65-byte ones, resulting in a\ndifferent `wtxid` and a different fee rate than the creator\nintended")]),e._v(" "),n("p",[e._v("[^21]: "),n("strong",[e._v("Why permit two signature lengths?")]),e._v(" By making the most common\ntype of "),n("code",[e._v("hash_type")]),e._v(" implicit, a byte can often be saved.")])])}),[],!1,null,null,null);t.default=a.exports}}]);