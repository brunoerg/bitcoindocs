(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{423:function(e,t,i){"use strict";i.r(t);var n=i(43),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,i=e._self._c||t;return i("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[i("h1",{attrs:{id:"_141"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_141"}},[e._v("#")]),e._v(" 141")]),e._v(" "),i("div",{staticClass:"language- extra-class"},[i("pre",[i("code",[e._v("  BIP: 141\n  Layer: Consensus (soft fork)\n  Title: Segregated Witness (Consensus layer)\n  Author: Eric Lombrozo <elombrozo@gmail.com>\n          Johnson Lau <jl2012@xbt.hk>\n          Pieter Wuille <pieter.wuille@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0141\n  Status: Final\n  Type: Standards Track\n  Created: 2015-12-21\n  License: PD\n")])])]),i("h2",{attrs:{id:"abstract"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),i("p",[e._v('This BIP defines a new structure called a "witness" that is committed\nto blocks separately from the transaction merkle tree. This structure\ncontains data required to check transaction validity but not required to\ndetermine transaction effects. In particular, scripts and signatures are\nmoved into this new structure.')]),e._v(" "),i("p",[e._v("The witness is committed in a tree that is nested into the block's\nexisting merkle root via the coinbase transaction for the purpose of\nmaking this BIP soft fork compatible. A future hard fork can place this\ntree in its own branch.")]),e._v(" "),i("h2",{attrs:{id:"motivation"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),i("p",[e._v("The entirety of the transaction's effects are determined by output\nconsumption (spends) and new output creation. Other transaction data,\nand signatures in particular, are only required to validate the\nblockchain state, not to determine it.")]),e._v(" "),i("p",[e._v("By removing this data from the transaction structure committed to the\ntransaction merkle tree, several problems are fixed:")]),e._v(" "),i("ol",[i("li",[i("strong",[e._v("Nonintentional malleability becomes impossible")]),e._v(". Since signature\ndata is no longer part of the transaction hash, changes to how the\ntransaction was signed are no longer relevant to transaction\nidentification. As a solution of transaction malleability, this is\nsuperior to the canonical signature approach\n("),i("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0062.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("BIP62"),i("OutboundLink")],1),e._v("):\n"),i("ul",[i("li",[e._v("It prevents involuntary transaction malleability for any type of\nscripts, as long as all inputs are signed (with at least one\nCHECKSIG or CHECKMULTISIG operation)")]),e._v(" "),i("li",[e._v("In the case of an m-of-n CHECKMULTISIG script, a transaction is\nmalleable only with agreement of m private key holders (as\nopposed to only 1 private key holder with BIP62)")]),e._v(" "),i("li",[e._v("It prevents involuntary transaction malleability due to unknown\nECDSA signature malleability")]),e._v(" "),i("li",[e._v("It allows creation of unconfirmed transaction dependency chains\nwithout counterparty risk, an important feature for offchain\nprotocols such as the Lightning Network")])])]),e._v(" "),i("li",[i("strong",[e._v("Transmission of signature data becomes optional")]),e._v(". It is needed\nonly if a peer is trying to validate a transaction instead of just\nchecking its existence. This reduces the size of SPV proofs and\npotentially improves the privacy of SPV clients as they can download\nmore transactions using the same bandwidth.")]),e._v(" "),i("li",[i("strong",[e._v("Some constraints could be bypassed with a soft fork")]),e._v(" by moving\npart of the transaction data to a structure unknown to current\nprotocol, for example:\n"),i("ul",[i("li",[e._v("Size of witness could be ignored / discounted when calculating\nthe block size, effectively increasing the block size to some\nextent")]),e._v(" "),i("li",[e._v("Hard coded constants, such as maximum data push size (520 bytes)\nor sigops limit could be reevaluated or removed")]),e._v(" "),i("li",[e._v("New script system could be introduced without any limitation\nfrom the existing script semantic. For example, a new\ntransaction digest algorithm for transaction signature\nverification is described in\n"),i("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("BIP143"),i("OutboundLink")],1)])])])]),e._v(" "),i("h2",{attrs:{id:"specification"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),i("h3",{attrs:{id:"transaction-id-transaction-id"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#transaction-id-transaction-id"}},[e._v("#")]),e._v(" Transaction ID {#transaction_id}")]),e._v(" "),i("p",[e._v("A new data structure, "),i("code",[e._v("witness")]),e._v(", is defined. Each transaction will have\n2 IDs.")]),e._v(" "),i("p",[e._v("Definition of "),i("code",[e._v("txid")]),e._v(" remains unchanged: the double SHA256 of the\ntraditional serialization format:")]),e._v(" "),i("p",[i("code",[e._v("[nVersion][txins][txouts][nLockTime]")]),i("br"),e._v(" "),i("code")]),e._v(" "),i("p",[e._v("A new "),i("code",[e._v("wtxid")]),e._v(" is defined: the double SHA256 of the new serialization\nwith witness data:")]),e._v(" "),i("p",[i("code",[e._v("[nVersion][marker][flag][txins][txouts][witness][nLockTime]")]),i("br"),e._v(" "),i("code")]),e._v(" "),i("p",[e._v("Format of "),i("code",[e._v("nVersion")]),e._v(", "),i("code",[e._v("txins")]),e._v(", "),i("code",[e._v("txouts")]),e._v(", and "),i("code",[e._v("nLockTime")]),e._v(" are same as\ntraditional serialization.")]),e._v(" "),i("p",[e._v("The "),i("code",[e._v("marker")]),e._v(" MUST be a 1-byte zero value: "),i("code",[e._v("0x00")]),e._v(".")]),e._v(" "),i("p",[e._v("The "),i("code",[e._v("flag")]),e._v(" MUST be a 1-byte non-zero value. Currently, "),i("code",[e._v("0x01")]),e._v(" MUST be\nused.")]),e._v(" "),i("p",[e._v("The "),i("code",[e._v("witness")]),e._v(" is a serialization of all witness data of the transaction.\nEach txin is associated with a witness field. A witness field starts\nwith a "),i("code",[e._v("var_int")]),e._v(" to indicate the number of stack items for the txin. It\nis followed by stack items, with each item starts with a "),i("code",[e._v("var_int")]),e._v(" to\nindicate the length. Witness data is NOT script.")]),e._v(" "),i("p",[e._v("A non-witness program (defined hereinafter) txin MUST be associated with\nan empty witness field, represented by a "),i("code",[e._v("0x00")]),e._v(". If all txins are not\nwitness program, a transaction's "),i("code",[e._v("wtxid")]),e._v(" is equal to its "),i("code",[e._v("txid")]),e._v(".")]),e._v(" "),i("h3",{attrs:{id:"commitment-structure-commitment-structure"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#commitment-structure-commitment-structure"}},[e._v("#")]),e._v(" Commitment structure {#commitment_structure}")]),e._v(" "),i("p",[e._v("A new block rule is added which requires a commitment to the "),i("code",[e._v("wtxid")]),e._v(".\nThe "),i("code",[e._v("wtxid")]),e._v(" of coinbase transaction is assumed to be "),i("code",[e._v("0x0000....0000")]),e._v(".")]),e._v(" "),i("p",[e._v("A "),i("code",[e._v("witness root hash")]),e._v(" is calculated with all those "),i("code",[e._v("wtxid")]),e._v(" as leaves, in\na way similar to the "),i("code",[e._v("hashMerkleRoot")]),e._v(" in the block header.")]),e._v(" "),i("p",[e._v("The commitment is recorded in a "),i("code",[e._v("scriptPubKey")]),e._v(" of the coinbase\ntransaction. It must be at least 38 bytes, with the first 6-byte of\n"),i("code",[e._v("0x6a24aa21a9ed")]),e._v(", that is:")]),e._v(" "),i("p",[i("code",[e._v("1-byte - OP_RETURN (0x6a)")]),i("br"),e._v(" "),i("code",[e._v("1-byte - Push the following 36 bytes (0x24)")]),i("br"),e._v(" "),i("code",[e._v("4-byte - Commitment header (0xaa21a9ed)")]),i("br"),e._v(" "),i("code",[e._v("32-byte - Commitment hash: Double-SHA256(witness root hash|witness reserved value)")]),i("br"),e._v(" "),i("code"),i("br"),e._v(" "),i("code",[e._v("39th byte onwards: Optional data with no consensus meaning")]),i("br"),e._v(" "),i("code")]),e._v(" "),i("p",[e._v("and the coinbase's input's witness must consist of a single 32-byte\narray for the "),i("code",[e._v("witness reserved value")]),e._v(".")]),e._v(" "),i("p",[e._v("If there are more than one "),i("code",[e._v("scriptPubKey")]),e._v(" matching the pattern, the one\nwith highest output index is assumed to be the commitment.")]),e._v(" "),i("p",[e._v("If all transactions in a block do not have witness data, the commitment\nis optional.")]),e._v(" "),i("h3",{attrs:{id:"witness-program-witness-program"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#witness-program-witness-program"}},[e._v("#")]),e._v(" Witness program {#witness_program}")]),e._v(" "),i("p",[e._v("A "),i("code",[e._v("scriptPubKey")]),e._v(" (or "),i("code",[e._v("redeemScript")]),e._v(' as defined in BIP16/P2SH) that\nconsists of a 1-byte push opcode (for 0 to 16) followed by a data push\nbetween 2 and 40 bytes gets a new special meaning. The value of the\nfirst push is called the "version byte". The following byte vector\npushed is called the "witness program".')]),e._v(" "),i("p",[e._v("There are two cases in which witness validation logic are triggered.\nEach case determines the location of the witness version byte and\nprogram, as well as the form of the scriptSig:")]),e._v(" "),i("ol",[i("li",[e._v("Triggered by a "),i("code",[e._v("scriptPubKey")]),e._v(" that is exactly a push of a version\nbyte, plus a push of a witness program. The scriptSig must be\nexactly empty or validation fails. ("),i("em",[e._v('"native witness program"')]),e._v(")")]),e._v(" "),i("li",[e._v("Triggered when a "),i("code",[e._v("scriptPubKey")]),e._v(" is a P2SH script, and the BIP16\n"),i("code",[e._v("redeemScript")]),e._v(" pushed in the "),i("code",[e._v("scriptSig")]),e._v(" is exactly a push of a\nversion byte plus a push of a witness program. The "),i("code",[e._v("scriptSig")]),e._v(" must\nbe exactly a push of the BIP16 "),i("code",[e._v("redeemScript")]),e._v(" or validation fails.\n("),i("em",[e._v('"P2SH witness program"')]),e._v(")")])]),e._v(" "),i("p",[e._v("If the version byte is 0, and the witness program is 20 bytes:")]),e._v(" "),i("ul",[i("li",[e._v("It is interpreted as a pay-to-witness-public-key-hash (P2WPKH)\nprogram.")]),e._v(" "),i("li",[e._v("The witness must consist of exactly 2 items (≤ 520 bytes each). The\nfirst one a signature, and the second one a public key.")]),e._v(" "),i("li",[e._v("The HASH160 of the public key must match the 20-byte witness\nprogram.")]),e._v(" "),i("li",[e._v("After normal script evaluation, the signature is verified against\nthe public key with CHECKSIG operation. The verification must result\nin a single TRUE on the stack.")])]),e._v(" "),i("p",[e._v("If the version byte is 0, and the witness program is 32 bytes:")]),e._v(" "),i("ul",[i("li",[e._v("It is interpreted as a pay-to-witness-script-hash (P2WSH) program.")]),e._v(" "),i("li",[e._v("The witness must consist of an input stack to feed to the script,\nfollowed by a serialized script ("),i("code",[e._v("witnessScript")]),e._v(").")]),e._v(" "),i("li",[e._v("The "),i("code",[e._v("witnessScript")]),e._v(" (≤ 10,000 bytes) is popped off the initial\nwitness stack. SHA256 of the "),i("code",[e._v("witnessScript")]),e._v(" must match the 32-byte\nwitness program.")]),e._v(" "),i("li",[e._v("The "),i("code",[e._v("witnessScript")]),e._v(" is deserialized, and executed after normal\nscript evaluation with the remaining witness stack (≤ 520 bytes for\neach stack item).")]),e._v(" "),i("li",[e._v("The script must not fail, and result in exactly a single TRUE on the\nstack.")])]),e._v(" "),i("p",[e._v("If the version byte is 0, but the witness program is neither 20 nor 32\nbytes, the script must fail.[^1]")]),e._v(" "),i("p",[e._v("If the version byte is 1 to 16, no further interpretation of the witness\nprogram or witness stack happens, and there is no size restriction for\nthe witness stack. These versions are reserved for future\nextensions.[^2]")]),e._v(" "),i("h3",{attrs:{id:"other-consensus-critical-limits-other-consensus-critical-limits"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#other-consensus-critical-limits-other-consensus-critical-limits"}},[e._v("#")]),e._v(" Other consensus critical limits {#other_consensus_critical_limits}")]),e._v(" "),i("h4",{attrs:{id:"block-size-block-size"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#block-size-block-size"}},[e._v("#")]),e._v(" Block size {#block_size}")]),e._v(" "),i("p",[e._v("Blocks are currently limited to 1,000,000 bytes (1MB) total size. We\nchange this restriction as follows:")]),e._v(" "),i("p",[i("em",[e._v("Block weight")]),e._v(" is defined as "),i("em",[e._v("Base size")]),e._v(" * 3 + "),i("em",[e._v("Total size")]),e._v(".\n(rationale[^3])")]),e._v(" "),i("p",[i("em",[e._v("Base size")]),e._v(" is the block size in bytes with the original transaction\nserialization without any witness-related data, as seen by a\nnon-upgraded node.")]),e._v(" "),i("p",[i("em",[e._v("Total size")]),e._v(" is the block size in bytes with transactions serialized as\ndescribed in "),i("a",{attrs:{href:"bip-0144.mediawiki",title:"wikilink"}},[e._v("BIP144")]),e._v(", including base\ndata and witness data.")]),e._v(" "),i("p",[e._v("The new rule is "),i("em",[e._v("block weight")]),e._v(" ≤ 4,000,000.")]),e._v(" "),i("h4",{attrs:{id:"sigops"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#sigops"}},[e._v("#")]),e._v(" Sigops")]),e._v(" "),i("p",[e._v("Sigops per block is currently limited to 20,000. We change this\nrestriction as follows:")]),e._v(" "),i("p",[e._v("Sigops in the current pubkey script, signature script, and P2SH check\nscript are counted at 4 times their previous value. The sigop limit is\nlikewise quadrupled to ≤ 80,000.")]),e._v(" "),i("p",[e._v("Each P2WPKH input is counted as 1 sigop. In addition, opcodes within a\nP2WSH "),i("code",[e._v("witnessScript")]),e._v(" are counted identically as previously within the\nP2SH "),i("code",[e._v("redeemScript")]),e._v(". That is, CHECKSIG is counted as only 1 sigop, and\nCHECKMULTISIG is counted as 1 to 20 sigops according to the arguments.\nThis rule applies to both native witness program and P2SH witness\nprogram.")]),e._v(" "),i("h3",{attrs:{id:"additional-definitions-additional-definitions"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#additional-definitions-additional-definitions"}},[e._v("#")]),e._v(" Additional definitions {#additional_definitions}")]),e._v(" "),i("p",[e._v("The following definitions are not used for consensus limits, but are\nsuggested to provide language consistent with the terminology introduced\nabove.")]),e._v(" "),i("h4",{attrs:{id:"transaction-size-calculations-transaction-size-calculations"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#transaction-size-calculations-transaction-size-calculations"}},[e._v("#")]),e._v(" Transaction size calculations {#transaction_size_calculations}")]),e._v(" "),i("p",[i("em",[e._v("Transaction weight")]),e._v(" is defined as "),i("em",[e._v("Base transaction size")]),e._v(" * 3 + "),i("em",[e._v("Total\ntransaction size")]),e._v(" (ie. the same method as calculating "),i("em",[e._v("Block weight")]),e._v("\nfrom "),i("em",[e._v("Base size")]),e._v(" and "),i("em",[e._v("Total size")]),e._v(").")]),e._v(" "),i("p",[i("em",[e._v("Virtual transaction size")]),e._v(" is defined as "),i("em",[e._v("Transaction weight")]),e._v(" / 4\n(rounded up to the next integer).")]),e._v(" "),i("p",[i("em",[e._v("Base transaction size")]),e._v(" is the size of the transaction serialised with\nthe witness data stripped.")]),e._v(" "),i("p",[i("em",[e._v("Total transaction size")]),e._v(" is the transaction size in bytes serialized as\ndescribed in "),i("a",{attrs:{href:"bip-0144.mediawiki",title:"wikilink"}},[e._v("BIP144")]),e._v(", including base\ndata and witness data.")]),e._v(" "),i("h3",{attrs:{id:"new-script-semantics-new-script-semantics"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#new-script-semantics-new-script-semantics"}},[e._v("#")]),e._v(" New script semantics {#new_script_semantics}")]),e._v(" "),i("p",[e._v("Despite that the script language for P2WPKH and P2WSH looks very similar\nto pre-segregated witness script, there are several notable differences.\nUsers MUST NOT assume that a script spendable in pre-segregated witness\nsystem would also be spendable as a P2WPKH or P2WSH script. Before\nlarge-scale deployment in the production network, developers should test\nthe scripts on testnet with the default relay policy turned on, and with\na small amount of money after BIP141 is activated on mainnet.")]),e._v(" "),i("p",[e._v("A major difference at consensus level is described in\n"),i("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("BIP143"),i("OutboundLink")],1),e._v(",\nas a new transaction digest algorithm for signature verification in\nversion 0 witness program.")]),e._v(" "),i("p",[e._v("Three relay and mining policies are also included in the first release\nof segregated witness at reference implementation version 0.13.1.\nSoftforks based on these policies are likely to be proposed in the near\nfuture. To avoid indefinite delay in transaction confirmation and\npermanent fund loss in a potential softfork, users MUST observe the new\nsemantics carefully:")]),e._v(" "),i("ol",[i("li",[e._v("Only compressed public keys are accepted in P2WPKH and P2WSH (See\n"),i("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0143.mediawiki#Restrictions_on_public_key_type",target:"_blank",rel:"noopener noreferrer"}},[e._v("BIP143"),i("OutboundLink")],1),e._v(")")]),e._v(" "),i("li",[e._v("The argument of OP_IF/NOTIF in P2WSH must be minimal"),i("a",{attrs:{href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-August/013014.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("^4"),i("OutboundLink")],1)]),e._v(" "),i("li",[e._v("Signature(s) must be null vector(s) if an OP_CHECKSIG or\nOP_CHECKMULTISIG is failed (for both pre-segregated witness script\nand P2WSH. See\n"),i("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0146.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("BIP146"),i("OutboundLink")],1),e._v(")")])]),e._v(" "),i("h2",{attrs:{id:"examples"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[e._v("#")]),e._v(" Examples")]),e._v(" "),i("h3",{attrs:{id:"p2wpkh"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#p2wpkh"}},[e._v("#")]),e._v(" P2WPKH")]),e._v(" "),i("p",[e._v("The following example is a version 0 pay-to-witness-public-key-hash\n(P2WPKH):")]),e._v(" "),i("p",[i("code",[e._v("witness:       <signature>")]),e._v(" "),i("code",[e._v("<pubkey>")]),e._v(" "),i("br"),e._v(" "),i("code",[e._v("scriptSig:    (empty)")]),i("br"),e._v(" "),i("code",[e._v("scriptPubKey: 0 <20-byte-key-hash>")]),i("br"),e._v(" "),i("code",[e._v("(0x0014{20-byte-key-hash})")])]),e._v(" "),i("p",[e._v("The '0' in scriptPubKey indicates the following push is a version 0\nwitness program. The length of the witness program indicates that it is\na P2WPKH type. The witness must consist of exactly 2 items. The HASH160\nof the pubkey in witness must match the witness program.")]),e._v(" "),i("p",[e._v("The signature is verified as")]),e._v(" "),i("p",[i("code",[e._v("<signature>")]),e._v(" "),i("code",[e._v("<pubkey>")]),e._v(" "),i("code",[e._v("CHECKSIG")])]),e._v(" "),i("p",[e._v("Comparing with a traditional P2PKH output, the P2WPKH equivalent\noccupies 3 less bytes in the scriptPubKey, and moves the signature and\npublic key from scriptSig to witness.")]),e._v(" "),i("h3",{attrs:{id:"p2wpkh-nested-in-bip16-p2sh-p2wpkh-nested-in-bip16-p2sh"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#p2wpkh-nested-in-bip16-p2sh-p2wpkh-nested-in-bip16-p2sh"}},[e._v("#")]),e._v(" P2WPKH nested in BIP16 P2SH {#p2wpkh_nested_in_bip16_p2sh}")]),e._v(" "),i("p",[e._v("The following example is the same P2WPKH, but nested in a BIP16 P2SH\noutput.")]),e._v(" "),i("p",[i("code",[e._v("witness:       <signature>")]),e._v(" "),i("code",[e._v("<pubkey>")]),e._v(" "),i("br"),e._v(" "),i("code",[e._v("scriptSig:    <0 <20-byte-key-hash>>")]),i("br"),e._v(" "),i("code",[e._v("(0x160014{20-byte-key-hash})")]),i("br"),e._v(" "),i("code",[e._v("scriptPubKey: HASH160 <20-byte-script-hash> EQUAL")]),i("br"),e._v(" "),i("code",[e._v("(0xA914{20-byte-script-hash}87)")])]),e._v(" "),i("p",[e._v("The only item in scriptSig is hashed with HASH160, compared against the\n20-byte-script-hash in scriptPubKey, and interpreted as:")]),e._v(" "),i("p",[i("code",[e._v("0 <20-byte-key-hash>")])]),e._v(" "),i("p",[e._v("The public key and signature are then verified as described in the\nprevious example.")]),e._v(" "),i("p",[e._v("Comparing with the previous example, the scriptPubKey is 1 byte bigger\nand the scriptSig is 23 bytes bigger. Although a nested witness program\nis less efficient, its payment address is fully transparent and backward\ncompatible for all Bitcoin reference client since version 0.6.0.")]),e._v(" "),i("h3",{attrs:{id:"p2wsh"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#p2wsh"}},[e._v("#")]),e._v(" P2WSH")]),e._v(" "),i("p",[e._v("The following example is an 1-of-2 multi-signature version 0\npay-to-witness-script-hash (P2WSH).")]),e._v(" "),i("p",[i("code",[e._v("witness:      0  <signature1>")]),e._v(" "),i("code",[e._v("<1  <pubkey1>")]),e._v(" "),i("code",[e._v("<pubkey2>")]),e._v(" "),i("code",[e._v("2 CHECKMULTISIG>")]),i("br"),e._v(" "),i("code",[e._v("scriptSig:    (empty)")]),i("br"),e._v(" "),i("code",[e._v("scriptPubKey: 0 <32-byte-hash>")]),i("br"),e._v(" "),i("code",[e._v("(0x0020{32-byte-hash})")])]),e._v(" "),i("p",[e._v("The '0' in scriptPubKey indicates the following push is a version 0\nwitness program. The length of the witness program indicates that it is\na P2WSH type. The last item in the witness (the \"witnessScript\") is\npopped off, hashed with SHA256, compared against the 32-byte-hash in\nscriptPubKey, and deserialized:")]),e._v(" "),i("p",[i("code",[e._v("1  <pubkey1>")]),e._v(" "),i("code",[e._v("<pubkey2>")]),e._v(" "),i("code",[e._v("2 CHECKMULTISIG")])]),e._v(" "),i("p",[e._v("The script is executed with the remaining data from witness:")]),e._v(" "),i("p",[i("code",[e._v("0  <signature1>")]),e._v(" "),i("code",[e._v("1  <pubkey1>")]),e._v(" "),i("code",[e._v("<pubkey2>")]),e._v(" "),i("code",[e._v("2 CHECKMULTISIG")])]),e._v(" "),i("p",[e._v("P2WSH allows maximum script size of 10,000 bytes, as the 520-byte push\nlimit is bypassed.")]),e._v(" "),i("p",[e._v("The scriptPubKey occupies 34 bytes, as opposed to 23 bytes of BIP16\nP2SH. The increased size improves security against possible collision\nattacks, as 2^80^ work is not infeasible anymore (By the end of 2015,\n2^84^ hashes have been calculated in Bitcoin mining since the creation\nof Bitcoin). The spending script is same as the one for an equivalent\nBIP16 P2SH output but is moved to witness.")]),e._v(" "),i("h3",{attrs:{id:"p2wsh-nested-in-bip16-p2sh-p2wsh-nested-in-bip16-p2sh"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#p2wsh-nested-in-bip16-p2sh-p2wsh-nested-in-bip16-p2sh"}},[e._v("#")]),e._v(" P2WSH nested in BIP16 P2SH {#p2wsh_nested_in_bip16_p2sh}")]),e._v(" "),i("p",[e._v("The following example is the same 1-of-2 multi-signature P2WSH script,\nbut nested in a BIP16 P2SH output.")]),e._v(" "),i("p",[i("code",[e._v("witness:      0  <signature1>")]),e._v(" "),i("code",[e._v("<1  <pubkey1>")]),e._v(" "),i("code",[e._v("<pubkey2>")]),e._v(" "),i("code",[e._v("2 CHECKMULTISIG>")]),i("br"),e._v(" "),i("code",[e._v("scriptSig:    <0 <32-byte-hash>>")]),i("br"),e._v(" "),i("code",[e._v("(0x220020{32-byte-hash})")]),i("br"),e._v(" "),i("code",[e._v("scriptPubKey: HASH160 <20-byte-hash> EQUAL")]),i("br"),e._v(" "),i("code",[e._v("(0xA914{20-byte-hash}87)")])]),e._v(" "),i("p",[e._v("The only item in scriptSig is hashed with HASH160, compared against the\n20-byte-hash in scriptPubKey, and interpreted as:")]),e._v(" "),i("p",[i("code",[e._v("0 <32-byte-hash>")])]),e._v(" "),i("p",[e._v("The P2WSH witnessScript is then executed as described in the previous\nexample.")]),e._v(" "),i("p",[e._v("Comparing with the previous example, the scriptPubKey is 11 bytes\nsmaller (with reduced security) while witness is the same. However, it\nalso requires 35 bytes in scriptSig.")]),e._v(" "),i("h3",{attrs:{id:"extensible-commitment-structure-extensible-commitment-structure"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#extensible-commitment-structure-extensible-commitment-structure"}},[e._v("#")]),e._v(" Extensible commitment structure {#extensible_commitment_structure}")]),e._v(" "),i("p",[e._v("The new commitment in coinbase transaction is a hash of the\n"),i("code",[e._v("witness root hash")]),e._v(" and a "),i("code",[e._v("witness reserved value")]),e._v(". The\n"),i("code",[e._v("witness reserved value")]),e._v(" currently has no consensus meaning, but in the\nfuture allows new commitment values for future softforks. For example,\nif a new consensus-critical commitment is required in the future, the\ncommitment in coinbase becomes:")]),e._v(" "),i("p",[i("code",[e._v("Double-SHA256(Witness root hash|Hash(new commitment|witness reserved value))")])]),e._v(" "),i("p",[e._v("For backward compatibility, the\n"),i("code",[e._v("Hash(new commitment|witness reserved value)")]),e._v(" will go to the coinbase\nwitness, and the "),i("code",[e._v("witness reserved value")]),e._v(" will be recorded in another\nlocation specified by the future softfork. Any number of new commitment\ncould be added in this way.")]),e._v(" "),i("p",[e._v("Any commitments that are not consensus-critical to Bitcoin, such as\nmerge-mining, MUST NOT use the "),i("code",[e._v("witness reserved value")]),e._v(" to preserve the\nability to do upgrades of the Bitcoin consensus protocol.")]),e._v(" "),i("p",[e._v("The optional data space following the commitment also leaves room for\nmetadata of future softforks, and MUST NOT be used for other purpose.")]),e._v(" "),i("h3",{attrs:{id:"trust-free-unconfirmed-transaction-dependency-chain-trust-free-unconfirmed-transaction-dependency-chain"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#trust-free-unconfirmed-transaction-dependency-chain-trust-free-unconfirmed-transaction-dependency-chain"}},[e._v("#")]),e._v(" Trust-free unconfirmed transaction dependency chain {#trust_free_unconfirmed_transaction_dependency_chain}")]),e._v(" "),i("p",[e._v("Segregated witness fixes the problem of transaction malleability\nfundamentally, which enables the building of unconfirmed transaction\ndependency chains in a trust-free manner.")]),e._v(" "),i("p",[e._v('Two parties, Alice and Bob, may agree to send certain amount of Bitcoin\nto a 2-of-2 multisig output (the "funding transaction"). Without\nsigning the funding transaction, they may create another transaction,\ntime-locked in the future, spending the 2-of-2 multisig output to third\naccount(s) (the "spending transaction"). Alice and Bob will sign the\nspending transaction and exchange the signatures. After examining the\nsignatures, they will sign and commit the funding transaction to the\nblockchain. Without further action, the spending transaction will be\nconfirmed after the lock-time and release the funding according to the\noriginal contract. It also retains the flexibility of revoking the\noriginal contract before the lock-time, by another spending transaction\nwith shorter lock-time, but only with mutual-agreement of both parties.')]),e._v(" "),i("p",[e._v("Such setups are not possible with BIP62 as the malleability fix, since\nthe spending transaction could not be created without both parties first\nsigning the funding transaction. If Alice reveals the funding\ntransaction signature before Bob does, Bob is able to lock up the\nfunding indefinitely without ever signing the spending transaction.")]),e._v(" "),i("p",[e._v("Unconfirmed transaction dependency chain is a fundamental building block\nof more sophisticated payment networks, such as duplex micropayment\nchannel and the Lightning Network, which have the potential to greatly\nimprove the scalability and efficiency of the Bitcoin system.")]),e._v(" "),i("h2",{attrs:{id:"future-extensions-future-extensions"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#future-extensions-future-extensions"}},[e._v("#")]),e._v(" Future extensions {#future_extensions}")]),e._v(" "),i("h3",{attrs:{id:"compact-fraud-proof-for-spv-nodes-compact-fraud-proof-for-spv-nodes"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#compact-fraud-proof-for-spv-nodes-compact-fraud-proof-for-spv-nodes"}},[e._v("#")]),e._v(" Compact fraud proof for SPV nodes {#compact_fraud_proof_for_spv_nodes}")]),e._v(" "),i("p",[e._v("Bitcoin right now only has two real security models. A user either runs\na full-node which validates every block with all rules in the system, or\na SPV (Simple Payment Verification) client which only validates the\nheaders as a proof of publication of some transactions. The Bitcoin\nwhitepaper suggested that SPV nodes may accept alerts from full nodes\nwhen they detect an invalid block, prompting the SPV node to download\nthe questioned blocks and transactions for validation. This approach,\nhowever, could become a DoS attack vector as there is virtually no cost\nto generate a false alarm. An alarm must come with a compact, yet\ndeterministic fraud proof.")]),e._v(" "),i("p",[e._v("In the current Bitcoin protocol, it is possible to generate compact\nfraud proof for almost all rules except a few:")]),e._v(" "),i("ol",[i("li",[e._v("It is not possible to prove a miner has introduced too many Bitcoins\nin the coinbase transaction outputs without showing the whole block\nitself and all input transactions.")]),e._v(" "),i("li",[e._v("It is not possible to prove the violation of any block specific\nconstraints, such as size and sigop limits, without showing the\nwhole block (and all input transactions in the case of sigop limit)")]),e._v(" "),i("li",[e._v("It is not possible to prove the spending of a non-existing input\nwithout showing all transaction IDs in the blockchain way back to\nthe genesis block.")])]),e._v(" "),i("p",[e._v("Extra witness data can be committed that allows short proofs of block\ninvalidity that SPV nodes can quickly verify:")]),e._v(" "),i("ol",[i("li",[e._v("Sum trees for transaction fee can be committed making it possible to\nconstruct short proofs that the miner does not add excessive fees to\nthe coinbase transaction. Similar for the block size and sigop count\nlimit.")]),e._v(" "),i("li",[e._v("Backlinks for the outputs spent by the transaction's inputs can be\nprovided. These backlinks consist of a block hash and an offset that\nthin clients can easily query and check to verify that the outputs\nexist.")])]),e._v(" "),i("p",[e._v("These commitments could be included in the extensible commitment\nstructure through a soft fork and will be transparent to nodes that do\nnot understand such new rules.")]),e._v(" "),i("h3",{attrs:{id:"new-script-system-new-script-system"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#new-script-system-new-script-system"}},[e._v("#")]),e._v(" New script system {#new_script_system}")]),e._v(" "),i("p",[e._v("Since a version byte is pushed before a witness program, and programs\nwith unknown versions are always considered as anyone-can-spend script,\nit is possible to introduce any new script system with a soft fork. The\nwitness as a structure is not restricted by any existing script\nsemantics and constraints, the 520-byte push limit in particular, and\ntherefore allows arbitrarily large scripts and signatures.")]),e._v(" "),i("p",[e._v("Examples of new script system include Schnorr signatures which reduce\nthe size of multisig transactions dramatically, Lamport signature which\nis quantum computing resistance, and Merklized abstract syntax trees\nwhich allow very compact witness for conditional scripts with extreme\ncomplexity.")]),e._v(" "),i("h3",{attrs:{id:"per-input-lock-time-and-relative-lock-time-per-input-lock-time-and-relative-lock-time"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#per-input-lock-time-and-relative-lock-time-per-input-lock-time-and-relative-lock-time"}},[e._v("#")]),e._v(" Per-input lock-time and relative-lock-time {#per_input_lock_time_and_relative_lock_time}")]),e._v(" "),i("p",[e._v("Currently there is only one nLockTime field in a transaction and all\ninputs must share the same value.\n"),i("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0068.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("BIP68"),i("OutboundLink")],1),e._v("\nenables per-input relative-lock-time using the nSequence field, however,\nwith a limited lock-time period and resolution.")]),e._v(" "),i("p",[e._v("With a soft fork, it is possible to introduce a separate witness\nstructure to allow per-input lock-time and relative-lock-time, and a new\nscript system that could sign and manipulate the new data (like\n"),i("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0065.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("BIP65"),i("OutboundLink")],1),e._v("\nand\n"),i("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0112.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("BIP112"),i("OutboundLink")],1),e._v(").")]),e._v(" "),i("h2",{attrs:{id:"backward-compatibility-backward-compatibility"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#backward-compatibility-backward-compatibility"}},[e._v("#")]),e._v(" Backward compatibility {#backward_compatibility}")]),e._v(" "),i("p",[e._v("As a soft fork, older software will continue to operate without\nmodification. Non-upgraded nodes, however, will not see nor validate the\nwitness data and will consider all witness programs as anyone-can-spend\nscripts (except a few edge cases where the witness programs are equal to\n0, which the script must fail). Wallets should always be wary of\nanyone-can-spend scripts and treat them with suspicion. Non-upgraded\nnodes are strongly encouraged to upgrade in order to take advantage of\nthe new features.")]),e._v(" "),i("p",[i("strong",[e._v("What a non-upgraded wallet can do")])]),e._v(" "),i("ul",[i("li",[e._v("Receiving bitcoin from non-upgraded and upgraded wallets")]),e._v(" "),i("li",[e._v("Sending bitcoin to non-upgraded and upgraded wallets with\ntraditional P2PKH address (without any benefit of segregated\nwitness)")]),e._v(" "),i("li",[e._v("Sending bitcoin to upgraded wallets using a P2SH address")]),e._v(" "),i("li",[e._v("Sending bitcoin to upgraded wallets using a native witness program\nthrough\n"),i("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0070.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("BIP70"),i("OutboundLink")],1),e._v("\npayment protocol")])]),e._v(" "),i("p",[i("strong",[e._v("What a non-upgraded wallet cannot do")])]),e._v(" "),i("ul",[i("li",[e._v("Validating segregated witness transaction. It assumes such a\ntransaction is always valid")])]),e._v(" "),i("h2",{attrs:{id:"deployment"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#deployment"}},[e._v("#")]),e._v(" Deployment")]),e._v(" "),i("p",[e._v('This BIP will be deployed by "version bits" BIP9 with the name\n"segwit" and using bit 1.')]),e._v(" "),i("p",[e._v("For Bitcoin mainnet, the BIP9 starttime will be midnight 15 november\n2016 UTC (Epoch timestamp 1479168000) and BIP9 timeout will be midnight\n15 november 2017 UTC (Epoch timestamp 1510704000).")]),e._v(" "),i("p",[e._v("For Bitcoin testnet, the BIP9 starttime will be midnight 1 May 2016 UTC\n(Epoch timestamp 1462060800) and BIP9 timeout will be midnight 1 May\n2017 UTC (Epoch timestamp 1493596800).")]),e._v(" "),i("h2",{attrs:{id:"credits"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#credits"}},[e._v("#")]),e._v(" Credits")]),e._v(" "),i("p",[e._v("Special thanks to Gregory Maxwell for originating many of the ideas in\nthis BIP and Luke-Jr for figuring out how to deploy this as a soft fork.")]),e._v(" "),i("h2",{attrs:{id:"footnotes"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#footnotes"}},[e._v("#")]),e._v(" Footnotes")]),e._v(" "),i("div",{staticClass:"language- line-numbers-mode"},[i("pre",{pre:!0,attrs:{class:"language-text"}},[i("code",[e._v("<references />\n")])]),e._v(" "),i("div",{staticClass:"line-numbers-wrapper"},[i("span",{staticClass:"line-number"},[e._v("1")]),i("br")])]),i("h2",{attrs:{id:"reference-implementation-reference-implementation"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#reference-implementation-reference-implementation"}},[e._v("#")]),e._v(" Reference Implementation {#reference_implementation}")]),e._v(" "),i("p",[i("a",{attrs:{href:"https://github.com/bitcoin/bitcoin/pull/8149",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/bitcoin/bitcoin/pull/8149"),i("OutboundLink")],1)]),e._v(" "),i("h2",{attrs:{id:"references"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),i("ul",[i("li",[i("a",{attrs:{href:"bip-0016.mediawiki",title:"wikilink"}},[e._v("BIP16 Pay to Script Hash")])]),e._v(" "),i("li",[i("a",{attrs:{href:"bip-0143.mediawiki",title:"wikilink"}},[e._v("BIP143 Transaction Signature Verification for Version 0 Witness\nProgram")])]),e._v(" "),i("li",[i("a",{attrs:{href:"bip-0144.mediawiki",title:"wikilink"}},[e._v("BIP144 Segregated Witness (Peer\nServices)")])]),e._v(" "),i("li",[i("a",{attrs:{href:"bip-0173.mediawiki",title:"wikilink"}},[e._v("BIP173 Base32 address format for native v0-16 witness\noutputs")])])]),e._v(" "),i("h2",{attrs:{id:"copyright"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),i("p",[e._v("This document is placed in the public domain.")]),e._v(" "),i("p",[e._v("[^1]: For example, a scriptPubKey with OP_0 followed by a 40-byte\nnon-zero data push will fail due to incorrect program size. However,\na scriptPubKey with OP_0 followed by a 41-byte non-zero data push\nwill pass, since it is not considered to be a witness program")]),e._v(" "),i("p",[e._v("[^2]: For backward compatibility, for any version byte from 0 to 16, the\nscript must fail if the witness program has a "),i("code",[e._v("CastToBool")]),e._v(" value of\nzero. However, having a hash like this is a successful preimage\nattack against the hash function, and the risk is negligible.")]),e._v(" "),i("p",[e._v("[^3]: Rationale of using a single composite constraint, instead of two\nseparate limits such as 1MB base data and 3MB witness data: Using\ntwo separate limits would make mining and fee estimation nearly\nimpossible. Miners would need to solve a complex non-linear\noptimization problem to find the set of transactions that maximize\nfees given both constraints, and wallets would not be able to know\nwhat to pay as it depends on which of the two conditions is most\nconstrained by the time miners try to produce blocks with their\ntransactions in. Another problem with such an approach is\nfreeloading. Once a set of transactions hit the base data 1MB\nconstraint, up to 3MB extra data could be added to the witness by\njust minimally increasing the fee. The marginal cost for extra\nwitness space effectively becomes zero in that case.")])])}),[],!1,null,null,null);t.default=s.exports}}]);