(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{438:function(e,t,n){"use strict";n.r(t);var i=n(43),a=Object(i.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_157"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_157"}},[e._v("#")]),e._v(" 157")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  BIP: 157\n  Layer: Peer Services\n  Title: Client Side Block Filtering\n  Author: Olaoluwa Osuntokun <laolu32@gmail.com>\n          Alex Akselrod <alex@akselrod.org>\n          Jim Posen <jimpo@coinbase.com>\n  Comments-Summary: None yet\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0157\n  Status: Draft\n  Type: Standards Track\n  Created: 2017-05-24\n  License: CC0-1.0\n")])])]),n("h2",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("This BIP describes a new light client protocol in Bitcoin that improves\nupon currently available options. The standard light client protocol in\nuse today, defined in BIP 37"),n("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0037.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("^1"),n("OutboundLink")],1),e._v(", has known flaws that weaken the\nsecurity and privacy of clients and allow denial-of-service attack\nvectors on full nodes"),n("a",{attrs:{href:"https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-May/012636.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("^2"),n("OutboundLink")],1),e._v(". The new protocol overcomes these issues by\nallowing light clients to obtain compact probabilistic filters of block\ncontent from full nodes and download full blocks if the filter matches\nrelevant data.")]),e._v(" "),n("p",[e._v("New P2P messages empower light clients to securely sync the blockchain\nwithout relying on a trusted source. This BIP also defines a filter\nheader, which serves as a commitment to all filters for previous blocks\nand provides the ability to efficiently detect malicious or faulty peers\nserving invalid filters. The resulting protocol guarantees that light\nclients with at least one honest peer are able to identify the correct\nblock filters.")]),e._v(" "),n("h2",{attrs:{id:"motivation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),n("p",[e._v("Bitcoin light clients allow applications to read relevant transactions\nfrom the blockchain without incurring the full cost of downloading and\nvalidating all data. Such applications seek to simultaneously minimize\nthe trust in peers and the amount of bandwidth, storage space, and\ncomputation required. They achieve this by downloading all block\nheaders, verifying the proofs of work, and following the longest\nproof-of-work chain. Since block headers are a fixed 80-bytes and are\ngenerated every 10 minutes on average, the bandwidth required to sync\nthe block headers is minimal. Light clients then download only the\nblockchain data relevant to them directly from peers and validate\ninclusion in the header chain. Though clients do not check the validity\nof all blocks in the longest proof-of-work chain, they rely on miner\nincentives for security.")]),e._v(" "),n("p",[e._v("BIP 37 is currently the most widely used light client execution mode for\nBitcoin. With BIP 37, a client sends a Bloom filter it wants to watch to\na full node peer, then receives notifications for each new transaction\nor block that matches the filter. The client then requests relevant\ntransactions from the peer along with Merkle proofs of inclusion in the\nblocks containing them, which are verified against the block headers.\nThe Bloom filters match data such as client addresses and unspent\noutputs, and the filter size must be carefully tuned to balance the\nfalse positive rate with the amount of information leaked to peer. It\nhas been shown, however, that most implementations available offer\nvirtually "),n("em",[e._v("zero privacy")]),e._v(" to wallets and other applications"),n("a",{attrs:{href:"https://jonasnick.github.io/blog/2015/02/12/privacy-in-bitcoinj/",target:"_blank",rel:"noopener noreferrer"}},[e._v("^3"),n("OutboundLink")],1),e._v(".\nAdditionally, malicious full nodes serving light clients can omit\ncritical data with little risk of detection, which is unacceptable for\nsome applications (such as Lightning Network clients) that must respond\nto certain on-chain events. Finally, honest nodes servicing BIP 37 light\nclients may incur significant I/O and CPU resource usage due to\nmaliciously crafted Bloom filters, creating a denial-of-service (DoS)\nvector and disincentizing node operators from supporting the\nprotocol"),n("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0111.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("^5"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("p",[e._v("The alternative detailed in this document can be seen as the opposite of\nBIP 37: instead of the client sending a filter to a full node peer, full\nnodes generate deterministic filters on block data that are served to\nthe client. A light client can then download an entire block if the\nfilter matches the data it is watching for. Since filters are\ndeterministic, they only need to be constructed once and stored on disk,\nwhenever a new block is connected to the chain. This keeps the\ncomputation required to serve filters minimal, and eliminates the I/O\nasymmetry that makes BIP 37 enabled nodes vulnerable. Clients also get\nbetter assurance of seeing all relevant transactions because they can\ncheck the validity of filters received from peers more easily than they\ncan check completeness of filtered blocks. Finally, client privacy is\nimproved because blocks can be downloaded from "),n("em",[e._v("any source")]),e._v(", so that no\none peer gets complete information on the data required by a client.\nExtremely privacy conscious light clients may opt to anonymously fetch\nblocks using advanced techniques such a Private Information\nRetrieval"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Private_information_retrieval",target:"_blank",rel:"noopener noreferrer"}},[e._v("^6"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("h2",{attrs:{id:"definitions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#definitions"}},[e._v("#")]),e._v(" Definitions")]),e._v(" "),n("p",[n("code",[e._v("[]byte")]),e._v(" represents a vector of bytes.")]),e._v(" "),n("p",[n("code",[e._v("[N]byte")]),e._v(" represents a fixed-size byte array with length N.")]),e._v(" "),n("p",[n("em",[e._v("CompactSize")]),e._v(" is a compact encoding of unsigned integers used in the\nBitcoin P2P protocol.")]),e._v(" "),n("p",[n("em",[e._v("double-SHA256")]),e._v(" is a hash algorithm defined by two invocations of\nSHA-256: "),n("code",[e._v("double-SHA256(x) = SHA256(SHA256(x))")]),e._v(".")]),e._v(" "),n("p",[e._v('The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL\nNOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and\n"OPTIONAL" in this document are to be interpreted as described in RFC\n2119.')]),e._v(" "),n("h2",{attrs:{id:"specification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),n("h3",{attrs:{id:"filter-types-filter-types"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#filter-types-filter-types"}},[e._v("#")]),e._v(" Filter Types {#filter_types}")]),e._v(" "),n("p",[e._v("For the sake of future extensibility and reducing filter sizes, there\nare multiple "),n("em",[e._v("filter types")]),e._v(" that determine which data is included in a\nblock filter as well as the method of filter construction/querying. In\nthis model, full nodes generate one filter per block per filter type\nsupported.")]),e._v(" "),n("p",[e._v("Each type is identified by a one byte code, and specifies the contents\nand serialization format of the filter. A full node MAY signal support\nfor particular filter types using service bits. The initial filter types\nare defined separately in "),n("a",{attrs:{href:"bip-0158.mediawiki",title:"wikilink"}},[e._v("BIP 158")]),e._v(", and\none service bit is allocated to signal support for them.")]),e._v(" "),n("h3",{attrs:{id:"filter-headers-filter-headers"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#filter-headers-filter-headers"}},[e._v("#")]),e._v(" Filter Headers {#filter_headers}")]),e._v(" "),n("p",[e._v("This proposal draws inspiration from the headers-first mechanism that\nBitcoin nodes use to sync the block chain"),n("a",{attrs:{href:"https://bitcoin.org/en/developer-guide#headers-first",target:"_blank",rel:"noopener noreferrer"}},[e._v("^7"),n("OutboundLink")],1),e._v(". Similar to how block\nheaders have a Merkle commitment to all transaction data in the block,\nwe define filter headers that have commitments to the block filters.\nAlso like block headers, filter headers each have a commitment to the\npreceding one. Before downloading the block filters themselves, a light\nclient can download all filter headers for the current block chain and\nuse them to verify the authenticity of the filters. If the filter header\nchains differ between multiple peers, the client can identify the point\nwhere they diverge, then download the full block and compute the correct\nfilter, thus identifying which peer is faulty.")]),e._v(" "),n("p",[e._v("The canonical hash of a block filter is the double-SHA256 of the\nserialized filter. Filter headers are 32-byte hashes derived for each\nblock filter. They are computed as the double-SHA256 of the\nconcatenation of the filter hash with the previous filter header. The\nprevious filter header used to calculate that of the genesis block is\ndefined to be the 32-byte array of 0's.")]),e._v(" "),n("h3",{attrs:{id:"new-messages-new-messages"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#new-messages-new-messages"}},[e._v("#")]),e._v(" New Messages {#new_messages}")]),e._v(" "),n("h4",{attrs:{id:"getcfilters"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#getcfilters"}},[e._v("#")]),e._v(" getcfilters")]),e._v(" "),n("p",[n("code",[e._v("getcfilters")]),e._v(" is used to request the compact filters of a particular\ntype for a particular range of blocks. The message contains the\nfollowing fields:")]),e._v(" "),n("p",[e._v("Field Name    Data Type    Byte Size   Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("FilterType    byte         1           Filter type for which headers are requested\nStartHeight   uint32       4           The height of the first block in the requested range\nStopHash      [32]byte   32          The hash of the last block in the requested range")]),e._v(" "),n("ol",[n("li",[e._v("Nodes SHOULD NOT send "),n("code",[e._v("getcfilters")]),e._v(" unless the peer has signaled\nsupport for this filter type. Nodes receiving "),n("code",[e._v("getcfilters")]),e._v(" with an\nunsupported filter type SHOULD NOT respond.")]),e._v(" "),n("li",[e._v("StopHash MUST be known to belong to a block accepted by the\nreceiving peer. This is the case if the peer had previously sent a\n"),n("code",[e._v("headers")]),e._v(" or "),n("code",[e._v("inv")]),e._v(" message with that block or any descendents. A\nnode that receives "),n("code",[e._v("getcfilters")]),e._v(" with an unknown StopHash SHOULD NOT\nrespond.")]),e._v(" "),n("li",[e._v("The height of the block with hash StopHash MUST be greater than or\nequal to StartHeight, and the difference MUST be strictly less\nthan 1000.")]),e._v(" "),n("li",[e._v("The receiving node MUST respond to valid requests by sending one\n"),n("code",[e._v("cfilter")]),e._v(" message for each block in the requested range,\nsequentially in order by block height.")])]),e._v(" "),n("h4",{attrs:{id:"cfilter"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cfilter"}},[e._v("#")]),e._v(" cfilter")]),e._v(" "),n("p",[n("code",[e._v("cfilter")]),e._v(" is sent in response to "),n("code",[e._v("getcfilters")]),e._v(", one for each block in\nthe requested range. The message contains the following fields:")]),e._v(" "),n("p",[e._v("Field Name       Data Type     Byte Size        Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("FilterType       byte          1                Byte identifying the type of filter being returned\nBlockHash        [32]byte    32               Block hash of the Bitcoin block for which the filter is being returned\nNumFilterBytes   CompactSize   1-5              A variable length integer representing the size of the filter in the following field\nFilterBytes      []byte      NumFilterBytes   The serialized compact filter for this block")]),e._v(" "),n("ol",[n("li",[e._v("The FilterType SHOULD match the field in the "),n("code",[e._v("getcfilters")]),e._v(" request,\nand BlockHash must correspond to a block that is an ancestor of\nStopHash with height greater than or equal to StartHeight.")])]),e._v(" "),n("h4",{attrs:{id:"getcfheaders"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#getcfheaders"}},[e._v("#")]),e._v(" getcfheaders")]),e._v(" "),n("p",[n("code",[e._v("getcfheaders")]),e._v(" is used to request verifiable filter headers for a range\nof blocks. The message contains the following fields:")]),e._v(" "),n("p",[e._v("Field Name    Data Type    Byte Size   Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("FilterType    byte         1           Filter type for which headers are requested\nStartHeight   uint32       4           The height of the first block in the requested range\nStopHash      [32]byte   32          The hash of the last block in the requested range")]),e._v(" "),n("ol",[n("li",[e._v("Nodes SHOULD NOT send "),n("code",[e._v("getcfheaders")]),e._v(" unless the peer has signaled\nsupport for this filter type. Nodes receiving "),n("code",[e._v("getcfheaders")]),e._v(" with an\nunsupported filter type SHOULD NOT respond.")]),e._v(" "),n("li",[e._v("StopHash MUST be known to belong to a block accepted by the\nreceiving peer. This is the case if the peer had previously sent a\n"),n("code",[e._v("headers")]),e._v(" or "),n("code",[e._v("inv")]),e._v(" message with that block or any descendents. A\nnode that receives "),n("code",[e._v("getcfheaders")]),e._v(" with an unknown StopHash SHOULD\nNOT respond.")]),e._v(" "),n("li",[e._v("The height of the block with hash StopHash MUST be greater than or\nequal to StartHeight, and the difference MUST be strictly less than\n2,000.")])]),e._v(" "),n("h4",{attrs:{id:"cfheaders"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cfheaders"}},[e._v("#")]),e._v(" cfheaders")]),e._v(" "),n("p",[n("code",[e._v("cfheaders")]),e._v(" is sent in response to "),n("code",[e._v("getcfheaders")]),e._v(". Instead of including\nthe filter headers themselves, the response includes one filter header\nand a sequence of filter hashes, from which the headers can be derived.\nThis has the benefit that the client can verify the binding links\nbetween the headers. The message contains the following fields:")]),e._v(" "),n("p",[e._v("Field Name             Data Type        Byte Size                  Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("FilterType             byte             1                          Filter type for which hashes are requested\nStopHash               [32]byte       32                         The hash of the last block in the requested range\nPreviousFilterHeader   [32]byte       32                         The filter header preceding the first block in the requested range\nFilterHashesLength     CompactSize      1-3                        The length of the following vector of filter hashes\nFilterHashes           [][32]byte   FilterHashesLength * 32   The filter hashes for each block in the requested range")]),e._v(" "),n("ol",[n("li",[e._v("The FilterType and StopHash SHOULD match the fields in the\n"),n("code",[e._v("getcfheaders")]),e._v(" request.")]),e._v(" "),n("li",[e._v("FilterHashesLength MUST NOT be greater than 2,000.")]),e._v(" "),n("li",[e._v("FilterHashes MUST have one entry for each block on the chain\nterminating with tip StopHash, starting with the block at height\nStartHeight. The entries MUST be the filter hashes of the given type\nfor each block in that range, in ascending order by height.")]),e._v(" "),n("li",[e._v("PreviousFilterHeader MUST be set to the previous filter header of\nfirst block in the requested range.")])]),e._v(" "),n("h4",{attrs:{id:"getcfcheckpt"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#getcfcheckpt"}},[e._v("#")]),e._v(" getcfcheckpt")]),e._v(" "),n("p",[n("code",[e._v("getcfcheckpt")]),e._v(" is used to request filter headers at evenly spaced\nintervals over a range of blocks. Clients may use filter hashes from\n"),n("code",[e._v("getcfheaders")]),e._v(" to connect these checkpoints, as is described in the\n"),n("a",{attrs:{href:"#client-operation",title:"wikilink"}},[e._v("Client Operation")]),e._v(" section below. The\n"),n("code",[e._v("getcfcheckpt")]),e._v(" message contains the following fields:")]),e._v(" "),n("p",[e._v("Field Name   Data Type    Byte Size   Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("FilterType   byte         1           Filter type for which headers are requested\nStopHash     [32]byte   32          The hash of the last block in the chain that headers are requested for")]),e._v(" "),n("ol",[n("li",[e._v("Nodes SHOULD NOT send "),n("code",[e._v("getcfcheckpt")]),e._v(" unless the peer has signaled\nsupport for this filter type. Nodes receiving "),n("code",[e._v("getcfcheckpt")]),e._v(" with an\nunsupported filter type SHOULD NOT respond.")]),e._v(" "),n("li",[e._v("StopHash MUST be known to belong to a block accepted by the\nreceiving peer. This is the case if the peer had previously sent a\n"),n("code",[e._v("headers")]),e._v(" or "),n("code",[e._v("inv")]),e._v(" message with any descendent blocks. A node that\nreceives "),n("code",[e._v("getcfcheckpt")]),e._v(" with an unknown StopHash SHOULD NOT respond.")])]),e._v(" "),n("h4",{attrs:{id:"cfcheckpt"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#cfcheckpt"}},[e._v("#")]),e._v(" cfcheckpt")]),e._v(" "),n("p",[n("code",[e._v("cfcheckpt")]),e._v(" is sent in response to "),n("code",[e._v("getcfcheckpt")]),e._v(". The filter headers\nincluded are the set of all filter headers on the requested chain where\nthe height is a positive multiple of 1,000. The message contains the\nfollowing fields:")]),e._v(" "),n("p",[e._v("Field Name            Data Type        Byte Size                   Description")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("FilterType            byte             1                           Filter type for which headers are requested\nStopHash              [32]byte       32                          The hash of the last block in the chain that headers are requested for\nFilterHeadersLength   CompactSize      1-3                         The length of the following vector of filter headers\nFilterHeaders         [][32]byte   FilterHeadersLength * 32   The filter headers at intervals of 1,000")]),e._v(" "),n("ol",[n("li",[e._v("The FilterType and StopHash SHOULD match the fields in the\n"),n("code",[e._v("getcfcheckpt")]),e._v(" request.")]),e._v(" "),n("li",[e._v("FilterHeaders MUST have exactly one entry for each block on the\nchain terminating in StopHash, where the block height is a multiple\nof 1,000 greater than 0. The entries MUST be the filter headers of\nthe given type for each such block, in ascending order by height.")])]),e._v(" "),n("h3",{attrs:{id:"node-operation-node-operation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#node-operation-node-operation"}},[e._v("#")]),e._v(" Node Operation {#node_operation}")]),e._v(" "),n("p",[e._v("Full nodes MAY opt to support this BIP and generate filters for any of\nthe specified filter types. Such nodes SHOULD treat the filters as an\nadditional index of the blockchain. For each new block that is connected\nto the main chain, nodes SHOULD generate filters for all supported types\nand persist them. Nodes that are missing filters and are already synced\nwith the blockchain SHOULD reindex the chain upon start-up, constructing\nfilters for each block from genesis to the current tip. They also SHOULD\nkeep every checkpoint header in memory, so that "),n("code",[e._v("getcfcheckpt")]),e._v(" requests\ndo not result in many random-access disk reads.")]),e._v(" "),n("p",[e._v("Nodes SHOULD NOT generate filters dynamically on request, as malicious\npeers may be able to perform DoS attacks by requesting small filters\nderived from large blocks. This would require an asymmetical amount of\nI/O on the node to compute and serve, similar to attacks against BIP 37\nenabled nodes noted in BIP 111.")]),e._v(" "),n("p",[e._v("Nodes MAY prune block data after generating and storing all filters for\na block.")]),e._v(" "),n("h3",{attrs:{id:"client-operation-client-operation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#client-operation-client-operation"}},[e._v("#")]),e._v(" Client Operation {#client_operation}")]),e._v(" "),n("p",[e._v("This section provides recommendations for light clients to download\nfilters with maximal security.")]),e._v(" "),n("p",[e._v("Clients SHOULD first sync the entire block header chain from peers using\nthe standard headers-first syncing mechanism before downloading any\nblock filters or filter headers. Clients configured with trusted\ncheckpoints MAY only sync headers started from the last checkpoint.\nClients SHOULD disconnect any outbound peers whose best chain has\nsignificantly less work than the known longest proof-of-work chain.")]),e._v(" "),n("p",[e._v("Once a client's block headers are in sync, it SHOULD download and\nverify filter headers for all blocks and filter types that it might\nlater download. The client SHOULD send "),n("code",[e._v("getcfheaders")]),e._v(" messages to peers\nand derive and store the filter headers for each block. The client MAY\nfirst fetch headers at evenly spaced intervals of 1,000 by sending\n"),n("code",[e._v("getcfcheckpt")]),e._v(". The header checkpoints allow the client to download\nfilter headers for different intervals from multiple peers in parallel,\nverifying each range of 1,000 headers against the checkpoints.")]),e._v(" "),n("p",[e._v("Unless securely connected to a trusted peer that is serving filter\nheaders, the client SHOULD connect to multiple outbound peers that\nsupport each filter type to mitigate the risk of downloading incorrect\nheaders. If the client receives conflicting filter headers from\ndifferent peers for any block and filter type, it SHOULD interrogate\nthem to determine which is faulty. The client SHOULD use "),n("code",[e._v("getcfheaders")]),e._v("\nand/or "),n("code",[e._v("getcfcheckpt")]),e._v(" to first identify the first filter headers that\nthe peers disagree on. The client then SHOULD download the full block\nfrom any peer and derive the correct filter and filter header. The\nclient SHOULD ban any peers that sent a filter header that does not\nmatch the computed one.")]),e._v(" "),n("p",[e._v("Once the client has downloaded and verified all filter headers needed,\n"),n("em",[e._v("and")]),e._v(" no outbound peers have sent conflicting headers, the client can\ndownload the actual block filters it needs. The client MAY backfill\nfilter headers before the first verified one at this point if it only\ndownloaded them starting at a later point. Clients SHOULD persist the\nverified filter headers for last 100 blocks in the chain (or whatever\nfinality depth is desired), to compare against headers received from new\npeers after restart. They MAY store more filter headers to avoid\nredownloading them if a rescan is later necessary.")]),e._v(" "),n("p",[e._v("Starting from the first block in the desired range, the client now MAY\ndownload the filters. The client SHOULD test that each filter links to\nits corresponding filter header and ban peers that send incorrect\nfilters. The client MAY download multiple filters at once to increase\nthroughput, though it SHOULD test the filters sequentially. The client\nMAY check if a filter is empty before requesting it by checking if the\nfilter header commits to the hash of the empty filter, saving a round\ntrip if that is the case.")]),e._v(" "),n("p",[e._v("Each time a new valid block header is received, the client SHOULD\nrequest the corresponding filter headers from all eligible peers. If two\npeers send conflicting filter headers, the client should interrogate\nthem as described above and ban any peers that send an invalid header.")]),e._v(" "),n("p",[e._v("If a client is fetching full blocks from the P2P network, they SHOULD be\ndownloaded from outbound peers at random to mitigate privacy loss due to\ntransaction intersection analysis. Note that blocks may be downloaded\nfrom peers that do not support this BIP.")]),e._v(" "),n("h2",{attrs:{id:"rationale"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),n("p",[e._v("The filter headers and checkpoints messages are defined to help clients\nidentify the correct filter for a block when connected to peers sending\nconflicting information. An alternative solution is to require Bitcoin\nblocks to include commitments to derived block filters, so light clients\ncan verify authenticity given block headers and some additional witness\ndata. This would require a network-wide change to the Bitcoin consensus\nrules, however, whereas this document proposes a solution purely at the\nP2P layer.")]),e._v(" "),n("p",[e._v("The constant interval of 1,000 blocks between checkpoints was chosen so\nthat, given the current chain height and rate of growth, the size of a\n"),n("code",[e._v("cfcheckpt")]),e._v(" message is not drastically from a "),n("code",[e._v("cfheaders")]),e._v(" between two\ncheckpoints. Also, 1,000 is a nice round number, at least to those of us\nwho think in decimal.")]),e._v(" "),n("h2",{attrs:{id:"compatibility"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#compatibility"}},[e._v("#")]),e._v(" Compatibility")]),e._v(" "),n("p",[e._v("This light client mode is not compatible with current node deployments\nand requires support for the new P2P messages. The node implementation\nof this proposal is not incompatible with the current P2P network rules\n(ie. doesn't affect network topology of full nodes). Light clients may\nadopt protocols based on this as an alternative to the existing BIP 37.\nAdoption of this BIP may result in reduced network support for BIP 37.")]),e._v(" "),n("h2",{attrs:{id:"acknowledgments"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#acknowledgments"}},[e._v("#")]),e._v(" Acknowledgments")]),e._v(" "),n("p",[e._v("We would like to thank bfd (from the bitcoin-dev mailing list) for\nbringing the basis of this BIP to our attention, Joseph Poon for\nsuggesting the filter header chain scheme, and Pedro Martelletto for\nwriting the initial indexing code for "),n("code",[e._v("btcd")]),e._v(".")]),e._v(" "),n("p",[e._v("We would also like to thank Dave Collins, JJ Jeffrey, Eric Lombrozo, and\nMatt Corallo for useful discussions.")]),e._v(" "),n("h2",{attrs:{id:"reference-implementation-reference-implementation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reference-implementation-reference-implementation"}},[e._v("#")]),e._v(" Reference Implementation {#reference_implementation}")]),e._v(" "),n("p",[e._v("Light client: "),n("a",{attrs:{href:"https://github.com/lightninglabs/neutrino",target:"_blank",rel:"noopener noreferrer"}},[e._v("1"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("Full-node indexing: "),n("a",{attrs:{href:"https://github.com/Roasbeef/btcd/tree/segwit-cbf",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/Roasbeef/btcd/tree/segwit-cbf"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("Golomb-Rice Coded sets:\n"),n("a",{attrs:{href:"https://github.com/Roasbeef/btcutil/tree/gcs/gcs",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/Roasbeef/btcutil/tree/gcs/gcs"),n("OutboundLink")],1)]),e._v(" "),n("h2",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("<references/>\n")])]),e._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[e._v("1")]),n("br")])]),n("h2",{attrs:{id:"copyright"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),n("p",[e._v("This document is licensed under the Creative Commons CC0 1.0 Universal\nlicense.")])])}),[],!1,null,null,null);t.default=a.exports}}]);