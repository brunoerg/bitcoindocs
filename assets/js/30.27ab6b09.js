(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{405:function(e,t,n){"use strict";n.r(t);var a=n(43),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_119"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_119"}},[e._v("#")]),e._v(" 119")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  BIP: 119\n  Layer: Consensus (soft fork)\n  Title: CHECKTEMPLATEVERIFY\n  Author: Jeremy Rubin <j@rubin.io>\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0119\n  Status: Draft\n  Type: Standards Track\n  Created: 2020-01-06\n  License: BSD-3-Clause\n")])])]),n("h2",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("This BIP proposes a new opcode, OP_CHECKTEMPLATEVERIFY, to be activated\nas a change to the semantics of OP_NOP4.")]),e._v(" "),n("p",[e._v("The new opcode has applications for transaction congestion control and\npayment channel instantiation, among others, which are described in the\nMotivation section of this BIP.")]),e._v(" "),n("h2",{attrs:{id:"summary"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[e._v("#")]),e._v(" Summary")]),e._v(" "),n("p",[e._v("OP_CHECKTEMPLATEVERIFY uses opcode OP_NOP4 (0xb3) as a soft fork\nupgrade.")]),e._v(" "),n("p",[e._v("OP_CHECKTEMPLATEVERIFY does the following:")]),e._v(" "),n("ul",[n("li",[e._v("There is at least one element on the stack, fail otherwise")]),e._v(" "),n("li",[e._v("The element on the stack is 32 bytes long, NOP otherwise")]),e._v(" "),n("li",[e._v("The StandardTemplateHash of the transaction at the current input\nindex is equal to the element on the stack, fail otherwise")])]),e._v(" "),n("p",[e._v("The StandardTemplateHash commits to the serialized version, locktime,\nscriptSigs hash (if any non-null scriptSigs), number of inputs,\nsequences hash, number of outputs, outputs hash, and currently executing\ninput index.")]),e._v(" "),n("p",[e._v("The recommended standardness rules additionally:")]),e._v(" "),n("ul",[n("li",[e._v("Reject non-32 byte as SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS.")])]),e._v(" "),n("h2",{attrs:{id:"motivation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),n("p",[e._v("Covenants are restrictions on how a coin may be spent beyond key\nownership. Covenants can be useful to construct smart contracts. As\ncovenants are complex to implement and risk of introducing fungibility\ndiscriminants they have not been seriously considered for inclusion in\nBitcoin.")]),e._v(" "),n("p",[e._v("This BIP introduces a simple covenant called a *template* which\nenables a limited set of highly valuable use cases without significant\nrisk.")]),e._v(" "),n("p",[e._v("A few examples are described below, which should be the subject of\nfuture non-consensus standardization efforts.")]),e._v(" "),n("h3",{attrs:{id:"congestion-controlled-transactions-congestion-controlled-transactions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#congestion-controlled-transactions-congestion-controlled-transactions"}},[e._v("#")]),e._v(" Congestion Controlled Transactions {#congestion_controlled_transactions}")]),e._v(" "),n("p",[e._v("When there is a high demand for blockspace it becomes very expensive to\nmake transactions. A large volume payment processor may aggregate all\ntheir payments into a single O(1) transaction commitment for purposes of\nconfirmation using CHECKTEMPLATEVERIFY. Then, some time later, the\npayments can be expanded out of that UTXO when the demand for blockspace\nis decreased. These payments can be structured in a tree-like fashion to\nreduce individual costs of redemption.")]),e._v(" "),n("p",[e._v("The below chart showcases the structure of these transactions in\ncomparison to normal transactions and batched transactions.")]),e._v(" "),n("p",[n("code",[e._v('<img src="bip-0119/states.svg" align="middle">')]),e._v(" "),n("code",[e._v("</img>")])]),e._v(" "),n("p",[e._v("A simulation is shown below of what impact this could have on mempool\nbacklog given 5% network adoption, and 50% network adoption. The code\nfor the simulation is provided in this BIP's subdirectory.")]),e._v(" "),n("p",[n("code",[e._v('<img src="bip-0119/five.png" align="middle">')]),e._v(" "),n("code",[e._v("</img>")]),e._v(" "),n("code",[e._v('<img src="bip-0119/fifty.png" align="middle">')]),e._v(" "),n("code",[e._v("</img>")])]),e._v(" "),n("h3",{attrs:{id:"payment-channels-payment-channels"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#payment-channels-payment-channels"}},[e._v("#")]),e._v(" Payment Channels {#payment_channels}")]),e._v(" "),n("p",[e._v("There are numerous payment channel related uses.")]),e._v(" "),n("h4",{attrs:{id:"channel-factories-channel-factories"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#channel-factories-channel-factories"}},[e._v("#")]),e._v(" Channel Factories {#channel_factories}")]),e._v(" "),n("p",[e._v("Using CHECKTEMPLATEVERIFY for Channel Factories is similar to the use\nfor Congestion Control, except the leaf node transactions are channels\ninstead of plain payments. The channel can be between the sender and\nrecipient or a target of recipient's choice. Using an\nCHECKTEMPLATEVERIFY, the recipient may give the sender an address which\nmakes a tree of channels unbeknownst to them. These channels are time\ninsensitive for setup, as all punishments are relative timelocked to the\npenultimate transaction node. Thus, coins sent using a congestion\ncontrolled transaction can still enjoy instant liquidity.")]),e._v(" "),n("h4",{attrs:{id:"non-interactive-channels-non-interactive-channels"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#non-interactive-channels-non-interactive-channels"}},[e._v("#")]),e._v(" Non-Interactive Channels {#non_interactive_channels}")]),e._v(" "),n("p",[e._v('When opening a traditional payment channel, both parties to the channel\nmust participate. This is because the channel uses pre-signed multi-sig\ntransactions to ensure that a channel can always be exited by either\nparty, before entering. With CHECKTEMPLATEVERIFY, it\'s possible for a\nsingle party to construct a channel which either party can exit from\nwithout requiring signatures from both parties. These payment channels\ncan operate in one direction, paying to the channel "listener" without\nneed for their private key to be online.\n'),n("code",[e._v('<img src="bip-0119/nic.svg" align="middle">')]),e._v(" "),n("code",[e._v("</img>")])]),e._v(" "),n("h4",{attrs:{id:"increased-channel-routes-increased-channel-routes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#increased-channel-routes-increased-channel-routes"}},[e._v("#")]),e._v(" Increased Channel Routes {#increased_channel_routes}")]),e._v(" "),n("p",[e._v("In the Lightning Network protocol, Hashed Time Locked Contracts (HTLCS)\nare used in the construction of channels. A new HTLC is required per\nroute that the channel is serving in. In BOLT #2, this maximum number\nof HTLCs in a channel is hard limited to 483 as the maximum safe size to\nprevent the transaction from being too large to be valid. In common\nsoftware implementations such as LND, this limit is set much lower to 12\nHTLCS. This is because accepting a larger number of HTLCS makes it more\ndifficult for transactions to confirm during congested periods as they\nmust pay higher fees. Therefore, similarly to how congestion control is\nhandled for normal transaction, lightning channel updates can be done\nacross an CHECKTEMPLATEVERIFY tree, allowing nodes to safely use many\nmore HTLCS. Because each HTLC can have its own relative time lock in the\ntree, this also improves the latency sensitivity of the lightning\nprotocol on contested channel close.")]),e._v(" "),n("h3",{attrs:{id:"wallet-vaults-wallet-vaults"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#wallet-vaults-wallet-vaults"}},[e._v("#")]),e._v(" Wallet Vaults {#wallet_vaults}")]),e._v(" "),n("p",[e._v("When greater security is required for cold storage solutions, there can\nbe default script paths that move funds from one target to another\ntarget. For example, a cold wallet can be set up where one customer\nsupport desk can, without further authorization, move a portion of the\nfunds (using multiple pre-set amounts) into a lukewarm wallet operated\nby an isolated support desk. The support desk can then issue some funds\nto a hot wallet, and send the remainder back to cold storage with a\nsimilar withdrawal mechanism in place. This is all possible without\nCHECKTEMPLATEVERIFY, but CHECKTEMPLATEVERIFY eliminates the need for\ncoordination and online signers, as well as reducing the ability for a\nsupport desk to improperly move funds. Furthermore, all such designs can\nbe combined with relative time locks to give time for compliance and\nrisk desks to intervene.")]),e._v(" "),n("p",[n("code",[e._v('<img src="bip-0119/vaults.svg" align="middle">')]),e._v(" "),n("code",[e._v("</img>")])]),e._v(" "),n("h3",{attrs:{id:"coinjoin"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#coinjoin"}},[e._v("#")]),e._v(" CoinJoin")]),e._v(" "),n("p",[e._v("CHECKTEMPLATEVERIFY makes it much easier to set up trustless CoinJoins\nthan previously because participants agree on a single output which pays\nall participants, which will be lower fee than before. Further Each\nparticipant doesn't need to know the totality of the outputs committed\nto by that output, they only have to verify their own sub-tree will pay\nthem.")]),e._v(" "),n("h2",{attrs:{id:"detailed-specification-detailed-specification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#detailed-specification-detailed-specification"}},[e._v("#")]),e._v(" Detailed Specification {#detailed_specification}")]),e._v(" "),n("p",[e._v("The below code is the main logic for verifying CHECKTEMPLATEVERIFY, and\nis the canonical specification for the semantics of\nOP_CHECKTEMPLATEVERIFY.")]),e._v(" "),n("p",[n("code",[e._v("case OP_CHECKTEMPLATEVERIFY:")]),n("br"),e._v(" "),n("code",[e._v("{")]),n("br"),e._v(" "),n("code",[e._v("// if flags not enabled; treat as a NOP4")]),n("br"),e._v(" "),n("code",[e._v("if (!(flags & SCRIPT_VERIFY_STANDARD_TEMPLATE)) break;")]),n("br"),e._v(" "),n("code",[e._v("if (stack.size() < 1)")]),n("br"),e._v(" "),n("code",[e._v("return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);")]),n("br"),e._v(" "),n("code",[e._v("// If the argument was not 32 bytes, treat as OP_NOP4:")]),n("br"),e._v(" "),n("code",[e._v("switch (stack.back().size()) {")]),n("br"),e._v(" "),n("code",[e._v("case 32:")]),n("br"),e._v(" "),n("code",[e._v("if (!checker.CheckStandardTemplateHash(stack.back())) {")]),n("br"),e._v(" "),n("code",[e._v("return set_error(serror, SCRIPT_ERR_TEMPLATE_MISMATCH);")]),n("br"),e._v(" "),n("code",[e._v("}")]),n("br"),e._v(" "),n("code",[e._v("break;")]),n("br"),e._v(" "),n("code",[e._v("default:")]),n("br"),e._v(" "),n("code",[e._v("// future upgrade can add semantics for this opcode with different length args")]),n("br"),e._v(" "),n("code",[e._v("// so discourage use when applicable")]),n("br"),e._v(" "),n("code",[e._v("if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {")]),n("br"),e._v(" "),n("code",[e._v("return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);")]),n("br"),e._v(" "),n("code",[e._v("}")]),n("br"),e._v(" "),n("code",[e._v("}")]),n("br"),e._v(" "),n("code",[e._v("}")]),n("br"),e._v(" "),n("code",[e._v("break;")])]),e._v(" "),n("p",[e._v("The hash is computed as follows:")]),e._v(" "),n("p",[n("code",[e._v("uint256 GetStandardTemplateHash(const CTransaction& tx, uint32_t input_index) {")]),n("br"),e._v(" "),n("code",[e._v("return GetStandardTemplateHash(tx, GetOutputsSHA256(tx), GetSequenceSHA256(tx), input_index);")]),n("br"),e._v(" "),n("code",[e._v("}")]),n("br"),e._v(" "),n("code",[e._v("uint256 GetStandardTemplateHash(const CTransaction& tx, const uint256& outputs_hash, const uint256& sequences_hash,")]),n("br"),e._v(" "),n("code",[e._v("const uint32_t input_index) {")]),n("br"),e._v(" "),n("code",[e._v("bool skip_scriptSigs = std::find_if(tx.vin.begin(), tx.vin.end(),")]),n("br"),e._v(" "),n("code",[e._v("[](const CTxIn& c) { return c.scriptSig != CScript(); }) == tx.vin.end();")]),n("br"),e._v(" "),n("code",[e._v("return skip_scriptSigs ? GetStandardTemplateHashEmptyScript(tx, outputs_hash, sequences_hash, input_index) :")]),n("br"),e._v(" "),n("code",[e._v("GetStandardTemplateHashWithScript(tx, outputs_hash, sequences_hash, GetScriptSigsSHA256(tx), input_index);")]),n("br"),e._v(" "),n("code",[e._v("}")]),n("br"),e._v(" "),n("code",[e._v("uint256 GetStandardTemplateHashWithScript(const CTransaction& tx, const uint256& outputs_hash, const uint256& sequences_hash,")]),n("br"),e._v(" "),n("code",[e._v("const uint256& scriptSig_hash, const uint32_t input_index) {")]),n("br"),e._v(" "),n("code",[e._v("auto h =  CHashWriter(SER_GETHASH, 0)")]),n("br"),e._v(" "),n("code",[e._v("<< tx.nVersion")]),n("br"),e._v(" "),n("code",[e._v("<< tx.nLockTime")]),n("br"),e._v(" "),n("code",[e._v("<< scriptSig_hash")]),n("br"),e._v(" "),n("code",[e._v("<< uint32_t(tx.vin.size())")]),n("br"),e._v(" "),n("code",[e._v("<< sequences_hash")]),n("br"),e._v(" "),n("code",[e._v("<< uint32_t(tx.vout.size())")]),n("br"),e._v(" "),n("code",[e._v("<< outputs_hash")]),n("br"),e._v(" "),n("code",[e._v("<< input_index;")]),n("br"),e._v(" "),n("code",[e._v("return h.GetSHA256();")]),n("br"),e._v(" "),n("code",[e._v("}")]),n("br"),e._v(" "),n("code",[e._v("uint256 GetStandardTemplateHashEmptyScript(const CTransaction& tx, const uint256& outputs_hash, const uint256& sequences_hash,")]),n("br"),e._v(" "),n("code",[e._v("const uint32_t input_index) {")]),n("br"),e._v(" "),n("code",[e._v("auto h =  CHashWriter(SER_GETHASH, 0)")]),n("br"),e._v(" "),n("code",[e._v("<< tx.nVersion")]),n("br"),e._v(" "),n("code",[e._v("<< tx.nLockTime")]),n("br"),e._v(" "),n("code",[e._v("<< uint32_t(tx.vin.size())")]),n("br"),e._v(" "),n("code",[e._v("<< sequences_hash")]),n("br"),e._v(" "),n("code",[e._v("<< uint32_t(tx.vout.size())")]),n("br"),e._v(" "),n("code",[e._v("<< outputs_hash")]),n("br"),e._v(" "),n("code",[e._v("<< input_index;")]),n("br"),e._v(" "),n("code",[e._v("return h.GetSHA256();")]),n("br"),e._v(" "),n("code",[e._v("}")])]),e._v(" "),n("p",[e._v("A PayToBasicStandardTemplate output matches the following template:")]),e._v(" "),n("p",[n("code",[e._v("bool CScript::IsPayToBasicStandardTemplate() const")]),n("br"),e._v(" "),n("code",[e._v("{")]),n("br"),e._v(" "),n("code",[e._v("// Extra-fast test for pay-to-basic-standard-template CScripts:")]),n("br"),e._v(" "),n("code",[e._v("return (this->size() == 34 &&")]),n("br"),e._v(" "),n("code",[e._v("(*this)[0] == 0x20 &&")]),n("br"),e._v(" "),n("code",[e._v("(*this)[33] == OP_CHECKTEMPLATEVERIFY);")]),n("br"),e._v(" "),n("code",[e._v("}")])]),e._v(" "),n("h2",{attrs:{id:"deployment"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#deployment"}},[e._v("#")]),e._v(" Deployment")]),e._v(" "),n("p",[e._v("Deployment should be done via BIP 9 VersionBits.")]),e._v(" "),n("p",[e._v("The start time and bit in the implementation are currently set to bit 5\nand March 1st, 2020, but this is subject to change while the BIP is a\ndraft.")]),e._v(" "),n("p",[e._v("For the avoidance of unclarity, the parameters are:")]),e._v(" "),n("p",[n("code",[e._v("consensus.vDeployments[Consensus::DEPLOYMENT_CHECKTEMPLATEVERIFY].bit = 5;")]),n("br"),e._v(" "),n("code",[e._v("consensus.vDeployments[Consensus::DEPLOYMENT_CHECKTEMPLATEVERIFY].nStartTime = 1583020800; // March 1, 2020")]),n("br"),e._v(" "),n("code",[e._v("consensus.vDeployments[Consensus::DEPLOYMENT_CHECKTEMPLATEVERIFY].nTimeout = 1614556800; //  March 1, 2021")])]),e._v(" "),n("p",[e._v("In order to facilitate using CHECKTEMPLATEVERIFY, the common case of a\nPayToBasicStandardTemplate with no scriptSig data shall be made standard\nto permit relaying. Future template types may be standardized later as\npolicy changes.")]),e._v(" "),n("h2",{attrs:{id:"reference-implementation-reference-implementation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#reference-implementation-reference-implementation"}},[e._v("#")]),e._v(" Reference Implementation {#reference_implementation}")]),e._v(" "),n("p",[e._v("A reference implementation and tests are available here:\n"),n("a",{attrs:{href:"https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://github.com/JeremyRubin/bitcoin/tree/checktemplateverify"),n("OutboundLink")],1),e._v(".")]),e._v(" "),n("h2",{attrs:{id:"rationale"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),n("p",[e._v("The goal of CHECKTEMPLATEVERIFY is to be minimal impact on the existing\ncodebase -- in the future, as we become aware of more complex but shown\nto be safe use cases new template types can be added.")]),e._v(" "),n("p",[e._v("Below we'll discuss the rules one-by-one:")]),e._v(" "),n("h4",{attrs:{id:"the-standardtemplatehash-of-the-transaction-at-the-current-input-index-matches-the-top-of-the-stack-the-standardtemplatehash-of-the-transaction-at-the-current-input-index-matches-the-top-of-the-stack"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-standardtemplatehash-of-the-transaction-at-the-current-input-index-matches-the-top-of-the-stack-the-standardtemplatehash-of-the-transaction-at-the-current-input-index-matches-the-top-of-the-stack"}},[e._v("#")]),e._v(" The StandardTemplateHash of the transaction at the current input index matches the top of the stack {#the_standardtemplatehash_of_the_transaction_at_the_current_input_index_matches_the_top_of_the_stack}")]),e._v(" "),n("p",[e._v("The set of data committed to is a superset of data which can impact the\nTXID of the transaction, other than the inputs. This ensures that for a\ngiven known input, the TXIDs can also be known ahead of time. Otherwise,\nCHECKTEMPLATEVERIFY would not be usable for Channel Factory type\nconstructions as the redemption TXID could be malleated and pre-signed\ntransactions invalidated.")]),e._v(" "),n("h5",{attrs:{id:"committing-to-the-version-and-locktime-committing-to-the-version-and-locktime"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#committing-to-the-version-and-locktime-committing-to-the-version-and-locktime"}},[e._v("#")]),e._v(" Committing to the version and locktime {#committing_to_the_version_and_locktime}")]),e._v(" "),n("p",[e._v("Were these values not committed, it would be possible to delay the\nspending of an output arbitrarily as well as possible to change the\nTXID.")]),e._v(" "),n("p",[e._v("Committing these values, rather than restricting them to specific\nvalues, is more flexible as it permits users of CHECKTEMPLATEVERIFY the\nset the version and locktime as they please.")]),e._v(" "),n("h5",{attrs:{id:"committing-to-the-scriptsigs-hash-committing-to-the-scriptsigs-hash"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#committing-to-the-scriptsigs-hash-committing-to-the-scriptsigs-hash"}},[e._v("#")]),e._v(" Committing to the ScriptSigs Hash {#committing_to_the_scriptsigs_hash}")]),e._v(" "),n("p",[e._v("The scriptsig in a segwit transaction must be exactly empty, unless it\nis a P2SH segwit transaction in which case it must be only the exact\nredeemscript. P2SH is incompatible (unless the P2SH hash is broken) with\nCHECKTEMPLATEVERIFY because the template hash must commit to the\nScriptSig, which must contain the redeemscript, which is a hash cycle.")]),e._v(" "),n("p",[e._v("To prevent malleability when not using a segwit input, we also commit to\nthe scriptsig. This makes it possible to use a 2 input\nCHECKTEMPLATEVERIFY with a legacy pre-signed spend, as long as the exact\nscriptsig for the legacy output is committed. This is more robust than\nsimply disallowing any scriptSig to be set with CHECKTEMPLATEVERIFY.")]),e._v(" "),n("p",[e._v("If no scriptSigs are set in the transaction, there is no purpose in\nhashing the data or including it in the StandardTemplateHash, so we\nelide it. It is expected to be common that no scriptSigs will be set as\nsegwit mandates that the scriptSig must be empty (to avoid\nmalleability).")]),e._v(" "),n("p",[e._v("We commit to the hash rather than the values themselves as this is\nalready precomputed for each transaction to optimize SIGHASH_ALL\nsignatures.")]),e._v(" "),n("p",[e._v("Committing to the hash additionally makes it simpler to construct\nStandardTemplateHashes safely and unambiguously from script.")]),e._v(" "),n("h5",{attrs:{id:"committing-to-the-number-of-inputs-committing-to-the-number-of-inputs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#committing-to-the-number-of-inputs-committing-to-the-number-of-inputs"}},[e._v("#")]),e._v(" Committing to the number of inputs {#committing_to_the_number_of_inputs}")]),e._v(" "),n("p",[e._v('If we allow more than one input to be spent in the transaction then it\nwould be possible for two outputs to request payment to the same set of\noutputs, resulting in half the intended payments being discarded, the\n"half-spend" problem.')]),e._v(" "),n("p",[e._v("Furthermore, the restriction on which inputs can be co-spent is critical\nfor payments-channel constructs where a stable TXID is a requirement\n(updates would need to be signed on all combinations of inputs).")]),e._v(" "),n("p",[e._v("However, there are legitimate use cases for allowing multiple inputs.\nFor example:")]),e._v(" "),n("p",[e._v("Script paths:")]),e._v(" "),n("p",[n("code",[e._v("Path A: <+24 hours> OP_CHECKSEQUENCEVERIFY OP_CHECKTEMPLATEVERIFY <Pay Alice 1 Bitcoin (1 input) nLockTime for +24 hours>")]),n("br"),e._v(" "),n("code",[e._v("Path B: OP_CHECKTEMPLATEVERIFY <Pay Bob 2 Bitcoin (2 inputs)>")])]),e._v(" "),n("p",[e._v("In this case, there are 24 hours for the output to, with the addition of\na second output, pay Bob 2 BTC. If 24 hours lapses, then Alice may\nredeem her 1 BTC from the contract. Both input UTXOs may have the exact\nsame Path B, or only one.")]),e._v(" "),n("p",[e._v("The issue with these constructs is that there are N! orders that the\ninputs can be ordered in and it's not generally possible to restrict\nthe ordering.")]),e._v(" "),n("p",[e._v("CHECKTEMPLATEVERIFY allows for users to guarantee the exact number of\ninputs being spent. In general, using CHECKTEMPLATEVERIFY with more than\none input is difficult and exposes subtle issues, so multiple inputs\nshould not be used except in specific applications.")]),e._v(" "),n("p",[e._v("In principal, committing to the Sequences Hash (below) implicitly\ncommits to the number of inputs, making this field strictly redundant.\nHowever, separately committing to this number makes it easier to\nconstruct StandardTemplateHashes from script.")]),e._v(" "),n("p",[e._v("We treat the number of inputs as a `uint32_t` because signature\nchecking code expects nIn to be an `unsigned int`, even though in\nprincipal a transaction can encode more than a `uint32_t`'s worth of\ninputs.")]),e._v(" "),n("h5",{attrs:{id:"committing-to-the-sequences-hash-committing-to-the-sequences-hash"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#committing-to-the-sequences-hash-committing-to-the-sequences-hash"}},[e._v("#")]),e._v(" Committing to the Sequences Hash {#committing_to_the_sequences_hash}")]),e._v(" "),n("p",[e._v("If we don't commit to the sequences, then the TXID can be malleated.\nThis also allows us to enforce a relative sequence lock without an\nOP_CSV. It is insufficient to just pair CHECKTEMPLATEVERIFY with OP_CSV\nbecause OP_CSV enforces a minimum nSequence value, not a literal value.")]),e._v(" "),n("p",[e._v("We commit to the hash rather than the values themselves as this is\nalready precomputed for each transaction to optimize SIGHASH_ALL\nsignatures.")]),e._v(" "),n("p",[e._v("Committing to the hash additionally makes it simpler to construct\nStandardTemplateHashes safely and unambiguously from script.")]),e._v(" "),n("h5",{attrs:{id:"committing-to-the-number-of-outputs-committing-to-the-number-of-outputs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#committing-to-the-number-of-outputs-committing-to-the-number-of-outputs"}},[e._v("#")]),e._v(" Committing to the Number of Outputs {#committing_to_the_number_of_outputs}")]),e._v(" "),n("p",[e._v("In principal, committing to the Outputs Hash (below) implicitly commits\nto the number of outputs, making this field strictly redundant. However,\nseparately committing to this number makes it easier to construct\nStandardTemplateHashes from script.")]),e._v(" "),n("p",[e._v("We treat the number of outputs as a `uint32_t` because a `COutpoint`\nindex is a `uint32_t`, even though in principal a transaction could\nencode more outputs.")]),e._v(" "),n("h5",{attrs:{id:"committing-to-the-outputs-hash-committing-to-the-outputs-hash"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#committing-to-the-outputs-hash-committing-to-the-outputs-hash"}},[e._v("#")]),e._v(" Committing to the outputs hash {#committing_to_the_outputs_hash}")]),e._v(" "),n("p",[e._v("This ensures that spending the UTXO is guaranteed to create the exact\noutputs requested.")]),e._v(" "),n("p",[e._v("We commit to the hash rather than the values themselves as this is\nalready precomputed for each transaction to optimize SIGHASH_ALL\nsignatures.")]),e._v(" "),n("p",[e._v("Committing to the hash additionally makes it simpler to construct\nStandardTemplateHashes safely and unambiguously from script.")]),e._v(" "),n("h5",{attrs:{id:"committing-to-the-current-input-s-index-committing-to-the-current-inputs-index"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#committing-to-the-current-input-s-index-committing-to-the-current-inputs-index"}},[e._v("#")]),e._v(" Committing to the current input's index {#committing_to_the_current_inputs_index}")]),e._v(" "),n("p",[e._v("Committing to the currently executing input's index is not strictly\nneeded for anti-malleability, however it does restrict the input\norderings eliminating a source of malleability for protocol designers.")]),e._v(" "),n("p",[e._v("However, committing to the index eliminates key-reuse vulnerability to\nthe half-spend problem. As CHECKTEMPLATEVERIFY scripts commit to being\nspent at particular index, reused instances of these scripts cannot be\nspent at the same index, which implies that they cannot be spent in the\nsame transaction. This makes it safer to design wallet vault contracts\nwithout half-spend vulnerabilities.")]),e._v(" "),n("p",[e._v("Committing to the current index doesn't prevent one from expressing a\nCHECKTEMPLATEVERIFY which can be spent at multiple indicies. In current\nscript, the CHECKTEMPLATEVERIFY operation can be wrapped in an OP_IF for\neach index (or Tapscript branches in the future). If OP_CAT or\nOP_SHA256STREAM are added to Bitcoin, the index may simply be passed in\nby the witness before hashing.")]),e._v(" "),n("h5",{attrs:{id:"committing-to-values-by-hash-committing-to-values-by-hash"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#committing-to-values-by-hash-committing-to-values-by-hash"}},[e._v("#")]),e._v(" Committing to Values by Hash {#committing_to_values_by_hash}")]),e._v(" "),n("p",[e._v("Committing to values by hash makes it easier and more efficient to\nconstruct a StandardTemplateHash from script. Fields which are not\nintended to be set may be committed to by hash without incurring O(n)\noverhead to re-hash.")]),e._v(" "),n("p",[e._v("Furthermore, if OP_SHA256STREAM is added in the future, it may be\npossible to write a script which allows adding a single output to a list\nof outputs without incurring O(n) overhead by committing to a hash\nmidstate in the script.")]),e._v(" "),n("h5",{attrs:{id:"the-ordering-of-fields-the-ordering-of-fields"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-ordering-of-fields-the-ordering-of-fields"}},[e._v("#")]),e._v(" The Ordering of Fields {#the_ordering_of_fields}")]),e._v(" "),n("p",[e._v("Strictly speaking, the ordering of fields is insignificant. However,\nwith a carefully selected order, the efficiency of future scripts (e.g.,\nthose using a OP_CAT or OP_SHA256STREAM) may be improved.")]),e._v(" "),n("p",[e._v("In particular, the order is selected in order of least likely to change\nto most.")]),e._v(" "),n("ol",[n("li",[e._v("nVersion")]),e._v(" "),n("li",[e._v("nLockTime")]),e._v(" "),n("li",[e._v("scriptSig hash (maybe!)")]),e._v(" "),n("li",[e._v("input count")]),e._v(" "),n("li",[e._v("sequences hash")]),e._v(" "),n("li",[e._v("output count")]),e._v(" "),n("li",[e._v("outputs hash")]),e._v(" "),n("li",[e._v("input index")])]),e._v(" "),n("p",[e._v("Several fields are infrequently modified. nVersion should change\ninfrequently. nLockTime should generally be fixed to 0 (in the case of a\npayment tree, only the *first* lock time is needed to prevent\nfee-sniping the root). scriptSig hash should generally not be set at\nall.")]),e._v(" "),n("p",[e._v("Since there are many possible sequences hash for a given input count,\nthe input count comes before the sequences hash.")]),e._v(" "),n("p",[e._v("Since there are many possible outputs hashes for a given out count, the\noutput count comes before the outputs hash.")]),e._v(" "),n("p",[e._v("Since we're generally using a single input to many output design,\nwe're more likely to modify the outputs hash than the inputs hash.")]),e._v(" "),n("p",[e._v('We usually have just a single input on a CHECKTEMPLATEVERIFY script,\nwhich would suggest that it does not make sense for input index to be\nthe last field. However, given the desirability of being able to express\na "don\'t care" index easily (e.g., for decentralized kickstarter-type\ntransactions), this value is placed last.')]),e._v(" "),n("p",[e._v("As an example, the following code checks an input index argument and\nconcatenates it to the template and checks the template matches the\ntransaction.")]),e._v(" "),n("p",[n("code",[e._v("OP_SIZE 4 OP_EQUALVERIF")]),n("br"),e._v(" "),n("code",[e._v("<nVersion || nLockTime || input count || sequences hash || output count || outputs hash>")]),n("br"),e._v(" "),n("code",[e._v("OP_SWAP OP_CAT OP_SHA256 OP_CHECKTEMPLATEVERIFY")])]),e._v(" "),n("h3",{attrs:{id:"design-tradeoffs-and-risks-design-tradeoffs-and-risks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#design-tradeoffs-and-risks-design-tradeoffs-and-risks"}},[e._v("#")]),e._v(" Design Tradeoffs and Risks {#design_tradeoffs_and_risks}")]),e._v(" "),n("p",[e._v("Covenants have historically been controversial given their potential for\nfungibility risks -- coins could be minted which have a permanent\nrestriction on how they may or may not be spent or required to propagate\nmetadata.")]),e._v(" "),n("p",[e._v("In the CHECKTEMPLATEVERIFY approach, the covenants are severely\nrestricted to simple templates. The structure of CHECKTEMPLATEVERIFY\ntemplate is such that the outputs must be known exactly at the time of\nconstruction. Based on a destructuring argument, it is only possible to\ncreate templates which expand in a finite number of steps. Thus\ntemplated transactions are in theory as safe as transactions which\ncreate all the inputs directly in this regard.")]),e._v(" "),n("p",[e._v("Furthermore, templates are restricted to be spendable as a known number\nof inputs only, preventing unintentional introduction of the 'half\nspend' problem.")]),e._v(" "),n("p",[e._v("Templates, as restricted as they are, bear some risks.")]),e._v(" "),n("h4",{attrs:{id:"permanently-unspendable-outputs-permanently-unspendable-outputs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#permanently-unspendable-outputs-permanently-unspendable-outputs"}},[e._v("#")]),e._v(" Permanently Unspendable Outputs {#permanently_unspendable_outputs}")]),e._v(" "),n("p",[e._v("The preimage argument passed to CHECKTEMPLATEVERIFY may be unknown or\notherwise unsatisfiable. However, requiring knowledge that an address is\nspendable from is incompatible with sender's ability to spend to any\naddress (especially, OP_RETURN). If a sender needs to know the template\ncan be spent from before sending, they may request a signature of an\nprovably non-transaction challenge string from the leafs of the\nCHECKTEMPLATEVERIFY tree.")]),e._v(" "),n("h4",{attrs:{id:"forwarding-addresses-forwarding-addresses"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#forwarding-addresses-forwarding-addresses"}},[e._v("#")]),e._v(" Forwarding Addresses {#forwarding_addresses}")]),e._v(" "),n("p",[e._v('Key-reuse with CHECKTEMPLATEVERIFY may be used as a form of "forwarding\naddress contract". A forwarding address is an address which can\nautomatically execute in a predefined way. For example, a exchange\'s\nhot wallet might use an address which can automatically be moved to a\ncold storage address after a relative timeout.')]),e._v(" "),n("p",[e._v("The issue is that reusing addresses in this way can lead to loss of\nfunds. Suppose one creates an template address which forwards 1 BTC to\ncold storage. Creating an output to this address with less than 1 BTC\nwill be frozen permanently. Paying more than 1 BTC will lead to the\nfunds in excess of 1BTC to be paid as a large miner fee.\nCHECKTEMPLATEVERIFY could commit to the exact amount of bitcoin provided\nby the inputs/amount of fee paid, but as this is a user error and not a\nmalleability issue this is not done. Future soft-forks could introduce\nopcodes which allow conditionalizing which template or script branches\nmay be used based on inspecting the amount of funds available in a\ntransaction")]),e._v(" "),n("p",[e._v("As a general best practice, it is incumbent on Bitcoin users to not\nreuse any address unless you are certain that the address is acceptable\nfor the payment attempted. This limitation and risk is not unique to\nCHECKTEMPLATEVERIFY. For example, atomic swap scripts are single use\nonce the hash is revealed. Future Taproot scripts may contain many\nlogical branches that would be unsafe for being spent to multiple times\n(e.g., a Hash Time Lock branch should be instantiated with unique hashes\neach time it is used). Keys which have signed a SIGHASH_ANYPREVOUT\ntransaction can similarly become reuse-unsafe.")]),e._v(" "),n("p",[e._v('Because CHECKTEMPLATEVERIFY commits to the input index currently being\nspent, reused-keys are guaranteed to execute in separate transactions\nwhich reduces the risk of "half-spend" type issues.')]),e._v(" "),n("h4",{attrs:{id:"nop-default-and-standardness-rules-nop-default-and-standardness-rules"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nop-default-and-standardness-rules-nop-default-and-standardness-rules"}},[e._v("#")]),e._v(" NOP-Default and Standardness Rules {#nop_default_and_standardness_rules}")]),e._v(" "),n("p",[e._v("If the argument length is not exactly 32, CHECKTEMPLATEVERIFY treats it\nas a NOP. Many OP_NOP upgrades prefer to fail in such circumstances. In\nparticular, for CHECKTEMPLATEVERIFY, making an invalid argument a NOP\npermits future soft-forks to upgrade the semantics or loosed\nrestrictions around the value being previously pushed only.")]),e._v(" "),n("p",[e._v("The standardness rules may lead an unscrupulous script developer to\naccidentally rely on the stricter standardness rules to be enforced\nduring consensus. Should that developer submit a transaction directly to\nthe network relying on standardness rejection, an standardness-invalid\nbut consensus-valid transaction may be caused, leading to a potential\nloss of funds.")]),e._v(" "),n("h4",{attrs:{id:"feature-redundancy-feature-redundancy"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#feature-redundancy-feature-redundancy"}},[e._v("#")]),e._v(" Feature Redundancy {#feature_redundancy}")]),e._v(" "),n("p",[e._v("CHECKTEMPLATEVERIFY templates are substantially less risky than other\ncovenant systems. If implemented, other covenant systems could make the\nCHECKTEMPLATEVERIFY's functionality redundant. However, given\nCHECKTEMPLATEVERIFY's simple semantics and low on chain cost it's\nlikely that it would continue to be favored even if redundant with other\ncapabilities.")]),e._v(" "),n("p",[e._v("More powerful covenants like those proposed by MES16, would also bring\nsome benefits in terms of improving the ability to adjust for things\nlike fees rather than relying on child-pays-for-parent or other\nmechanisms. However, these features come at substantially increased\ncomplexity and room for unintended behavior.")]),e._v(" "),n("p",[e._v("Alternatively, SIGHASH_ANYPREVOUTANYSCRIPT based covenant designs can\nimplement something similar to templates, via a scriptPubKey like:")]),e._v(" "),n("p",[n("code",[e._v("<sig of desired TX with PK and fixed nonce R || SIGHASH_ANYPREVOUTANYSCRIPT  <PK with public SK>")]),e._v(" "),n("code",[e._v("OP_CHECKSIG")])]),e._v(" "),n("p",[e._v("SIGHASH_ANYPREVOUTANYSCRIPT bears additional technical and\nimplementation risks that may preclude its viability for inclusion in\nBitcoin, but the capabilities above are similar to what\nCHECKTEMPLATEVERIFY offers. However, CHECKTEMPLATEVERIFY has benefits in\nterms of verification speed, as it requires only hash computation rather\nthan signature operations. This can be significant when constructing\nlarge payment trees or programmatic compilations. CHECKTEMPLATEVERIFY\nalso has a feature-wise benefit in that it provides a robust pathway for\nfuture template upgrades.")]),e._v(" "),n("p",[e._v("CHECKSIGFROMSTACK along with OP_CAT may also be used to emulate\nCHECKTEMPLATEVERIFY. However such constructions are more complicated to\nuse than CHECKTEMPLATEVERIFY, and encumbers additional verification\noverhead absent from CHECKTEMPLATEVERIFY. These types of covenants also\nbear similar potential recursion issues to OP_COV which make it unlikely\nfor inclusion in Bitcoin.")]),e._v(" "),n("p",[e._v("Given the simplicity of this approach to implement and analyze, and the\nbenefits realizable by user applications, CHECKTEMPLATEVERIFY's\ntemplate based approach is proposed in lieu of more complete covenants\nsystem.")]),e._v(" "),n("h2",{attrs:{id:"backwards-compatibility-backwards-compatibility"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#backwards-compatibility-backwards-compatibility"}},[e._v("#")]),e._v(" Backwards Compatibility {#backwards_compatibility}")]),e._v(" "),n("p",[e._v("OP_CHECKTEMPLATEVERIFY replaces a OP_NOP4 with stricter verification\nsemantics. Therefore, scripts which previously were valid will cease to\nbe valid with this change. Stricter verification semantics for an OP_NOP\nare a soft fork, so existing software will be fully functional without\nupgrade except for mining and block validation. Similar soft forks for\nOP_CHECKSEQUENCEVERIFY and OP_CHECKLOCKTIMEVERIFY (see BIP-0065 and\nBIP-0112) have similarly changed OP_NOP semantics without introducing\ncompatibility issues.")]),e._v(" "),n("p",[e._v('Older wallet software will be able to accept spends from\nOP_CHECKTEMPLATEVERIFY outputs, but will require an upgrade in order to\ntreat PayToBasicStandardTemplate chains with a confirmed ancestor as\nbeing "trusted" (i.e., eligible for spending before the transaction is\nconfirmed).')]),e._v(" "),n("p",[e._v("Backports of OP_CHECKTEMPLATEVERIFY can be trivially prepared (see the\nreference implementation) for older node versions that can be patched\nbut not upgraded to a newer major release.")]),e._v(" "),n("h2",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),n("ul",[n("li",[n("a",{attrs:{href:"https://utxos.org",target:"_blank",rel:"noopener noreferrer"}},[e._v("utxos.org informational site"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://www.youtube.com/watch?v=YxsjdIl0034&t=2451",target:"_blank",rel:"noopener noreferrer"}},[e._v("Scaling Bitcoin\nPresentation"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://bitcoinops.org/en/newsletters/2019/05/29/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Optech Newsletter Covering\nOP_CHECKOUTPUTSHASHVERIFY"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://cyber.stanford.edu/sites/g/files/sbiybj9936/f/jeremyrubin.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Structuring Multi Transaction Contracts in\nBitcoin"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://github.com/jeremyrubin/lazuli",target:"_blank",rel:"noopener noreferrer"}},[e._v("Lazuli Notes (ECDSA based N-of-N Signatures for Certified\nPost-Dated UTXOs)"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://fc16.ifca.ai/bitcoin/papers/MES16.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Bitcoin Covenants"),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://bitcointalk.org/index.php?topic=278122.0",target:"_blank",rel:"noopener noreferrer"}},[e._v("CoinCovenants using SCIP signatures, an amusingly bad\nidea."),n("OutboundLink")],1)]),e._v(" "),n("li",[n("a",{attrs:{href:"https://fc17.ifca.ai/bitcoin/papers/bitcoin17-final28.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Enhancing Bitcoin Transactions with\nCovenants"),n("OutboundLink")],1)])]),e._v(" "),n("h3",{attrs:{id:"note-on-similar-alternatives-note-on-similar-alternatives"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#note-on-similar-alternatives-note-on-similar-alternatives"}},[e._v("#")]),e._v(" Note on Similar Alternatives {#note_on_similar_alternatives}")]),e._v(" "),n("p",[e._v("An earlier version of CHECKTEMPLATEVERIFY, CHECKOUTPUTSHASHVERIFY, is\nwithdrawn in favor of CHECKTEMPLATEVERIFY. CHECKOUTPUTSHASHVERIFY did\nnot commit to the version or lock time and was thus insecure.")]),e._v(" "),n("p",[e._v("CHECKTEMPLATEVERIFY could also be implemented as an extension to\nTaproot, and was proposed this way earlier. However, given that\nCHECKTEMPLATEVERIFY has no dependency on Taproot, it is preferable to\ndeploy it independently.")]),e._v(" "),n("p",[e._v("CHECKTEMPLATEVERIFY has also been previously referred to as\nOP_SECURETHEBAG, which is mentioned here to aid in searching and\nreferencing discussion on this BIP.")]),e._v(" "),n("h2",{attrs:{id:"copyright"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),n("p",[e._v("This document is licensed under the 3-clause BSD license.")])])}),[],!1,null,null,null);t.default=s.exports}}]);