(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{455:function(e,n,t){"use strict";t.r(n);var i=t(43),s=Object(i.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_310"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_310"}},[e._v("#")]),e._v(" 310")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("  BIP: 310\n  Layer: Applications\n  Title: Stratum protocol extensions\n  Author: Pavel Moravec <pavel.moravec@braiins.cz>\n          Jan Čapek <jan.capek@braiins.cz>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0310\n  Status: Draft\n  Type: Informational\n  Created: 2018-03-10\n  License: BSD-3-Clause\n           CC0-1.0\n")])])]),t("h2",{attrs:{id:"abstract"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),t("p",[e._v('This BIP provides a generic mechanism for specifying stratum protocol\nextensions. At the same time, one of the important extensions that is\nspecified by this BIP is configuration of bits for "version rolling"\nin nVersion field of bitcoin block header.')]),e._v(" "),t("p",[e._v('The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL\nNOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and\n"OPTIONAL" in this document are to be interpreted as described in RFC\n2119.')]),e._v(" "),t("h2",{attrs:{id:"motivation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),t("p",[e._v('The initial motivation for specifying some general support for stratum\nprotocol extensions was a need to allow miners to do so called "version\nrolling", changing value in the first field of the Bitcoin block\nheader.')]),e._v(" "),t("p",[e._v("Version rolling is backwards incompatible change to the stratum protocol\nbecause the miner couldn't communicate different block version value to\nthe server in the original version of the stratum protocol. Similarly, a\nserver couldn't communicate safe bits for rolling to a miner. So both\nminers and pools need to implement some protocol extension to support\nversion rolling.")]),e._v(" "),t("p",[e._v("Typically, if a miner sends an unknown message to a server, the server\ncloses the connection (not all implementations do that but some do). So\nit is not very safe to try to send unknown messages to servers.")]),e._v(" "),t("p",[e._v("We can use this opportunity to make one backwards incompatible change to\nthe protocol to support multiple extensions in the future. In a way that\na miner can advertise its capabilities and at the same time it can\nrequest some needed features from the server.")]),e._v(" "),t("p",[e._v("It is preferable that the same mechanism for feature negotiation can be\nused for not yet known features. It SHOULD be easy to implement in the\nmining software too.")]),e._v(" "),t("p",[e._v("We introduce one new message to the stratum protocol\n("),t("strong",[e._v('"mining.configure"')]),e._v(") which handles the initial\nconfiguration/negotiation of features in a generic way. So that adding\nfeatures in the future can be done without a necessity to add new\nmessages to stratum protocol.")]),e._v(" "),t("p",[e._v("Each extension has its unique string name, so called "),t("strong",[e._v("extension code")]),e._v(".")]),e._v(" "),t("h2",{attrs:{id:"specification"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),t("p",[e._v("Currently, the following extensions are defined:")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v('"version-rolling"')])]),e._v(" "),t("li",[t("strong",[e._v('"minimum-difficulty"')])]),e._v(" "),t("li",[t("strong",[e._v('"subscribe-extranonce"')])])]),e._v(" "),t("h3",{attrs:{id:"additional-data-types-additional-data-types"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#additional-data-types-additional-data-types"}},[e._v("#")]),e._v(" Additional data types {#additional_data_types}")]),e._v(" "),t("p",[e._v("The following names are used as type aliases, making the message\ndescription easier.")]),e._v(" "),t("ul",[t("li",[t("p",[t("strong",[e._v("TMask")]),e._v(" - case independent hexadecimal string of length 8,\nencoding an unsigned 32-bit integer (~"),t("code",[e._v("[0-9a-fA-F]{8}")]),e._v(")")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("TExtensionCode")]),e._v(" - non-empty string with a value equal to the name\nof some protocol extension.")])]),e._v(" "),t("li",[t("p",[t("strong",[e._v("TExtensionResult")]),e._v(" - "),t("code",[e._v("true")]),e._v(" / "),t("code",[e._v("false")]),e._v(" / "),t("em",[e._v("String")]),e._v(".")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("true")]),e._v(" = The requested feature is supported and its\nconfiguration understood and applied.")]),e._v(" "),t("li",[t("code",[e._v("false")]),e._v(" = The feature is not supported or unknown.")]),e._v(" "),t("li",[t("em",[e._v("String")]),e._v(" = Error message containing information about what went\nwrong.")])])])]),e._v(" "),t("h3",{attrs:{id:"request-mining-configure-request-mining-configure"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#request-mining-configure-request-mining-configure"}},[e._v("#")]),e._v(' Request "mining.configure" {#request_mining.configure}')]),e._v(" "),t("p",[e._v("This message (JSON RPC Request) SHOULD be the "),t("strong",[e._v("first message")]),e._v(" sent by\nthe miner after the connection with the server is established. The\nclient uses the message to advertise its features and to request/allow\nsome protocol extensions.")]),e._v(" "),t("p",[e._v("The reason for it being the first is that we want the implementation and\npossible interactions to be as easy and simple as possible. An extension\ncan define explicitly what does a repeated configuration of that\nextension mean.")]),e._v(" "),t("p",[e._v('Each extension code provides a namespace for its extension parameters\nand extension return values. By convention, the names are formed from\nextension codes by adding "." and a parameter name. The same applies\nfor the return values, which are transferred in a result map too. E.g.\n"version-rolling.mask" is the name of the parameter "mask" of\nextension "version-rolling".')]),e._v(" "),t("p",[t("strong",[e._v("Parameters")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v("extensions")]),e._v(" (REQUIRED, List of "),t("em",[e._v("TExtensionCode")]),e._v(")")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(":   \\- Each string in the list MUST be a valid extension code. The\n    meaning of each code is described independently as part of the\n    extension definition. A miner SHOULD advertise all its available\n    features.\n")])])]),t("ul",[t("li",[t("strong",[e._v("extension-parameters")]),e._v(" (REQUIRED, "),t("em",[e._v("Map of (String -> Any)")]),e._v(")")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(":   \\- Parameters of the requested/allowed extensions from the first\n    parameter.\n")])])]),t("p",[t("strong",[e._v("Return value")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("Map of (String -> Any)")])])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(':   \\- Each code from the **extensions** list MUST have a defined\n    return value (*TExtensionCode* -\\> *TExtensionResult*). This way\n    the miner knows if the extension is activated or not. E.g.\n    `{"version-rolling":false}` for unsupported version rolling.\n:   \\- Some extensions need additional information to be delivered\n    to the miner. The return value map is used for this purpose.\n')])])]),t("p",[e._v("Example request (new-lines added):")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(' {"method": "mining.configure",\n  "id": 1,\n  "params": [["minimum-difficulty", "version-rolling"],\n         {"minimum-difficulty.value": 2048,\n          "version-rolling.mask": "1fffe000", "version-rolling.min-bit-count": 2}]}\n')])])]),t("p",[e._v("(The miner requests extensions "),t("code",[e._v('"version-rolling"')]),e._v(" and\n"),t("code",[e._v('"minimum-difficulty"')]),e._v(". It sets the parameters according to the\nextensions' definitions.)")]),e._v(" "),t("p",[e._v("Example result (new-lines added):")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(' {"error": null,\n  "id": 1,\n  "result": {"version-rolling": true,\n         "version-rolling.mask": "18000000",\n         "minimum-difficulty": true}}\n')])])]),t("h1",{attrs:{id:"defined-extensions-defined-extensions"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#defined-extensions-defined-extensions"}},[e._v("#")]),e._v(" Defined extensions {#defined_extensions}")]),e._v(" "),t("h2",{attrs:{id:"extension-version-rolling-extension-version-rolling"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#extension-version-rolling-extension-version-rolling"}},[e._v("#")]),e._v(' Extension "version-rolling" {#extension_version_rolling}')]),e._v(" "),t("p",[e._v("This extension allows the miner to change the value of some bits in the\nversion field in the block header. Currently there are no standard bits\nused for version rolling so they need to be negotiated between a miner\nand a server.")]),e._v(" "),t("p",[e._v("A miner sends the server a mask describing bits which the miner is\ncapable of changing. 1 = changeable bit, 0 = not changeable\n("),t("code",[e._v("miner_mask")]),e._v(") and a minimum number of bits that it needs for efficient\nversion rolling.")]),e._v(" "),t("p",[e._v("A server typically allows you to change only some of the version bits\n("),t("code",[e._v("server_mask")]),e._v(") and the rest of the version bits are fixed. E.g. because\nthe block needs to be valid or some signaling is in place.")]),e._v(" "),t("p",[e._v("The server responds to the configuration message by sending a mask with\ncommon bits intersection of the miner's mask and its a mask\n("),t("code",[e._v("response = server_mask & miner_mask")]),e._v(")")]),e._v(" "),t("p",[e._v("Example request (a miner capable of changing any 2 bits from a 16-bit\nmask):")]),e._v(" "),t("p",[t("code",[e._v('{"method": "mining.configure", "id": 1, "params": [["version-rolling"], {"version-rolling.mask": "1fffe000", "version-rolling.min-bit-count": 2}]}')])]),e._v(" "),t("p",[e._v("Example result (success):")]),e._v(" "),t("p",[t("code",[e._v('{"error": null, "id": 1, "result": {"version-rolling": true, "version-rolling.mask": "18000000"}}')])]),e._v(" "),t("p",[e._v("Example result (unknown extension):")]),e._v(" "),t("p",[t("code",[e._v('{"error": null, "id": 1, "result": {"version-rolling": false}}')])]),e._v(" "),t("p",[t("strong",[e._v("Extension parameters")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v('"version-rolling.mask"')]),e._v(" (OPTIONAL, "),t("em",[e._v("TMask")]),e._v(", default value\n"),t("code",[e._v('"ffffffff"')]),e._v(")")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(":   \\- Bits set to 1 can be changed by the miner. This value is\n    expected\n")])])]),t("p",[e._v("to be stable for the whole mining session. A miner doesn't have to send\nthe mask, in this case a default full mask is used.")]),e._v(" "),t("p",[t("strong",[e._v("Extension return values")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v('"version-rolling"')]),e._v(" (REQUIRED, "),t("em",[e._v("TExtensionResult")]),e._v(")")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(':   \\- When responded with `true`, the server will accept new\n    parameter of **\\"mining.submit\\"**, see later.\n')])])]),t("ul",[t("li",[t("strong",[e._v('"version-rolling.mask"')]),e._v(" (REQUIRED, "),t("em",[e._v("TMask")]),e._v(")")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(":   \\- Bits set to 1 are allowed to be changed by the miner. If a\n    miner changes bits with mask value 0, the server will reject the\n    submit.\n:   \\- The server SHOULD return the largest mask possible (as many\n    bits set to 1 as possible). This can be useful in a mining proxy\n    setup when a proxy needs to negotiate the best mask for its\n    future clients. There is a \\[Draft\n    BIP\\](https://github.com/bitcoin/bips/pull/661/files) describing\n    available nVersion bits. The server SHOULD pick a mask that\n    preferably covers all bits specified in the BIP.\n")])])]),t("ul",[t("li",[t("strong",[e._v('"version-rolling.min-bit-count"')]),e._v(" (REQUIRED, "),t("em",[e._v("TMask")]),e._v(")")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(":   \\- The miner also provides a minimum number of bits that it\n    needs for efficient version rolling in hardware. Note that this\n    parameter provides important diagnostic information to the pool\n    server. If the requested bit count exceeds the limit of the pool\n    server, the miner always has the chance to operate in a degraded\n    mode without using full hashing power. The pool server SHOULD\n    NOT terminate miner connection if this rare mismatch case\n    occurs.\n")])])]),t("h3",{attrs:{id:"notification-mining-set-version-mask-notification-mining-set-version-mask"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#notification-mining-set-version-mask-notification-mining-set-version-mask"}},[e._v("#")]),e._v(" Notification "),t("strong",[e._v('"mining.set_version_mask"')]),e._v(" {#notification_mining.set_version_mask}")]),e._v(" "),t("p",[e._v('Server notifies the miner about a new mask valid for the connection.\nThis message can be sent at any time after the successful setup of the\nversion rolling extension by the "mining.configure" message. The new\nmask is valid '),t("strong",[e._v("immediately")]),e._v(", so that the server doesn't wait for the\nnext job.")]),e._v(" "),t("p",[t("strong",[e._v("Parameters")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("mask")]),e._v(" (REQUIRED, "),t("em",[e._v("TMask")]),e._v("): The meaning is the same as the\n"),t("strong",[e._v('"version-rolling.mask"')]),e._v(" return parameter.")])]),e._v(" "),t("p",[e._v("Example:")]),e._v(" "),t("p",[t("code",[e._v('{"params":["00003000"], "id":null, "method": "mining.set_version_mask"}')])]),e._v(" "),t("h3",{attrs:{id:"changes-in-request-mining-submit-changes-in-request-mining-submit"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#changes-in-request-mining-submit-changes-in-request-mining-submit"}},[e._v("#")]),e._v(" Changes in request "),t("strong",[e._v('"mining.submit"')]),e._v(" {#changes_in_request_mining.submit}")]),e._v(" "),t("p",[e._v("Immediately after successful activation of the version-rolling extension\n(result to "),t("strong",[e._v('"mining.configure"')]),e._v(" sent by server), the server MUST\naccept an additional parameter of the message "),t("strong",[e._v('"mining.submit"')]),e._v(". The\nclient MUST send one additional parameter, "),t("strong",[e._v("version_bits")]),e._v(" (6th\nparameter, after "),t("em",[e._v("worker_name")]),e._v(", "),t("em",[e._v("job_id")]),e._v(", "),t("em",[e._v("extranonce2")]),e._v(", "),t("em",[e._v("ntime")]),e._v(" and\n"),t("em",[e._v("nonce")]),e._v(").")]),e._v(" "),t("p",[t("strong",[e._v("Additional parameters")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("em",[e._v("version_bits")]),e._v(" (REQUIRED, "),t("em",[e._v("TMask")]),e._v(") - Version bits set by miner.")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(':   \\- Miner can set only bits corresponding to the set bits in the\n    last received mask from the server either as response to\n    \\"mining.configure\\" or \\"mining.set_version_mask\\" notification\n    (`last_mask`). This must hold:\n')])])]),t("p",[t("code",[e._v("version_bits & ~last_mask ==  0")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(":   \\- The server computes *nVersion* for the submit as follows:\n")])])]),t("p",[t("code",[e._v("nVersion = (job_version & ~last_mask) | (version_bits & last_mask)")])]),e._v(" "),t("p",[e._v("where "),t("code",[e._v("job_version")]),e._v(" is the block version sent to miner as part of job\nwith id "),t("code",[e._v("job_id")]),e._v(".")]),e._v(" "),t("h2",{attrs:{id:"extension-minimum-difficulty-extension-minimum-difficulty"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#extension-minimum-difficulty-extension-minimum-difficulty"}},[e._v("#")]),e._v(' Extension "minimum-difficulty" {#extension_minimum_difficulty}')]),e._v(" "),t("p",[e._v("This extension allows miner to request a minimum difficulty for the\nconnected machine. It solves a problem in the original stratum protocol\nwhere there is no way how to communicate hard limit of the connected\ndevice.")]),e._v(" "),t("p",[t("strong",[e._v("Extension parameters")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v('"minimum-difficulty.value"')]),e._v(" (REQUIRED, "),t("em",[e._v("Integer/Float")]),e._v(", >= 0)")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(":   \\- The minimum difficulty value acceptable for the\n    miner/connection. The value can be 0 for essentially disabling\n    the feature.\n")])])]),t("p",[t("strong",[e._v("Extension return values")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v('"minimum-difficulty"')]),e._v(" (REQUIRED, "),t("em",[e._v("TExtensionResult")]),e._v(")")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(':   \\- Whether the minimum difficulty was accepted or not.\n:   \\- This extension can be configured multiple times by calling\n    \\"mining.configure\\" with \\"minimum-difficulty\\" code again.\n')])])]),t("h2",{attrs:{id:"extension-subscribe-extranonce-extension-subscribe-extranonce"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#extension-subscribe-extranonce-extension-subscribe-extranonce"}},[e._v("#")]),e._v(' Extension "subscribe-extranonce" {#extension_subscribe_extranonce}')]),e._v(" "),t("p",[e._v("Parameter-less extension. Miner advertises its capability of receiving\nmessage "),t("strong",[e._v('"mining.set_extranonce"')]),e._v(" message (useful for hash rate\nrouting scenarios).")]),e._v(" "),t("h2",{attrs:{id:"extension-info-extension-info"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#extension-info-extension-info"}},[e._v("#")]),e._v(' Extension "info" {#extension_info}')]),e._v(" "),t("p",[e._v("Miner provides additional text-based information.")]),e._v(" "),t("p",[t("strong",[e._v("Extension parameters")]),e._v(":")]),e._v(" "),t("ul",[t("li",[t("strong",[e._v('"info.connection-url"')]),e._v(" (OPTIONAL, "),t("em",[e._v("String")]),e._v(")")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(":   \\- Exact URL used by the mining software to connect to the\n    stratum server.\n")])])]),t("ul",[t("li",[t("strong",[e._v('"info.hw-version"')]),e._v(" (OPTIONAL, "),t("em",[e._v("String")]),e._v(")")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(":   \\- Manufacturer specific hardware revision string.\n")])])]),t("ul",[t("li",[t("strong",[e._v('"info.sw-version"')]),e._v(" (OPTIONAL, "),t("em",[e._v("String")]),e._v(")")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(":   \\- Manufacturer specific software version\n")])])]),t("ul",[t("li",[t("strong",[e._v('"info.hw-id"')]),e._v(" (OPTIONAL, "),t("em",[e._v("String")]),e._v(")")])]),e._v(" "),t("p",[e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v(":   \\- Unique identifier of the mining device\n")])])]),t("h2",{attrs:{id:"compatibility"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#compatibility"}},[e._v("#")]),e._v(" Compatibility")]),e._v(" "),t("p",[e._v("Currently, there is a similar protocol feature "),t("strong",[e._v("mining.capabilities")]),e._v("\nthat was intended for various protocol extensions. However,\n"),t("strong",[e._v("mining.configure")]),e._v(" is incompatible with this feature as it requires a\nserver response confirming all accepted/negotatied extensions. The\nreason why we made it incompatible is that "),t("strong",[e._v("mining.capabilities")]),e._v("\nrequest has no associated response.")]),e._v(" "),t("h2",{attrs:{id:"copyright"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),t("p",[e._v("This document is dual licensed as BSD 3-clause, and Creative Commons CC0\n1.0 Universal.")])])}),[],!1,null,null,null);n.default=s.exports}}]);