(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{467:function(e,a,s){"use strict";s.r(a);var t=s(43),n=Object(t.a)({},(function(){var e=this,a=e.$createElement,s=e._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"_45"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_45"}},[e._v("#")]),e._v(" 45")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("  BIP: 45\n  Layer: Applications\n  Title: Structure for Deterministic P2SH Multisignature Wallets\n  Author: Manuel Araoz <manu@bitpay.com>\n          Ryan X. Charles <ryan@bitpay.com>\n          Matias Alejo Garcia <matias@bitpay.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0045\n  Status: Proposed\n  Type: Standards Track\n  Created: 2014-04-25\n")])])]),s("h2",{attrs:{id:"abstract"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),s("p",[e._v("This BIP defines a structure for hierarchical deterministic P2SH\nmulti-party multi-signature wallets (HDPM wallets from now on) based on\nthe algorithm described in BIP-0032 (BIP32 from now on) and purpose\nscheme described in BIP-0043 (BIP43 from now on). This BIP is a\nparticular application of BIP43.")]),e._v(" "),s("h2",{attrs:{id:"motivation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),s("p",[e._v("The structure proposed in this document allows for standard ways to\ncreate, use, import, and store HDPM wallets. It allows to handle\nmultiple parties sharing an m-of-n wallet, on the following assumptions:")]),e._v(" "),s("ul",[s("li",[e._v("n parties share an m-of-n wallet.")]),e._v(" "),s("li",[e._v("Each party generates their master private keys independently.")]),e._v(" "),s("li",[e._v("Multisig P2SH is used for all addresses.")]),e._v(" "),s("li",[e._v("BIP32 is used to derive public keys, then create a multisig script,\nand the corresponding P2SH address for that script.")]),e._v(" "),s("li",[e._v("Address generation should not require communication between parties.\n(Thus, all parties must be able to generate all public keys)")]),e._v(" "),s("li",[e._v("Transaction creation and signing requires communication between\nparties.")])]),e._v(" "),s("p",[e._v("This BIP will allow interoperability between various HDPM wallet\nimplementations.")]),e._v(" "),s("h2",{attrs:{id:"specification"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),s("p",[e._v("We define the following levels in BIP32 path:")]),e._v(" "),s("p",[s("code",[e._v("m / purpose' / cosigner_index / change / address_index")])]),e._v(" "),s("p",[e._v("Apostrophe in the path indicates that BIP32 hardened derivation is used.")]),e._v(" "),s("p",[e._v("Each level has special meaning described in the chapters below.")]),e._v(" "),s("h3",{attrs:{id:"purpose"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#purpose"}},[e._v("#")]),e._v(" Purpose")]),e._v(" "),s("p",[e._v("Purpose is a constant set to 45, following the BIP43 recommendation. It\nindicates that the subtree of this node is used according to this\nspecification.")]),e._v(" "),s("p",[s("code",[e._v("m / 45' / *")])]),e._v(" "),s("p",[e._v("Hardened derivation is used at this level.")]),e._v(" "),s("h3",{attrs:{id:"cosigner-index-cosigner-index"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cosigner-index-cosigner-index"}},[e._v("#")]),e._v(" Cosigner Index {#cosigner_index}")]),e._v(" "),s("p",[e._v('The index of the party creating a P2SH multisig address. The indices can\nbe determined independently by lexicographically sorting the purpose\npublic keys of each cosigner. Each cosigner creates addresses on its own\nbranch, even though they have independent extended master public key, as\nexplained in the "Address generation" section.')]),e._v(" "),s("p",[e._v("Note that the master public key is not shared amongst the cosigners.\nOnly the hardened purpose extended public key is shared, and this is\nwhat is used to derive child extended public keys.")]),e._v(" "),s("p",[e._v("Software should only use indices corresponding to each of the N\ncosigners sequentially. For example, for a 2-of-3 HDPM wallet, having\nthe following purpose public keys:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",[s("code",[e._v("03a473275a750a20b7b71ebeadfec83130c014da4b53f1c4743fcf342af6589a38\n039863fb5f07b667d9b1ca68773c6e6cdbcac0088ffba9af46f6f6acd153d44463\n03f76588e06c0d688617ef365d1e58a7f1aa84daa3801380b1e7f12acc9a69cd13\n")])])]),s("p",[e._v("it should use "),s("code",[e._v("m / 45 ' / 0 / *")]),e._v(" for\n"),s("code",[e._v("039863fb5f07b667d9b1ca68773c6e6cdbcac0088ffba9af46f6f6acd153d44463")]),e._v(",\n"),s("code",[e._v("m / 45 ' / 1 / *")]),e._v(" for\n"),s("code",[e._v("03a473275a750a20b7b71ebeadfec83130c014da4b53f1c4743fcf342af6589a38")]),e._v(",\nand "),s("code",[e._v("m / 45 ' / 2 / *")]),e._v(" for\n"),s("code",[e._v("03f76588e06c0d688617ef365d1e58a7f1aa84daa3801380b1e7f12acc9a69cd13")]),e._v(", as\ndictated by their lexicographical order.")]),e._v(" "),s("p",[e._v('Software needs to discover all used indexes when importing the seed from\nan external source. Such algorithm is described in "Address discovery"\nchapter.')]),e._v(" "),s("p",[e._v("Non-hardened derivation is used at this level.")]),e._v(" "),s("h3",{attrs:{id:"change"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#change"}},[e._v("#")]),e._v(" Change")]),e._v(" "),s("p",[e._v("Constant 0 is used for external chain and constant 1 for internal chain\n(also known as change addresses). External chain is used for addresses\nthat are meant to be visible outside of the wallet (e.g. for receiving\npayments). Internal chain is used for addresses which are not meant to\nbe visible outside of the wallet and is used for return transaction\nchange.")]),e._v(" "),s("p",[e._v("For example, if cosigner 2 wants to generate a change address, he would\nuse "),s("code",[e._v("m / 45 ' / 2 / 1 / *")]),e._v(", and "),s("code",[e._v("m / 45 ' / 2 / 0 / *")]),e._v(" for a receive\naddress.")]),e._v(" "),s("p",[e._v("Non-hardened derivation is used at this level.")]),e._v(" "),s("h3",{attrs:{id:"address-index-address-index"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#address-index-address-index"}},[e._v("#")]),e._v(" Address Index {#address_index}")]),e._v(" "),s("p",[e._v("Addresses are numbered from index 0 in sequentially increasing manner.\nThis number is used as child index in BIP32 derivation.")]),e._v(" "),s("p",[e._v("Non-hardened derivation is used at this level.")]),e._v(" "),s("h3",{attrs:{id:"hdpm-wallet-high-level-description-hdpm-wallet-high-level-description"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hdpm-wallet-high-level-description-hdpm-wallet-high-level-description"}},[e._v("#")]),e._v(" HDPM Wallet High-level Description {#hdpm_wallet_high_level_description}")]),e._v(" "),s("p",[e._v("Each party generates their own extended master keypair and shares the\nextended purpose' public key with the others, which is stored\nencrypted. Each party can generate any of the other's derived public\nkeys, but only his own private keys.")]),e._v(" "),s("h3",{attrs:{id:"address-generation-procedure-address-generation-procedure"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#address-generation-procedure-address-generation-procedure"}},[e._v("#")]),e._v(" Address Generation Procedure {#address_generation_procedure}")]),e._v(" "),s("p",[e._v("When generating an address, each party can independently generate the N\nneeded public keys. They do this by deriving the public key in each of\nthe different trees, but using the same path. They can then generate the\nmultisig script (by lexicographically sorting the public keys) and the\ncorresponding p2sh address. In this way, each path corresponds to an\naddress, but the public keys for that address come from different trees.")]),e._v(" "),s("h4",{attrs:{id:"receive-address-case-receive-address-case"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#receive-address-case-receive-address-case"}},[e._v("#")]),e._v(" Receive address case {#receive_address_case}")]),e._v(" "),s("p",[e._v("Each cosigner generates addresses only on his own branch. One of the n\ncosigners wants to receive a payment, and the others are offline. He\nknows the last used index in his own branch, because only he generates\naddresses there. Thus, he can generate the public keys for all of the\nothers using the next index, and calculate the needed script for the\naddress.")]),e._v(" "),s("p",[e._v("Example: Cosigner #2 wants to receive a payment to the shared wallet.\nHis last used index on his own branch is 4. Then, the path for the next\nreceive address is "),s("code",[e._v("m/45'/2/0/5")]),e._v(". He uses this same path in all of the\ncosigners trees to generate a public key for each one, and from that he\ngets the new p2sh address.")]),e._v(" "),s("h4",{attrs:{id:"change-address-case-change-address-case"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#change-address-case-change-address-case"}},[e._v("#")]),e._v(" Change address case {#change_address_case}")]),e._v(" "),s("p",[e._v("Again, each cosigner generates addresses only on his own branch. One of\nthe n cosigners wants to create an outgoing payment, for which he'll\nneed a change address. He generates a new address using the same\nprocedure as above, but using a separate index to track the used change\naddresses.")]),e._v(" "),s("p",[e._v("Example: Cosigner #5 wants to send a payment from the shared wallet,\nfor which he'll need a change address. His last used change index on\nhis own branch is 11. Then, the path for the next change address is\n"),s("code",[e._v("m/45'/5/1/12")]),e._v(". He uses this same path in all of the cosigners trees to\ngenerate a public key for each one, and from that he gets the new p2sh\naddress.")]),e._v(" "),s("h3",{attrs:{id:"transaction-creation-and-signing-transaction-creation-and-signing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#transaction-creation-and-signing-transaction-creation-and-signing"}},[e._v("#")]),e._v(" Transaction creation and signing {#transaction_creation_and_signing}")]),e._v(" "),s("p",[e._v("When creating a transaction, first one of the parties creates a\nTransaction Proposal. This is a transaction that spends some output\nstored in any of the p2sh multisig addresses (corresponding to any of\nthe copayers' branches). This proposal is sent to the other parties,\nwho decide if they want to sign. If they approve the proposal, they can\ngenerate their needed private key for that specific address (using the\nsame path that generated the public key in that address, but deriving\nthe private key instead), and sign it. Once the proposal reaches m\nsignatures, any cosigner can broadcast it to the network, becoming\nfinal. The specifics of how this proposal is structured, and the\nprotocol to accept or reject it, belong to another BIP, in my opinion.")]),e._v(" "),s("h3",{attrs:{id:"address-discovery-address-discovery"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#address-discovery-address-discovery"}},[e._v("#")]),e._v(" Address discovery {#address_discovery}")]),e._v(" "),s("p",[e._v("When the master seed is imported from an external source the software\nshould start to discover the addresses in the following manner:")]),e._v(" "),s("ol",[s("li",[e._v("for each cosigner:")]),e._v(" "),s("li",[e._v("derive the cosigner's node ("),s("code",[e._v("m / 45' / cosigner_index")]),e._v(")")]),e._v(" "),s("li",[e._v("for both the external and internal chains on this node\n("),s("code",[e._v("m / 45' / cosigner_index / 0")]),e._v(" and "),s("code",[e._v("m / 45' / cosigner_index / 1")]),e._v("):")]),e._v(" "),s("li",[e._v("scan addresses of the chain; respect the gap limit described below")])]),e._v(" "),s("p",[e._v("Please note that the algorithm uses the transaction history, not address\nbalances, so even if the address has 0 coins, the program should\ncontinue with discovery. Opposite to BIP44, each cosigner branch needs\nto be checked, even if the earlier ones don't have transactions")]),e._v(" "),s("h3",{attrs:{id:"address-gap-limit-address-gap-limit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#address-gap-limit-address-gap-limit"}},[e._v("#")]),e._v(" Address gap limit {#address_gap_limit}")]),e._v(" "),s("p",[e._v("Address gap limit is currently set to 20. If the software hits 20 unused\naddresses (no transactions associated with that address) in a row, it\nexpects there are no used addresses beyond this point and stops\nsearching the address chain.")]),e._v(" "),s("p",[e._v("Wallet software should warn when user is trying to exceed the gap limit\non an external chain by generating a new address.")]),e._v(" "),s("h3",{attrs:{id:"rationale"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),s("p",[e._v("This structure provides a general way of doing HDPM wallets between\nm-of-n parties. Here are some explanations about the design decisions\nmade.")]),e._v(" "),s("p",[e._v("The reason for using separate branches for each cosigner is we don't\nwant two of them generating the same address and receiving simultaneous\npayments to it. The ideal case is that each address receives at most one\npayment, requested by the corresponding cosigner.")]),e._v(" "),s("h2",{attrs:{id:"examples"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[e._v("#")]),e._v(" Examples")]),e._v(" "),s("p",[e._v("cosigner_index   change    address_index   path")]),e._v(" "),s("hr"),e._v(" "),s("p",[e._v("first            receive   first           m / 45' / 0 / 0 / 0\nfirst            receive   second          m / 45' / 0 / 0 / 1\nfirst            receive   fifth           m / 45' / 0 / 0 / 4\nfirst            change    first           m / 45' / 0 / 1 / 0\nfirst            change    second          m / 45' / 0 / 1 / 1\nsecond           receive   first           m / 45' / 1 / 0 / 0\nthird            change    tenth           m / 45' / 2 / 1 / 9")]),e._v(" "),s("h2",{attrs:{id:"compatible-wallets-compatible-wallets"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#compatible-wallets-compatible-wallets"}},[e._v("#")]),e._v(" Compatible wallets {#compatible_wallets}")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://copay.io",title:"wikilink",target:"_blank",rel:"noopener noreferrer"}},[e._v("Copay wallet"),s("OutboundLink")],1),e._v("\n("),s("a",{attrs:{href:"https://github.com/bitpay/copay",title:"wikilink",target:"_blank",rel:"noopener noreferrer"}},[e._v("source"),s("OutboundLink")],1),e._v(")")])]),e._v(" "),s("h2",{attrs:{id:"reference"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reference"}},[e._v("#")]),e._v(" Reference")]),e._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"bip-0032.mediawiki",title:"wikilink"}},[e._v("BIP32 - Hierarchical Deterministic\nWallets")])]),e._v(" "),s("li",[s("a",{attrs:{href:"bip-0043.mediawiki",title:"wikilink"}},[e._v("BIP43 - Purpose Field for Deterministic\nWallets")])]),e._v(" "),s("li",[s("a",{attrs:{href:"https://www.mail-archive.com/bitcoin-development@lists.sourceforge.net/msg05156.html",title:"wikilink",target:"_blank",rel:"noopener noreferrer"}},[e._v("Original mailing list\ndiscussion"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);a.default=n.exports}}]);