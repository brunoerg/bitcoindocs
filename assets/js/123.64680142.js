(window.webpackJsonp=window.webpackJsonp||[]).push([[123],{497:function(e,t,n){"use strict";n.r(t);var a=n(43),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_98"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_98"}},[e._v("#")]),e._v(" 98")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("  BIP: 98\n  Layer: Consensus (soft fork)\n  Title: Fast Merkle Trees\n  Author: Mark Friedenbach <mark@friedenbach.org>\n          Kalle Alm <kalle.alm@gmail.com>\n          BtcDrak <btcdrak@gmail.com>\n  Comments-Summary: No comments yet.\n  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-0098\n  Status: Draft\n  Type: Standards Track\n  Created: 2017-08-24\n  License: CC-BY-SA-4.0\n  License-Code: MIT\n")])])]),n("h2",{attrs:{id:"abstract"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#abstract"}},[e._v("#")]),e._v(" Abstract")]),e._v(" "),n("p",[e._v("In many applications it is useful to prove membership of a data element\nin a set without having to reveal the entire contents of that set. The\nMerkle hash-tree, where inner/non-leaf nodes are labeled with the hash\nof the labels or values of its children, is a cryptographic tool that\nachieves this goal. Bitcoin uses a Merkle hash-tree construct for\ncommitting the transactions of a block into the block header. This\nparticular design, created by Satoshi, suffers from a serious flaw\nrelated to duplicate entries documented in the National Vulnerability\nDatabase as CVE-2012-2459[1], and also suffers from less than optimal\nperformance due to unnecessary double-hashing.")]),e._v(" "),n("p",[e._v("This Bitcoin Improvement Proposal describes a more efficient Merkle\nhash-tree construct that is not vulnerable to CVE-2012-2459 and achieves\nan approximate 55% decrease in hash-tree construction and validation\ntimes as compared with fully optimized implementations of the Satoshi\nMerkle hash-tree construct.")]),e._v(" "),n("h2",{attrs:{id:"copyright"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#copyright"}},[e._v("#")]),e._v(" Copyright")]),e._v(" "),n("p",[e._v("This BIP is licensed under a Creative Commons Attribution-ShareAlike\nlicense. All provided source code is licensed under the MIT license.")]),e._v(" "),n("h2",{attrs:{id:"motivation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#motivation"}},[e._v("#")]),e._v(" Motivation")]),e._v(" "),n("p",[e._v("A Merkle hash-tree is a directed acyclic graph data structure where all\nnon-terminal nodes are labeled with the hash of combined labels or\nvalues of the node(s) it is connected to. Bitcoin uses a unique Merkle\nhash-tree construct invented by Satoshi for calculating the block header\ncommitment to the list of transactions in a block. While it would be\nconvenient for new applications to make use of this same data structure\nso as to share implementation and maintenance costs, there are three\nprinciple drawbacks to reuse.")]),e._v(" "),n("p",[e._v("First, Satoshi's Merkle hash-tree has a serious vulnerability[1]\nrelated to duplicate tree entries that can cause bugs in protocols that\nuse it. While it is possible to secure protocols and implementations\nagainst exploit of this flaw, it requires foresight and it is a bit more\ntricky to design secure protocols that work around this vulnerability.\nDesigners of new protocols ought avoid using the Satoshi Merkle\nhash-tree construct where at all possible in order to responsibly\ndecrease the likelihood of downstream bugs in naïve implementations.")]),e._v(" "),n("p",[e._v("Second, Satoshi's Merkle hash-tree performs an unnecessary number of\ncryptographic hash function compression rounds, resulting in\nconstruction and validation times that are approximately three (3) times\nmore computation than is strictly necessary in a naïve implementation,\nor 2.32x more computation in an implementation specialized for this\npurpose only[2]. New implementations that do not require backwards\ncompatibility ought to consider hash-tree implementations that do not\ncarry this unnecessary performance hit.")]),e._v(" "),n("p",[e._v("Third, Satoshi's algorithm presumes construction of a tree index from\nan ordered list, and therefore is designed to support balanced trees\nwith a uniform path length from root to leaf for all elements in the\ntree. Many applications, on the other hand, benefit from having\nunbalanced trees, particularly if the shorter path is more likely to be\nused. While it is possible to make a few elements of a Satoshi hash-tree\nhave shorter paths than the others, the tricks for doing so are\ndependent on the size of the tree and not very flexible.")]),e._v(" "),n("p",[e._v("Together these three reasons provide justification for specifying a\nstandard Merkle hash-tree structure for use in new protocols that fixes\nthese issues. This BIP describes such a structure, and provides an\nexample implementation.")]),e._v(" "),n("h2",{attrs:{id:"specification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#specification"}},[e._v("#")]),e._v(" Specification")]),e._v(" "),n("p",[e._v("A Merkle hash-tree as defined by this BIP is an arbitrarily-balanced\nbinary tree whose terminal/leaf nodes are labelled with the\ndouble-SHA256 hashes of data, whose format is outside the scope of this\nBIP, and inner nodes with labels constructed from the fast-SHA256 hash\nof its children's labels. The following image depicts an example\nunbalanced hash-tree:")]),e._v(" "),n("p",[e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(':   ![](bip-0098/unbalanced-hash-tree.png "fig:bip-0098/unbalanced-hash-tree.png")\n')])])]),n("p",[n("strong",[e._v("A")]),e._v(", "),n("strong",[e._v("B")]),e._v(", and "),n("strong",[e._v("C")]),e._v(" are leaf labels, 32-byte double-SHA256 hashes of\nthe data associated with the leaf. "),n("strong",[e._v("Node")]),e._v(" and "),n("strong",[e._v("Root")]),e._v(" are inner\nnodes, whose labels are fast-SHA256 (defined below) hashes of their\nrespective children's labels. "),n("strong",[e._v("Node")]),e._v(" is labelled with the fast-SHA256\nhash of the concatenation of "),n("strong",[e._v("B")]),e._v(" and "),n("strong",[e._v("C")]),e._v(". "),n("strong",[e._v("Root")]),e._v(" is labelled with\nthe fast-SHA256 hash of the concatenation of "),n("strong",[e._v("A")]),e._v(" and "),n("strong",[e._v("Node")]),e._v(", and is\nthe "),n("em",[e._v("Merkle root")]),e._v(" of the tree. Nodes with single children are not\nallowed.")]),e._v(" "),n("p",[e._v("The "),n("em",[e._v("double-SHA256")]),e._v(" cryptographic hash function takes an\narbitrary-length data as input and produces a 32-byte hash by running\nthe data through the SHA-256 hash function as specified in FIPS\n180-4[3], and then running the same hash function again on the 32-byte\nresult, as a protection against length-extension attacks.")]),e._v(" "),n("p",[e._v("The "),n("em",[e._v("fast-SHA256")]),e._v(" cryptographic hash function takes two 32-byte hash\nvalues, concatenates these to produce a 64-byte buffer, and applies a\nsingle run of the SHA-256 hash function with a custom 'initialization\nvector' (IV) and without message paddding. The result is a 32-byte\n'midstate' which is the combined hash value and the label of the inner\nnode. The changed IV protects against path-length extension attacks\n(grinding to interpret a hash as both an inner node and a leaf).\nfast-SHA256 is only defined for two 32-byte inputs. The custom IV is the\nintermediate hash value generated after performing a standard SHA-256 of\nthe following hex-encoded bytes and extracting the midstate:")]),e._v(" "),n("p",[n("code",[e._v("cbbb9d5dc1059ed8 e7730eaff25e24a3 f367f2fc266a0373 fe7a4d34486d08ae")]),n("br"),e._v(" "),n("code",[e._v("d41670a136851f32 663914b66b4b3c23 1b9e3d7740a60887 63c11d86d446cb1c")])]),e._v(" "),n("p",[e._v("This data is the first 512 fractional bits of the square root of 23, the\n9th prime number. The resulting midstate is used as IV for the\nfast-SHA256 cryptographic hash function:")]),e._v(" "),n("p",[n("code",[e._v("static unsigned char _MidstateIV[32] =")]),n("br"),e._v(" "),n("code",[e._v("{ 0x89, 0xcc, 0x59, 0xc6, 0xf7, 0xce, 0x43, 0xfc,")]),n("br"),e._v(" "),n("code",[e._v("0xf6, 0x12, 0x67, 0x0e, 0x78, 0xe9, 0x36, 0x2e,")]),n("br"),e._v(" "),n("code",[e._v("0x76, 0x8f, 0xd2, 0xc9, 0x18, 0xbd, 0x42, 0xed,")]),n("br"),e._v(" "),n("code",[e._v("0x0e, 0x0b, 0x9f, 0x79, 0xee, 0xf6, 0x8a, 0x24 };")])]),e._v(" "),n("p",[e._v('As fast-SHA256 is only defined for two (2) 32-byte hash inputs, there\nare necessarily two special cases: an empty Merkle tree is not allowed,\nnor is any root hash defined for such a "tree"; and a Merkle tree with\na single value has a root hash label equal to that self-same value of\nthe leaf branch, the only node in the tree (a passthrough operation with\nno hashing).')]),e._v(" "),n("h3",{attrs:{id:"rationale"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rationale"}},[e._v("#")]),e._v(" Rationale")]),e._v(" "),n("p",[e._v("The fast-SHA256 hash function can be calculated 2.32x faster than a\nspecialized double-SHA256 implementation[2], or three (3) times faster\nthan an implementation applying a generic SHA-256 primitive twice, as\nhashing 64 bytes of data with SHA-256 as specified by FIPS 180-4[3]\ntakes two compression runs (because of message padding) and then a third\ncompression run for the double-SHA256 construction. Validating a\nfast-SHA256 Merkle root is therefore more than twice as fast as the\ndouble-SHA256 construction used by Satoshi in bitcoin. Furthermore the\nfastest fast-SHA256 implementation "),n("em",[e._v("is")]),e._v(" the generic SHA-256\nimplementation, enabling generic circuitry and code reuse without a cost\nto performance.")]),e._v(" "),n("p",[e._v("The application of fast-SHA256 to inner node label updates is safe in\nthis limited domain because the inputs are hash values and fixed in\nnumber and in length, so the sorts of attacks prevented by message\npadding and double-hashing do not apply.")]),e._v(" "),n("p",[e._v("The 'initialization vector' for fast-SHA256 is changed in order to\nprevent a category of attacks on higher level protocols where a partial\ncollision can serve as both a leaf hash and as an inner node commitment\nto another leaf hash. The IV is computed using standard SHA-256 plus\nmidstate extraction so as to preserve compatibility with cryptographic\nlibrary interfaces that do not support custom IVs, at the cost of a 2x\nperformance hit if neither custom IVs nor resuming from midstate are\nsupported. The data hashed is a nothing-up-my-sleeve number that is\nunlikely to have a known hash preimage. The prime 23 was chosen as the\nleading fractional bits of the first eight (8) primes, two (2) through\nnineteen (19), are constants used in the setup of SHA-256 itself. Using\nthe next prime in sequence reduces the likelihood of introducing\nweakness due to reuse of a constant factor.")]),e._v(" "),n("p",[e._v('The Merkle root hash of a single element tree is a simple pass-through\nof the leaf hash without modification so as to allow for chained\nvalidation of split proofs. This is particularly useful when the\nvalidation environment constrains proof sizes, such as push limits in\nBitcoin script. Chained validation allows a verifier to split one proof\ninto two or more, where the leaf is shown to be under an inner node, and\nthat inner node is shown to be under the root. Without pass-through\nhashing in a single-element tree, use of chained validation would\nunnecessarily introduce a minimum path length requirement equal to the\nnumber of chain links. Pass-through hashing of single elements allows\ninstead for one or more of the chained validations to use a "NOP"\nproof consisting of a zero-length path, thereby allowing, for example, a\nfixed series of four (4) chained validations to verify a length three\n(3) or shorter path.')]),e._v(" "),n("h2",{attrs:{id:"inclusion-proofs-inclusion-proofs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#inclusion-proofs-inclusion-proofs"}},[e._v("#")]),e._v(" Inclusion Proofs {#inclusion_proofs}")]),e._v(" "),n("p",[e._v("An important use of Merkle hash-trees is the ability to compactly prove\nmembership with log-sized proofs. This section specifies a standard\nencoding for a multi-element inclusion proof.")]),e._v(" "),n("p",[e._v("To prove that a set of hashes is contained within a Merkle tree with a\ngiven root requires four pieces of information:")]),e._v(" "),n("ol",[n("li",[e._v("The root hash of the Merkle tree;")]),e._v(" "),n("li",[e._v("The hash values to be verified, a set usually consisting of the\ndouble-SHA256 hash of data elements, but potentially the labels of\ninner nodes instead, or both;")]),e._v(" "),n("li",[e._v("The paths from the root to the nodes containing the values under\nconsideration, expressed as a serialized binary tree structure; and")]),e._v(" "),n("li",[e._v("The hash values of branches not taken along those paths.")])]),e._v(" "),n("p",[e._v("Typically the last two elements, the paths and the elided branch hashes,\nare lumped together and referred to as the "),n("em",[e._v("proof")]),e._v(".")]),e._v(" "),n("p",[e._v("Serialization begins with a variable-length integer (VarInt) used to\nencode N, the number of internal nodes in the proof. Next the structure\nof the tree is traversed using depth-first, left-to-right, pre-order\nalgorithm to visit each internal nodes, which are serialized using a\npacked 3-bit representation for the configuration of each node,\nconsuming "),n("code",[e._v("(3*N + 7) / 8")]),e._v(" bytes. Then the number skipped hashes (those\nincluded in the proof, not verified by the proof) is serialized as a\nvariable-length integer (VarInt), followed by the hashes themselves in\nthe order previously traversed.")]),e._v(" "),n("p",[e._v("There are eight possible configurations of internal nodes, as given in\nthe following diagram:")]),e._v(" "),n("p",[e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(':   ![](bip-0098/node-variants.png "fig:bip-0098/node-variants.png")\n')])])]),n("p",[e._v('In this diagram, DESCEND means the branch links to another internal\nnode, as indicated by its child graph elements labeled "..."; SKIP\nmeans the branch contains a hash of an elided subtree or element, and\nthe fast-SHA256 root hash of this subtree or double-SHA256 hash of the\nelement is included in the proof structure; and VERIFY means the branch\ncontains an externally provided hash that is needed as witness for the\nverification of the proof. In tabular form, these code values are:')]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("Code   Left      Right\n000    VERIFY    SKIP\n001    VERIFY    VERIFY\n010    VERIFY    DESCEND\n011    DESCEND   SKIP\n100    DESCEND   VERIFY\n101    DESCEND   DESCEND\n110    SKIP      VERIFY\n111    SKIP      DESCEND")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("These 3-bit codes are packed into a byte array such that eight (8) codes\nwould fit in every three (3) bytes. The order of filling a byte begins\nwith the most significant bit "),n("code",[e._v("0x80")]),e._v(" and ends with the least significant\nbit "),n("code",[e._v("0x01")]),e._v(". Unless the number of inner nodes is a multiple of eight (8),\nthere will be excess low-order bits in the final byte of serialization.\nThese excess bits must be zero.")]),e._v(" "),n("p",[e._v("Note that the tree serialization is self-segmenting. By tracking tree\nstructure a proof reader will know when the parser has reached the last\ninternal node. The number of inner nodes serialized in the proof MUST\nequal the number of nodes inferred from the tree structure itself.\nSimilarly, the number of SKIP hashes can also be inferred from the tree\nstructure as serialized, and MUST equal the number of hashes provided\nwithin the proof.")]),e._v(" "),n("p",[e._v("The single-hash proof has N=0 (the number of inner nodes), the tree\nstructure is not serialized (as there are no inner nodes), and the\nnumber of SKIP hashes can be either 0 or 1.")]),e._v(" "),n("h3",{attrs:{id:"example"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#example"}},[e._v("#")]),e._v(" Example")]),e._v(" "),n("p",[e._v("Consider the following Merkle tree structure:")]),e._v(" "),n("p",[e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(':   ![](bip-0098/traversal-example.png "fig:bip-0098/traversal-example.png")\n')])])]),n("p",[e._v("There are six (6) internal nodes. The depth-first, left-to-right,\npre-order traversal of the tree visits these nodes in the following\norder: A, B, D, F, C, then E. There are three (3) skipped hashes,\nvisited in the following order: 0x00..., 0x66..., and 0x22... The\nremaining four (4) hashes are provided at runtime to be verified by the\nproof.")]),e._v(" "),n("hr"),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v("      Byte 1     Byte 2     Byte 3\n")])])]),n("p",[e._v("Bits    76543210   76543210   76543210\nNodes   AAABBBDD   DFFFCCCE   EE------\nCode    10111101   10000100   01000000")]),e._v(" "),n("hr"),e._v(" "),n("p",[e._v("The serialization begins with the VarInt encoded number of inner nodes,\n"),n("code",[e._v("0x06")]),e._v(", followed by the tree serialization itself, "),n("code",[e._v("0xbd8440")]),e._v(". Next the\nnumber of SKIP hashes is VarInt encoded, "),n("code",[e._v("0x03")]),e._v(", followed by the three\n(3) hashes in sequence. The resulting 101 byte proof, encoded in\nbase64:.")]),e._v(" "),n("p",[n("code",[e._v("Br2EQAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGZmZmZmZmZmZmZmZmZmZmZmZmZm")]),n("br"),e._v(" "),n("code",[e._v("ZmZmZmZmZmZmZmZmREREREREREREREREREREREREREREREREREREREREREQ=")])]),e._v(" "),n("h3",{attrs:{id:"rationale-rationale-1"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#rationale-rationale-1"}},[e._v("#")]),e._v(" Rationale {#rationale_1}")]),e._v(" "),n("p",[e._v("The 3-bit encoding for inner nodes allows encoding all relevant\nconfigurations of the nodes where the left and right branches can each\nbe one of {DESCEND, SKIP, VERIFY}. The excluded 9th possibility would\nhave both branches as SKIP:")]),e._v(" "),n("p",[e._v(":")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",[n("code",[e._v(':   ![](bip-0098/skip-skip.png "fig:bip-0098/skip-skip.png")\n')])])]),n("p",[e._v("This possibility is not allowed as for verification purposes it is\nentirely equivalent to the shorter proof where the branch to that node\nwas SKIP'ed. Disallowing a node with two SKIP branches eliminates what\nwould otherwise be a source of proof malleability.")]),e._v(" "),n("p",[e._v("The number of hashing operations required to verify a proof is one less\nthan the number of hashes (SKIP and VERIFY combined), and is exactly\nequal to the number of inner nodes serialized as the beginning of the\nproof as N. The variable-length integer encoding has the property that\nserialized integers, sorted lexigraphically, will also be sorted\nnumerically. Since the first serialized item is the number of inner\nnodes, sorting proofs lexigraphically has the effect of sorting the\nproofs by the amount of work required to verify.")]),e._v(" "),n("p",[e._v("The number of hashes required as input for verification of a proof is\nN+1 minus the number of SKIP hashes, and can be quickly calculated\nwithout parsing the tree structure.")]),e._v(" "),n("p",[e._v("The coding and packing rules for the serialized tree structure were also\nchosen to make lexigraphical comparison useful (or at least not\nmeaningless). If we consider a fully-expanded tree (no SKIP hashes, all\nVERIFY) to be encoding a list of elements in the order traversed\ndepth-first from left-to-right, then we can extract proofs for subsets\nof the list by SKIP'ing the hashes of missing values and recursively\npruning any resulting SKIP,SKIP nodes. Lexigraphically comparing the\nresulting serialized tree structures is the same as lexigraphically\ncomparing lists of indices from the original list verified by the\nderived proof.")]),e._v(" "),n("p",[e._v("Because the number of inner nodes and the number of SKIP hashes is\nextractible from the tree structure, both variable-length integers in\nthe proof are redundant and could have been omitted. However that would\nrequire either construction and storage of the explicit tree in memory\nat deserialization time, or duplication of the relatively complicated\ntree parsing code in both the serialization and verification methods.\nFor that reason (as well as to handle the single-hash edge case) the\nredundant inner node and SKIP hash counts are made explicit in the\nserialization, and the two values must match what is inferred from the\ntree structure for a proof to be valid. This makes deserialization\ntrivial and defers tree construction until verification time, which has\nthe additional benefit of enabling log-space verification algorithms.")]),e._v(" "),n("h2",{attrs:{id:"fast-merkle-lists-fast-merkle-lists"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fast-merkle-lists-fast-merkle-lists"}},[e._v("#")]),e._v(" Fast Merkle Lists {#fast_merkle_lists}")]),e._v(" "),n("p",[e._v("Many applications use a Merkle tree to provide indexing of, or compact\nmembership proofs about the elements in a list. This addendum specifies\nan algorithm that constructs a canonical balanced tree structure for\nlists of various lengths. It differs in a subtle but important way from\nthe algorithm used by Satoshi so as to structurally prevent the\nvulnerability described in [1].")]),e._v(" "),n("ol",[n("li",[e._v("Begin with a list of arbitrary data strings.")]),e._v(" "),n("li",[e._v("Pre-process the list by replacing each element with its\ndouble-SHA256 hash.")]),e._v(" "),n("li",[e._v("If the list is empty, return the zero hash.")]),e._v(" "),n("li",[e._v("While the list has 2 or more elements,\n"),n("ul",[n("li",[e._v("Pass through the list combining adjacent entries with the\nfast-SHA256 hash. If the list has an odd number of elements,\nleave the last element as-is (this fixes [1]). This step\nreduces a list of N elements to ceil(N/2) entries.")])])]),e._v(" "),n("li",[e._v("The last remaining item in the list is the Merkle root.")])]),e._v(" "),n("p",[e._v("This algorithm differs from Merkle lists used in bitcoin in two ways.\nFirst, fast-SHA256 is used instead of double-SHA256 for inner node\nlabels. Second, final entries on an odd-length list are not duplicated\nand hashed, which is the mistake that led to CVE-2012-2459[1].")]),e._v(" "),n("h2",{attrs:{id:"implementation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#implementation"}},[e._v("#")]),e._v(" Implementation")]),e._v(" "),n("p",[e._v("An implementation of this BIP for extraction of Merkle branches and\nfast, log-space Merkle branch validation is available at the following\nGithub repository:")]),e._v(" "),n("p",[n("a",{attrs:{href:"https://github.com/maaku/bitcoin/tree/fast-merkle-tree",target:"_blank",rel:"noopener noreferrer"}},[e._v("1"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("Also included in this repo is a 'merklebranch' RPC for calculating\nroot values and extracting inclusion proofs for both arbitrary trees and\ntrees constructed from lists of values using the algorithm in this BIP,\nand a 'mergemerklebranch' RPC for unifying two or more fast Merkle\ntree inclusion proofs--replacing SKIP hashes in one proof with a\nsubtree extracted from another.")]),e._v(" "),n("h2",{attrs:{id:"deployment"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#deployment"}},[e._v("#")]),e._v(" Deployment")]),e._v(" "),n("p",[e._v("This BIP is used by BIP116 (MERKLEBRANCHVERIFY)[4] to add Merkle\ninclusion proof verification to script by means of a soft-fork NOP\nexpansion opcode. Deployment of MERKLEBRANCHVERIFY would make the\ncontents of this BIP consensus critical. The deployment plan for BIP116\nis covered in the text of that BIP.")]),e._v(" "),n("h2",{attrs:{id:"compatibility"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#compatibility"}},[e._v("#")]),e._v(" Compatibility")]),e._v(" "),n("p",[e._v("This BIP on its own does not cause any backwards incompatibility.")]),e._v(" "),n("h2",{attrs:{id:"references"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),n("p",[e._v("[1] "),n("a",{attrs:{href:"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2012-2459",target:"_blank",rel:"noopener noreferrer"}},[e._v("National Vulnerability Database:\nCVE-2012-2459"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("[2] "),n("a",{attrs:{href:"https://github.com/sipa/bitcoin/tree/201709_dsha256_64",target:"_blank",rel:"noopener noreferrer"}},[e._v("github.com:sipa/bitcoin\n201709_dsha256_64"),n("OutboundLink")],1),e._v("\nPieter Wuille, September 2017, personal communication. By making use of\nknowledge that the inputs at each stage are fixed length, Mr. Wuille was\nable to achieve a 22.7% reduction in the time it takes to compute the\ndouble-SHA256 hash of 64 bytes of data, the hash aggregation function of\nthe Satoshi Merkle tree construction.")]),e._v(" "),n("p",[e._v("[3] "),n("a",{attrs:{href:"http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("Secure Hash\nStandard"),n("OutboundLink")],1)]),e._v(" "),n("p",[e._v("[4] "),n("a",{attrs:{href:"https://github.com/bitcoin/bips/blob/master/bip-0116.mediawiki",target:"_blank",rel:"noopener noreferrer"}},[e._v("BIP 116\nMERKLEBRANCHVERIFY"),n("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=i.exports}}]);